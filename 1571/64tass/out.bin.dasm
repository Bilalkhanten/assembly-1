
;6502/65C02/65816/CPU64/DTV Turbo Assembler V1.45 listing file of "serlib.asm"
;done on Sat Dec 13 15:24:19 2014

						.include "wd1770.asm"

;******  Processing file "wd1770.asm"


;******  Return to file "serlib.asm"

						.include "com.asm"

;******  Processing file "com.asm"


;******  Return to file "serlib.asm"

						.include "equate.asm"

;******  Processing file "equate.asm"

=0001					bit0	  = 1
=0002					bit1	  = 2
=0004					bit2	  = 4
=0008					bit3	  = 8
=0010					bit4	  = 16
=0020					bit5	  = 32
=0040					bit6	  = 64
=0080					bit7	  = 128
=00ff					all	  = 255
=0300					buff0    =$0300 ; buffers
=0400					buff1    =$0400
=0500					buff2    =$0500
=0600					buff3    =$0600
=0700					buff4    =$0700
=0024					skip1    =$24   ; bit zp
=002c					skip2    =$2c   ; bit abs
=0006					numjob   =6     ; number of jobs
=0006					notfnd   =6
=0080					lrf      =$80   ; last record flag
=0040					dyfile   =$40   ; dirty flag for rr file
=0020					ovrflo   =$20   ; rr print overflow
=0006					nssl     =6     ; # of side-sector links
=0010					ssioff   =4+nssl+nssl
=0078					nssp     =120   ; # of ptrs in ss
=0006					mxchns   =6     ; max # channels in system
=0012					maxsa    =18    ; max sa # +1
=000d					cr       =13    ; carriage return
=0010					bindx    =16    ; bam offset index
=0005					bfcnt    =5     ; available  buffer count
=000a					cbptr    =bfcnt+bfcnt
=0005					errchn   =mxchns-1
=0010					errsa    =16    ; error channel sa #
=0004					cmdchn   =mxchns-2
=000f					lxint    =%00001111
=000f					cmdsa    =15    ; command channel sa #
=0002					apmode   =2     ; open append mode
=0003					mdmode   =3     ; open modify mode
=0001					wtmode   =1     ; open write mode
=0004					reltyp   =4     ; open relative type
=0007					dirtyp   =7     ; open direct type
=0001					seqtyp   =1     ; open sequential type
=0002					prgtyp   =2     ; open program type
=0003					usrtyp   =3     ; open user type
=0007					typmsk   =7     ; mask for type bits
=0011					irsa     =17    ; internal read sa #
=0012					iwsa     =18    ; internal write sa #
=0005					mxfils   =5     ; max # filenames in string
=0018					dirlen   =24    ; directory length used
=001b					nbsiz    =27    ; nambuf text size
=0029					cmdlen   =41    ; length of command buffer
=0002					tolong = 2
=0003					tomany = 3
=0004					tobig = 4
=0005					tosmal = 5
=0070					frmtt = $70
=0040					bumpc = $40
=0060					execd = $60
=0080					read = $80
=0090					write = $90
=00d0					jumpc = $d0
=00b0					seek = $b0
=0088					fread = $88
=00c0					bump = $c0
=00b8					secsek = $b8
=00e0					exec = $e0
=0008					led0 = 8
=0000					led1 = 0
=0045					topwrt = $45
=0004					wrtmin = 4
=0008					wrtmax = 8
=0006					rdmax = 6
=0006					blindx = 6
=0005					numsyn = 5
=000b					gap1 = 11
=0001					drvmsk = 1
=0045					toprd = 69
=0041					fm4040 = $41
=003a					tim = 58
=0146					bam_one = $146
=c000					rom = $c000
=0040					tim2 = 64
=0004					gap2 = 4
=00ff					mscnt = 255
=0002					dosver = 2
=0000					sysdirsec = 0
=0000					sysiz = 0
=0000					sysiob = 0
=0000					detwp_dv = 0

;******  Return to file "serlib.asm"

						.include "iodef.asm"

;******  Processing file "iodef.asm"

=003f					unlsn    =$3f   ; unlisten command
=005f					untlk    =$5f   ; untalk command
=0000					notrdy   =$0    ; not ready
=0080					eoiout   =$80   ; talk with eoi
=0008					eoi	 =$08	; eoi
=0008					eoisnd   =$08   ; not(eoi) to send
=0088					rdytlk   =$88   ; talk no eoi
=0001					rdylst   =$1    ; ready to listen
=0089					rndrdy   =rdytlk+rdylst
=0081					rndeoi   =eoiout+rdylst
=1800					pb	=$1800		; port b
=0001					datin		=bit0	; in
=0002					datout		=bit1	; out
=0004					clkin		=bit2	; in
=0008					clkout		=bit3	; out
=0010					atna		=bit4	; out
=0002					fsdir		=bit1	; out
=400c					sdr	=$400c		; serial data register
=400d					icr     =$400d		; interrupt control register
=400e					cra	=$400e		; control register a
.2000					wdcmd
.2000					wdstat
.2001					wdtrk
.2002					wdsec
.2003					wddat
=1c00					ledprt = $1c00
=180d					ifr1 = $180d
=1801					pa1 = $1801
=4005					tima_h = $4005
=4004					tima_l = $4004
=180f					pota1 = $180f
=1804					t1lc1 = $1804
=180c					pcr1 = $180c
=1807					t1hl1 = $1807
=180e					ier1 = $180e
=1c00					byt_clr = $1c00
=180b					acr1 = $180b
=1802					ddrb1 = $1802
=1806					t1ll1 = $1806
=1805					t1hc1 = $1805
=1803					ddra1 = $1803

;******  Return to file "serlib.asm"

					        .include "lccio.asm"

;******  Processing file "lccio.asm"

=2004					cntst=  *
=1805					timer1   =$1805         ;  timer 1 counter
.1c00					dskcnt
.1c01					data2
.1c02					ddrb2
.1c03					ddra2
.1c04					t1lc2
.1c05					t1hc2
.1c06					t1ll2
.1c07					t1hl2
.1c08					t2ll2
.1c09					t2lh2
.1c0a					sr2
.1c0b					acr2
.1c0c					pcr2
.1c0d					ifr2
.1c0e					ier2

;******  Return to file "serlib.asm"

						.include "ramvar.asm"

;******  Processing file "ramvar.asm"

.0000					jobs
.0006					hdrs
.0012					dskid
.0016					header
=001b					info     =$1b;*=*+2          ; controller job information variable
=001b					fmhdpt   =$1b
=001c					wpsw     =$1c;*=*+1          ; write protect change flag
=001e					lwpt     =$1e
=0020					drvst    =$20;*=*+1          ; lcc var's
=0022					drvtrk   =$22;*=*+1
=0023					slflag   =$23
=0024					stab     =$24
=0024					mfmhdr   =$24
=002e					savpnt   =$2e
=0030					bufpnt   =$30;*=*+2          ; buffer pointer
=0032					hdrpnt   =$32
=0034					gcrpnt   =$34
=0035					acltim2  =$35
=0036					bytcnt   =$36
=0037					fastsr   =$37
=0038					bid      =$38
=0039					hbid     =$39
=003a					chksum   =$3a
=003b					tsttrk   =$3b
=003b					switch   =$3b;*=*+1          ; burst command switch
=003c					cpmit    =$3c
=003d					drive    =$3d
=003e					cdrive   =$3e
=003f					jobn     =$3f
=0040					tracc    =$40
=0041					nxtjob   =$41
=0042					nxtrk    =$42
=0043					sectr    =$43
=0044					work     =$44
=0044					mfmsiz_hi=$44
=0045					job      =$45
=0046					ctl_dat  =$46
=0047					dbid     =$47
=0048					acltim   =$48;*=*+2          ; acceleration/decceleration time delay
=0049					savsp    =$49;*=*+1          ; save stack pointer
=004a					steps    =$4a
=004b					tmp      =$4b;*=*+7
=004c					csect    =$4c
=004d					nexts    =$4d
=004e					nxtbf    =$4e
=004f					nxtpnt   =$4f
=0050					gcrflg   =$50
=0051					ftnum    =$51;*=*+1
=0052					btab     =$52
=0056					gtab     =$56
=005e					dkmode   =$5e;*=*+1          ; burst status
=005e					as       =$5e
=005f					ctl_cmd  =$5f
=005f					af       =$5f
=0060					aclstp   =$60
=0060					minsek   =$60;*=*+1          ; burst min. sector #
=0061					rsteps   =$61
=0061					maxsek   =$61;*=*+1          ; "  "  max. "    "
=0062					nxtst    =$62
=0064					minstp   =$64
=0064					cur_trk  =$64
=0065					vnmi     =$65;*=*+2          ; indirect for nmi
=0067					cmd_trk  =$67
=0068					autofg   =$68;*=*+1          ; auto init flag
=0069					secinc   =$69;*=*+1          ; sector inc for seq
=006a					revcnt   =$6a;*=*+1          ; error recovery count
=006d					bmpnt    =$6d;*=*+2          ; bit map pointer
=006b					usrjmp   =$6b;*=*+2          ; user jmp table ptr
=006f					temp     =$6f;*=*+6          ; work space
=006f					t0       =temp
=0070					t1       =temp+1
=0071					t2       =temp+2
=0072					t3       =temp+3
=0073					t4       =temp+4
=0075					ip       =$75;*=*+6          ; indirect ptr variable
=0077					lsnadr   =$77;*=*+1          ; listen address
=0078					tlkadr   =$78;*=*+1          ; talker address
=0079					lsnact   =$79
=007a					tlkact   =$7a
=007c					atnpnd   =$7c
=007b					adrsed   =$7b
=007e					prgtrk   =$7e;*=*+1          ; last prog accessed
=007d					atnact   =$7d
=007f					drvnum	 =$7f
=0080					track    =$80;*=*+1          ; current track
=0081					sector   =$81;*=*+1          ; current sector
=0082					lindx    =$82;*=*+1          ; logical index
=0083					sa       =$83;*=*+1          ; secondary address
=0084					orgsa    =$84;*=*+1          ; original sa
=0085					data     =$85;*=*+1          ; temp data byte
=0086					r0       =$86;*=*+1
=0087					r1       =$87;*=*+1
=0088					r2       =$88;*=*+1
=0089					r3       =$89;*=*+1
=008a					r4       =$8a;*=*+1
=008b					result   =$8b;*=*+4
=008f					accum    =$8f;*=*+5
=0094					dirbuf   =$94;*=*+2
=0096					cmd_sec  =$96
=0097					cpmsek   =$97
=0098					cont     =$98;*=*+1          ; bit counter for ser
=0099					buftab   =$99;*=*+cbptr+4    ; buffer byte pntrs
=00a3					cb       =buftab+cbptr
=00a7					buf0     =$a7;*=*+mxchns
=00ae					buf1     =$ae;*=*+mxchns
=00b5					nbkl     =$b5
=00b5					recl     =$b5;*=*+mxchns
=00bb					nbkh     =$bb
=00bb					rech     =$bb;*=*+mxchns
=00c1					nr       =$c1;*=*+mxchns
=00c7					rs       =$c7;*=*+mxchns
=00cd					ss       =$cd;*=*+mxchns
=00d3					f1ptr    =$d3;*=*+1          ; file stream 1 pointer
=00d4					recptr   =$d4;*=*+1
=00d5					ssnum    =$d5;*=*+1
=00d6					ssind    =$d6;*=*+1
=00d7					relptr   =$d7;*=*+1
=00d8					entsec   =$d8;*=*+mxfils     ; sector of directory entry
=00dd					entind   =$dd;*=*+mxfils     ; index of directory entry
=00e2					fildrv   =$e2;*=*+mxfils     ; default flag, drive #
=00e7					pattyp   =$e7;*=*+mxfils     ; pattern,replace,closed-flags,type
=00ec					filtyp   =$ec;*=*+mxchns     ; channel file type
=00f2					chnrdy   =$f2;*=*+mxchns     ; channel status
=00f8					eoiflg   =$f8;*=*+1          ; temp eoi
=00f9					jobnum   =$f9;*=*+1          ; current job #
=00fa					lrutbl   =$fa;*=*+mxchns-1   ; least recently used table
=00ff					nodrv    =$ff;*=*+1          ; no drive flag
=0100					ovrbuf   =$100
=0101					dskver   =$101;*=*+1          ; disk version
=01af					dside    =$1af
=01b0					mfmcmd   =$1b0
=01b1					side     =$1b1
=01b2					fmtsid   =$1b2
=01b3					vertog   =$1b3
=01b4					swapfg   =$1b4
.0200					cmdbuf
.022a					cmdnum
=022b					lintab   =$22b;*=*+maxsa+1    ; sa:lindx table
=023e					chndat   =$23e;*=*+mxchns     ; channel data byte
=0244					lstchr   =$244;*=*+mxchns     ; channel last char ptr
=024a					type     =$24a;*=*+1          ; active file type
=024b					strsiz   =$24b;*=*+1
=024c					tempsa   =$24c;*=*+1          ; temporary sa
=024d					cmd      =$24d;*=*+1          ; temp job command
=024e					lstsec   =$24e
=024f					bufuse   =$24f;*=*+1          ; buffer allocation
=0251					mdirty   =$251
=0253					entfnd   =$253;*=*+1          ; dir-entry found flag
=0254					dirlst   =$254;*=*+1          ; dir listing flag
=0255					cmdwat   =$255;*=*+1          ; command waiting flag
=0256					linuse   =$256;*=*+1          ; lindx use word
=0257					lbused   =$257;*=*+1          ; last buffer used
=0258					rec      =$258;*=*+1
=0259					trkss    =$259;*=*+1
=025a					secss    =$25a;*=*+1
=025b					lstjob   =$25b;*=*+bfcnt+4    ; last job
=0260					dsec     =$260;*=*+mxchns     ; sec of dir entry
=0266					dind     =$266;*=*+mxchns     ; index of dir entry
=026c					erword   =$26c;*=*+1          ; error word for recovery
=026d					erled    =$26d
=026e					prgdrv   =$26e
=026f					prgsec   =$26f;*=*+1          ; last program sector
=0270					wlindx   =$270;*=*+1          ; write lindx
=0271					mfmsiz_lo =$271
=0272					nbtemp   =$272;*=*+2          ; # blocks temp
=0275					char     =$275;*=*+1          ; char under parser
=0274					cmdsiz   =$274;*=*+1          ; command string size
=0276					limit    =$276;*=*+1          ; ptr limit in compar
=0277					f1cnt    =$277;*=*+1          ; file stream 1 count
=0278					f2cnt    =$278;*=*+1          ; file stream 2 count
=0279					f2ptr    =$279;*=*+1          ; file stream 2 pointer
=027a					filtbl   =$27a;*=*+mxfils+1   ; filename pointer
=0280					filtrk   =$280;*=*+mxfils     ; 1st link/track
=0285					filsec   =$285;*=*+mxfils     ;    /sector
=028a					patflg   =$28a;*=*+1          ; pattern presence flag
=028b					image    =$28b;*=*+1          ; file stream image
=028c					drvcnt   =$28c;*=*+1          ; number of drv searches
=028d					drvflg   =$28d;*=*+1          ; drive search flag
=028e					lstdrv	 =$28e
=028f					found    =$28f;*=*+1          ; found flag in dir searches
=0290					dirsec   =$290;*=*+1          ; directory sector
=0291					delsec   =$291;*=*+1          ; sector of 1st avail entry
=0292					delind   =$292;*=*+1          ; index "
=0293					lstbuf   =$293;*=*+1          ; =0 if last block
=0295					filcnt   =$295;*=*+1          ; counter, file entries
=0294					index    =$294;*=*+1          ; current index in buffer
=0296					typflg   =$296;*=*+1          ; match by type flag
=0297					mode     =$297;*=*+1          ; active file mode (r,w)
=0298					jobrtn   =$298;*=*+1          ; job return flag
=0299					eptr     =$299
=029a					toff     =$29a
=029d					bamis    =$29d
=029b					bamlu    =$29b
=02a1					bami     =$2a1
=02a9					irqjmp   =$2a9
=02ab					mtrcnt   =$2ab
=02ac					maxtrk   =$2ac;*=*+1          ; max track + 1
=02ad					savbm    =$2ad
=02af					lock     =$2af
=02b0					channel  =$2b0
=02b1					nambuf   =$2b1;*=*+36         ; directory buffer
=02d5					errbuf   =$2d5;*=*+36         ; error msg buffer
=02f9					wbam     =$2f9;*=*+1          ; bam status (0=clean)
=02fa					ndbl     =$2fa;*=*+1          ; # of disk blocks free
=02fc					ndbh     =$2fc;*=*+1
=02fe					phase    =$2fe
=0300					bufs     =$300

;******  Return to file "serlib.asm"

						.include "burst.asm"

;******  Processing file "burst.asm"

.8000					signature_lo
.8001					signature_hi

>8002	 53 2f 57 20 2d 20 44 41 		.text  'S/W - DAVID G SIRACUSA',$0D,"H/W - GREG BERLIN",$0D,'1985',$0D
>800a	 56 49 44 20 47 20 53 49 
>8012	 52 41 43 55 53 41 0d 48 
>801a	 2f 57 20 2d 20 47 52 45 
>8022	 47 20 42 45 52 4c 49 4e 
>802a	 0d 31 39 38 35 0d 

.8030					burst_routines
.8030	 ad 74 02	lda $0274		lda  cmdsiz     ; check command size
.8033	 c9 03		cmp #$03		cmp  #3
.8035	 90 2e		bcc $8065		bcc  realus
.8037	 ad 02 02	lda $0202		lda  cmdbuf+2	; get command
.803a	 85 3b		sta $3b			sta  switch	; save info
.803c	 29 1f		and #$1f		and  #$1f
.803e	 aa		tax			tax		; command info
.803f	 0a		asl a			asl  a
.8040	 a8		tay			tay
.8041	 b9 8e 80	lda $808e,y		lda  cmdtbb,y
.8044	 85 75		sta $75			sta  ip
.8046	 b9 8f 80	lda $808f,y		lda  cmdtbb+1,y
.8049	 85 76		sta $76			sta  ip+1
.804b	 e0 1e		cpx #$1e		cpx  #30	; utload ok for 1541 mode
.804d	 f0 07		beq $8056		beq  +
.804f	 ad 0f 18	lda $180f		lda  pota1
.8052	 29 20		and #$20		and  #$20	; 1/2 Mhz ?
.8054	 f0 0f		beq $8065		beq  realus	; 1541 mode...ignore
.8056	 a5 37		lda $37		+	lda  fastsr	; clear clock & error return
.8058	 29 eb		and #$eb		and  #$eb
.805a	 85 37		sta $37			sta  fastsr
.805c	 bd 6e 80	lda $806e,x		lda  cmdctl,x   ; most sig bit set set error recover
.805f	 8d 02 02	sta $0202		sta  cmdbuf+2	; save info here
.8062	 4c e7 aa	jmp $aae7		jmp  ptch65
.8065	 a9 ea		lda #$ea	realus  lda  #<ublock   ; set default block add
.8067	 85 6b		sta $6b		        sta  usrjmp
.8069	 a9 ff		lda #$ff	        lda  #>ublock
.806b	 85 6c		sta $6c		        sta  usrjmp+1
.806d	 60		rts		unused  rts

>806e	 80 81 90 91 b0 b1 f0 f1 	cmdctl   .byte  $80,$81,$90,$91,$b0,$b1,$f0,$f1,$00,$01,$B0,$01,$00,$01,$00,$01
>8076	 00 01 b0 01 00 01 00 01 
>807e	 80 81 90 91 b0 b1 f0 f1 	         .byte  $80,$81,$90,$91,$b0,$b1,$f0,$f1,$00,$01,$B0,$01,$00,$01,$00,$80
>8086	 00 01 b0 01 00 01 00 80 
>808e	 71 83                    	cmdtbb   .word    fstrd  	 ; fast read drv #0 - 0000
>8090	 7f 83                    		 .word    ndkrd 	 ; fast read drv #1 - 0001
>8092	 ec 83                    		 .word    fstwrt         ; fast write drv #0 - 0010
>8094	 f8 83                    		 .word    ndkwrt	 ; fast write drv #1 - 0011
>8096	 8b 84                    	         .word    fstsek         ; seek disk drv #0 - 0100
>8098	 7f 83                    	         .word    ndkrd          ; seek disk drv #1 - 0101
>809a	 b7 84                    	         .word    fstfmt         ; format disk drv #0 - 0110
>809c	 b7 84                    	         .word    fstfmt         ; format disk drv #1 - 0111
>809e	 f1 84                    	         .word    cpmint	 ; interleave disk drv #0 - 1000
>80a0	 f1 84                    	         .word    cpmint	 ; interleave disk drv #1 - 1001
>80a2	 17 85                    		 .word    querdk	 ; query disk format - 1010
>80a4	 7f 83                    	         .word    ndkrd          ; seek disk drv #1 - 1011
>80a6	 6b 85                    		 .word    inqst		 ; return disk status - 1100
>80a8	 7f 83                    		 .word    ndkrd		 ; return disk status - 1101
>80aa	 a5 85                    		 .word    duplc1	 ; backup drv0 to drv1 - 1110
>80ac	 a5 85                    		 .word    duplc1	 ; backup drv1 to drv0 - 1111
>80ae	 71 83                    		 .word    fstrd  	 ; fast read drv #0 - 0000
>80b0	 7f 83                    		 .word    ndkrd 	 ; fast read drv #1 - 0001
>80b2	 ec 83                    		 .word    fstwrt         ; fast write drv #0 - 0010
>80b4	 f8 83                    		 .word    ndkwrt	 ; fast write drv #1 - 0011
>80b6	 8b 84                    	         .word    fstsek         ; seek disk drv #0 - 0100
>80b8	 7f 83                    	         .word    ndkrd          ; seek disk drv #1 - 0101
>80ba	 b7 84                    	         .word    fstfmt
>80bc	 b7 84                    	         .word    fstfmt
>80be	 6d 80                    	         .word    unused
>80c0	 6d 80                    	         .word    unused
>80c2	 17 85                    		 .word    querdk	 ; query disk format - 1010
>80c4	 7f 83                    	         .word    ndkrd          ; seek disk drv #1 - 1011
>80c6	 6d 80                    	         .word    unused
>80c8	 6d 80                    	         .word    unused
>80ca	 e5 8f                    	         .word    chgutl
>80cc	 80 90                    	         .word    fstload

;******  Return to file "serlib.asm"

						.include "notes.asm"

;******  Processing file "notes.asm"


;******  Return to file "serlib.asm"

						.include "sieee1.asm"

;******  Processing file "sieee1.asm"


.80ce	 78		sei		jatnsrv sei
.80cf	 a9 00		lda #$00		lda  #0
.80d1	 85 7c		sta $7c			sta  atnpnd
.80d3	 85 79		sta $79			sta  lsnact
.80d5	 85 7a		sta $7a			sta  tlkact
.80d7	 a2 45		ldx #$45		ldx  #topwrt    ; reset stack
.80d9	 9a		txs			txs
.80da	 20 b2 81	jsr $81b2		jsr  spinp      ; serial input
.80dd	 a9 80		lda #$80		lda  #$80       ; set atn mode flag for acpt routine
.80df	 85 f8		sta $f8			sta  eoiflg     ; reset eoi flag to non-eoi state
.80e1	 85 7d		sta $7d			sta  atnact
.80e3	 20 b7 e9	jsr $e9b7		jsr  clkhi
.80e6	 20 a5 e9	jsr $e9a5		jsr  datlow     ; set data line low as response
.80e9	 ad 00 18	lda $1800		lda  pb         ; set atn ack to release data line
.80ec	 09 10		ora #$10		ora  #atna
.80ee	 8d 00 18	sta $1800		sta  pb
.80f1	 ad 00 18	lda $1800	-       lda  pb         ; test atn still here
.80f4	 10 64		bpl $815a		bpl  a2         ; gone !
.80f6	 29 04		and #$04		and  #clkin     ; clock still low
.80f8	 d0 f7		bne $80f1		bne  -
.80fa	 20 ca 82	jsr $82ca	a3      jsr  jacptr     ; get a command byte
.80fd	 c9 3f		cmp #$3f		cmp  #unlsn
.80ff	 d0 0c		bne $810d		bne  a4
.8101	 a5 37		lda $37			lda  fastsr     ; clr fast host flag & listen flag
.8103	 29 bf		and #$bf		and  #all-bit6
.8105	 85 37		sta $37			sta  fastsr
.8107	 a9 00		lda #$00		lda  #0
.8109	 85 79		sta $79			sta  lsnact
.810b	 f0 0e		beq $811b		beq  a6         ; bra
.810d	 c9 5f		cmp #$5f	a4      cmp  #untlk
.810f	 d0 0d		bne $811e		bne  a5
.8111	 a5 37		lda $37			lda  fastsr     ; clr fast host flag & talk flag
.8113	 29 bf		and #$bf		and  #all-bit6
.8115	 85 37		sta $37			sta  fastsr
.8117	 a9 00		lda #$00		lda  #0
.8119	 85 7a		sta $7a			sta  tlkact
.811b	 4c 92 81	jmp $8192	a6      jmp  a9         ; jmp
.811e	 c5 78		cmp $78		a5      cmp  tlkadr     ; our talk address?
.8120	 d0 0a		bne $812c		bne  a7         ; nope
.8122	 a9 01		lda #$01		lda  #1
.8124	 85 7a		sta $7a			sta  tlkact     ; set talk flag
.8126	 a9 00		lda #$00		lda  #0
.8128	 85 79		sta $79			sta  lsnact     ; clear listen flag
.812a	 f0 29		beq $8155		beq  a8         ; bra
.812c	 c5 77		cmp $77		a7      cmp  lsnadr     ; our listen address?
.812e	 d0 0a		bne $813a		bne  a10        ; nope
.8130	 a9 01		lda #$01		lda  #1
.8132	 85 79		sta $79			sta  lsnact     ; set listen flag
.8134	 a9 00		lda #$00		lda  #0
.8136	 85 7a		sta $7a			sta  tlkact     ; clear talk flag
.8138	 f0 1b		beq $8155		beq  a8         ; bra
.813a	 aa		tax		a10     tax             ; test if sa
.813b	 29 60		and #$60		and  #$60
.813d	 c9 60		cmp #$60		cmp  #$60       ; sa = $60 + n
.813f	 d0 4c		bne $818d		bne  a11        ; did not get a valid command
.8141	 8a		txa			txa             ; a sa for me
.8142	 85 84		sta $84			sta  orgsa
.8144	 29 0f		and #$0f		and  #$0f       ; strip junk
.8146	 85 83		sta $83			sta  sa
.8148	 a5 84		lda $84			lda  orgsa      ; test if close
.814a	 29 f0		and #$f0		and  #$f0
.814c	 c9 e0		cmp #$e0		cmp  #$e0
.814e	 d0 42		bne $8192		bne  a9         ; no
.8150	 58		cli			cli
.8151	 20 c0 da	jsr $dac0		jsr  close      ; close the file
.8154	 78		sei			sei
.8155	 2c 00 18	bit $1800	a8      bit  pb         ; test atn still here
.8158	 30 a0		bmi $80fa		bmi  a3
.815a	 a9 00		lda #$00	a2      lda  #0
.815c	 85 7d		sta $7d			sta  atnact     ; clear atn mode
.815e	 ad 00 18	lda $1800		lda  pb         ; atn gone, release atn ack
.8161	 29 ef		and #$ef		and  #all-atna
.8163	 8d 00 18	sta $1800		sta  pb
.8166	 a5 79		lda $79			lda  lsnact     ; listen ?
.8168	 f0 0d		beq $8177		beq  a12
.816a	 24 37		bit $37			bit  fastsr     ; fast ?
.816c	 50 03		bvc $8171		bvc  a14
.816e	 20 99 81	jsr $8199		jsr  drq        ; device request fast
.8171	 20 42 83	jsr $8342	a14     jsr  jlisten
.8174	 4c 6b 83	jmp $836b		jmp  xidle
.8177	 a5 7a		lda $7a		a12     lda  tlkact     ; talk?
.8179	 f0 0f		beq $818a		beq  a13
.817b	 20 9c e9	jsr $e99c		jsr  dathi      ; release data line
.817e	 20 ae e9	jsr $e9ae		jsr  clklo
.8181	 20 83 a4	jsr $a483		jsr  jslowd     ; slow down for plus4 series
.8184	 20 ea 81	jsr $81ea		jsr  jtalk
.8187	 20 83 a4	jsr $a483		jsr  jslowd     ; slow down for plus4 series
.818a	 4c 66 83	jmp $8366	a13     jmp  jilerr     ; release all lines and go to idle
.818d					a11
.818d	 a9 10		lda #$10		lda  #atna
.818f	 8d 00 18	sta $1800		sta  pb         ; kill all
.8192	 2c 00 18	bit $1800	a9      bit  pb
.8195	 10 c3		bpl $815a		bpl  a2         ; exit out same way after atn done
.8197	 30 f9		bmi $8192		bmi  a9         ; bra
.8199	 20 59 ea	jsr $ea59	drq     jsr  tstatn     ; does the host want us ?
.819c	 20 c0 e9	jsr $e9c0		jsr  debnc
.819f	 29 04		and #$04		and  #clkin
.81a1	 d0 f6		bne $8199		bne  drq        ; wait for clk hi
.81a3	 20 ce 81	jsr $81ce		jsr  spout      ; output
.81a6	 a9 00		lda #$00		lda  #0
.81a8	 8d 0c 40	sta $400c		sta  sdr        ; send zero
.81ab	 a9 08		lda #$08	fs_wait lda  #8
.81ad	 2c 0d 40	bit $400d	-       bit  icr        ; wait for byte to shift out
.81b0	 f0 fb		beq $81ad		beq  -
.81b2	 08		php		spinp   php             ; save uP status
.81b3	 78		sei			sei
.81b4	 ad 0e 40	lda $400e		lda  cra        ; turn 8520 in
.81b7	 29 bf		and #$bf		and  #%10111111 ; serial port input
.81b9	 8d 0e 40	sta $400e		sta  cra
.81bc	 ad 0f 18	lda $180f		lda  pota1       ; turn drvr in
.81bf	 29 fd		and #$fd		and  #all-2      ;**TODO**
.81c1	 8d 0f 18	sta $180f		sta  pota1
.81c4	 a9 88		lda #$88		lda  #$88 ;**TODO**
.81c6	 8d 0d 40	sta $400d		sta  icr
.81c9	 2c 0d 40	bit $400d		bit  icr
.81cc	 28		plp			plp
.81cd	 60		rts			rts
.81ce	 08		php		spout   php             ; save uP status
.81cf	 78		sei			sei
.81d0	 ad 0f 18	lda $180f		lda  pota1
.81d3	 09 02		ora #$02		ora  #fsdir
.81d5	 8d 0f 18	sta $180f		sta  pota1      ; turn drvr out
.81d8	 ad 0e 40	lda $400e		lda  cra        ; turn 6526 out
.81db	 09 40		ora #$40		ora  #%01000000
.81dd	 8d 0e 40	sta $400e		sta  cra
.81e0	 a9 08		lda #$08		lda  #8 ;**TODO**
.81e2	 8d 0d 40	sta $400d		sta  icr
.81e5	 2c 0d 40	bit $400d		bit  icr
.81e8	 28		plp			plp
.81e9	 60		rts			rts
.81ea					jtalk
.81ea	 78		sei			sei             ; find if open channel
.81eb	 20 eb d0	jsr $d0eb		jsr  fndrch
.81ee	 b0 06		bcs $81f6		bcs  m1         ; no one home
.81f0	 a6 82		ldx $82		m2      ldx  lindx
.81f2	 b5 f2		lda $f2,x		lda  chnrdy,x
.81f4	 30 01		bmi $81f7		bmi  m3
.81f6	 60		rts		m1      rts
.81f7	 20 59 ea	jsr $ea59	m3      jsr  tstatn     ; test for atn
.81fa	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.81fd	 29 01		and #$01		and  #datin
.81ff	 08		php			php
.8200	 20 b7 e9	jsr $e9b7		jsr  clkhi      ; set clk hi
.8203	 28		plp			plp             ; see if verify error...
.8204	 f0 12		beq $8218		beq  m4         ; br,  yes...data line hi, eoi !!!!
.8206	 20 59 ea	jsr $ea59	-       jsr  tstatn     ; test for atn
.8209	 20 c0 e9	jsr $e9c0		jsr  debnc
.820c	 29 01		and #$01		and  #datin
.820e	 d0 f6		bne $8206		bne  -          ; wait for data high
.8210	 a6 82		ldx $82			ldx  lindx      ; prepare to send eoi if needed
.8212	 b5 f2		lda $f2,x		lda  chnrdy,x
.8214	 29 08		and #$08		and  #eoi
.8216	 d0 14		bne $822c		bne  m7         ; no eoi
.8218	 20 59 ea	jsr $ea59	m4      jsr  tstatn     ; test for atn
.821b	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.821e	 29 01		and #$01		and  #datin     ; test if data line is low
.8220	 d0 f6		bne $8218		bne  m4         ; yes, wait till hi
.8222	 20 59 ea	jsr $ea59	-       jsr  tstatn     ; test for atn
.8225	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.8228	 29 01		and #$01		and  #datin
.822a	 f0 f6		beq $8222		beq  -
.822c	 20 ae e9	jsr $e9ae	m7      jsr  clklo      ; set clock low
.822f	 20 59 ea	jsr $ea59		jsr  tstatn     ; chk atn line
.8232	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.8235	 29 01		and #$01		and  #datin
.8237	 d0 f3		bne $822c		bne  m7
.8239	 24 37		bit $37			bit  fastsr     ; fast or slow ?
.823b	 50 39		bvc $8276		bvc  m10
.823d	 ad 0f 18	lda $180f		lda  pota1      ; fast serial output
.8240	 09 02		ora #$02		ora  #fsdir
.8242	 8d 0f 18	sta $180f		sta  pota1      ; turn drvr out
.8245	 ad 0e 40	lda $400e		lda  cra        ; turn 6526 out
.8248	 09 40		ora #$40		ora  #%01000000
.824a	 8d 0e 40	sta $400e		sta  cra
.824d	 2c 0d 40	bit $400d		bit  icr
.8250	 a6 82		ldx $82			ldx  lindx
.8252	 bd 3e 02	lda $023e,x		lda  chndat,x   ; get data
.8255	 8d 0c 40	sta $400c		sta  sdr        ; send it
.8258	 ad 0d 40	lda $400d	-       lda  icr        ; wait for byte ready
.825b	 29 08		and #$08		and  #8
.825d	 f0 f9		beq $8258		beq  -
.825f	 ad 0e 40	lda $400e		lda  cra
.8262	 29 bf		and #$bf		and  #%10111111 ; release the data bus
.8264	 8d 0e 40	sta $400e		sta  cra        ; must go input
.8267	 ad 0f 18	lda $180f		lda  pota1
.826a	 29 fd		and #$fd		and  #all-fsdir ; turn drvr in
.826c	 8d 0f 18	sta $180f		sta  pota1
.826f	 a9 88		lda #$88		lda  #$88
.8271	 8d 0d 40	sta $400d		sta  icr
.8274	 d0 3c		bne $82b2		bne  m9         ; wait for data accepted
.8276					m10
.8276	 a9 08		lda #$08		lda  #8         ; set up bit counter
.8278	 85 98		sta $98			sta  cont
.827a					m11
.827a	 20 c0 e9	jsr $e9c0		jsr  debnc      ; let port settle
.827d	 29 01		and #$01		and  #datin     ; test that data line is now high before we send
.827f	 d0 43		bne $82c4		bne  m16
.8281	 a6 82		ldx $82		m12     ldx  lindx      ; get byte to send
.8283	 bd 3e 02	lda $023e,x		lda  chndat,x
.8286	 6a		ror a			ror  a
.8287	 9d 3e 02	sta $023e,x		sta  chndat,x
.828a	 b0 05		bcs $8291		bcs  m13        ; send a 1
.828c	 20 a5 e9	jsr $e9a5		jsr  datlow     ; send a 0
.828f	 d0 03		bne $8294		bne  m14        ; and clock it
.8291	 20 9c e9	jsr $e99c	m13     jsr  dathi
.8294	 20 7e a4	jsr $a47e	m14     jsr  jslower    ; wait a bit for t-s ( 2 mhz )
.8297	 a5 23		lda $23			lda  slflag     ; slow down?
.8299	 d0 03		bne $829e		bne  m17
.829b	 20 83 a4	jsr $a483		jsr  jslowd     ; delay 40 us ( host dma )
.829e	 20 b7 e9	jsr $e9b7	m17     jsr  clkhi      ; rising edge clock
.82a1	 20 7e a4	jsr $a47e		jsr  jslower    ; increase t-v ( 2 mhz )
.82a4	 a5 23		lda $23			lda  slflag     ; slow down?
.82a6	 d0 03		bne $82ab		bne  m15
.82a8	 20 83 a4	jsr $a483		jsr  jslowd     ; delay 40 us ( host dma )
.82ab	 20 fb fe	jsr $fefb	m15     jsr  patch4     ; pull clock low and ...
.82ae	 c6 98		dec $98			dec  cont       ; more bits?
.82b0	 d0 c8		bne $827a		bne  m11        ; yes
.82b2	 20 59 ea	jsr $ea59	m9      jsr  tstatn     ; test for atn
.82b5	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.82b8	 29 01		and #$01		and  #datin
.82ba	 f0 f6		beq $82b2		beq  m9         ; wait for data low
.82bc	 58		cli			cli             ; let the controller run
.82bd	 20 aa d3	jsr $d3aa		jsr  get        ; get the next byte
.82c0	 78		sei			sei             ; sorry sync protocol
.82c1	 4c f0 81	jmp $81f0		jmp  m2         ; keep on talkin
.82c4	 4c 62 83	jmp $8362	m16     jmp  frmerr
.82c7					jacptr2
.82c7	 2c 0d 40	bit $400d		bit  icr        ; clear pending
.82ca					jacptr
.82ca	 a9 08		lda #$08		lda  #8         ; set byte bit count
.82cc	 85 98		sta $98			sta  cont
.82ce	 20 59 ea	jsr $ea59	-       jsr  tstatn
.82d1	 20 c0 e9	jsr $e9c0		jsr  debnc
.82d4	 29 04		and #$04		and  #clkin
.82d6	 d0 f6		bne $82ce		bne  -
.82d8	 20 9c e9	jsr $e99c		jsr  dathi      ; make data line hi
.82db	 a9 01		lda #$01		lda  #datin
.82dd	 2c 00 18	bit $1800	-       bit  pb         ; wait for data high
.82e0	 d0 fb		bne $82dd		bne  -
.82e2	 20 76 aa	jsr $aa76		jsr  ptch59
.82e5	 20 59 ea	jsr $ea59	m3	jsr  tstatn
.82e8	 ad 0d 18	lda $180d		lda  ifr1
.82eb	 29 40		and #$40		and  #$40
.82ed	 d0 09		bne $82f8		bne  m4
.82ef	 20 c0 e9	jsr $e9c0		jsr  debnc      ; test clock low
.82f2	 29 04		and #$04		and  #clkin
.82f4	 f0 ef		beq $82e5		beq  m3         ; no
.82f6	 d0 19		bne $8311		bne  m5         ; yes
.82f8	 20 a5 e9	jsr $e9a5	m4      jsr  datlow     ; set data line low as response
.82fb	 a2 18		ldx #$18		ldx  #24        ; delay for talker turnaround
.82fd	 ca		dex		-       dex
.82fe	 d0 fd		bne $82fd		bne  -
.8300	 20 9c e9	jsr $e99c		jsr  dathi      ; set data line hi
.8303	 20 59 ea	jsr $ea59	-       jsr  tstatn
.8306	 20 c0 e9	jsr $e9c0		jsr  debnc      ; wait for low clock
.8309	 29 04		and #$04		and  #clkin
.830b	 f0 f6		beq $8303		beq  -
.830d	 a9 00		lda #$00		lda  #0         ; set eoi received
.830f	 85 f8		sta $f8			sta  eoiflg
.8311	 ad 00 18	lda $1800	m5      lda  pb         ; wait for clock high
.8314	 49 01		eor #$01		eor  #01        ; complement datain
.8316	 aa		tax			tax             ; save .a
.8317	 ad 0d 40	lda $400d		lda  icr
.831a	 29 08		and #$08		and  #8         ; fast byte ?
.831c	 f0 08		beq $8326		beq  m11
.831e	 ad 0c 40	lda $400c		lda  sdr        ; get data
.8321	 85 85		sta $85			sta  data       ; keep
.8323	 4c 3c 83	jmp $833c		jmp  m10        ; finish up
.8326	 8a		txa		m11     txa             ; restore .a
.8327	 4a		lsr a			lsr  a          ; shift into carry
.8328	 29 02		and #$02		and  #$02       ; clkin/2
.832a	 d0 e5		bne $8311		bne  m5
.832c	 66 85		ror $85			ror  data
.832e	 20 59 ea	jsr $ea59	-       jsr  tstatn
.8331	 20 c0 e9	jsr $e9c0		jsr  debnc
.8334	 29 04		and #$04		and  #clkin     ; wait for clock low
.8336	 f0 f6		beq $832e		beq  -
.8338	 c6 98		dec $98			dec  cont       ; more to do?
.833a	 d0 d5		bne $8311		bne  m5
.833c	 20 a5 e9	jsr $e9a5	m10     jsr  datlow     ; set data line low
.833f	 a5 85		lda $85			lda  data
.8341	 60		rts			rts
.8342					jlisten
.8342	 78		sei			sei
.8343	 20 07 d1	jsr $d107		jsr  fndwch     ; test if active write channel
.8346	 b0 05		bcs $834d		bcs  m1
.8348	 b5 f2		lda $f2,x		lda  chnrdy,x
.834a	 6a		ror a			ror  a
.834b	 b0 0b		bcs $8358		bcs  m2
.834d	 a5 84		lda $84		m1      lda  orgsa      ; test if open
.834f	 29 f0		and #$f0		and  #$f0
.8351	 c9 f0		cmp #$f0		cmp  #$f0
.8353	 f0 03		beq $8358		beq  m2         ; its an open
.8355	 4c 66 83	jmp $8366		jmp  jilerr     ; not active channel
.8358	 20 c7 82	jsr $82c7	m2      jsr  jacptr2    ; get a byte
.835b	 58		cli			cli
.835c	 20 b7 cf	jsr $cfb7		jsr  put        ; put(data,eoiflg,sa)
.835f	 4c 42 83	jmp $8342		jmp  jlisten    ; and keep on listen
.8362	 a9 00		lda #$00	frmerr  lda #0
.8364	 85 37		sta $37			sta  fastsr
.8366	 a9 00		lda #$00	jilerr  lda  #0
.8368	 8d 00 18	sta $1800		sta  pb         ; in atnmod, release all bus lines
.836b	 20 b2 81	jsr $81b2	xidle   jsr  spinp
.836e	 4c e7 eb	jmp $ebe7		jmp  idle      ; go idle it

;******  Return to file "serlib.asm"

						.include "fastutl.asm"

;******  Processing file "fastutl.asm"

.8371	 8d 4d 02	sta $024d	fstrd   sta  cmd	; save command for dos
.8374	 85 5f		sta $5f			sta  ctl_cmd	; save command for stbctt
.8376	 ad 0d 18	lda $180d	        lda  ifr1	; disk change
.8379	 4a		lsr a		        lsr  a
.837a	 90 18		bcc $8394		bcc  frd_00	; br, ok
.837c	 a2 0b		ldx #$0b		ldx  #%00001011 ; no channel

>837e	 2c                       		.byte skip2

.837f	 a2 4f		ldx #$4f	ndkrd	ldx  #%01001111 ; no drive
.8381	 20 e9 85	jsr $85e9	fail	jsr  upinst     ; update dkmode
.8384	 20 81 85	jsr $8581	finbad	jsr  statqy	; wait for state handshake
.8387	 e0 02		cpx #$02	final	cpx  #2
.8389	 b0 01		bcs $838c		bcs  exbad
.838b	 60		rts			rts
.838c	 8a		txa		exbad   txa             ; retrieve status
.838d	 29 0f		and #$0f		and  #15	; bits 0-3 only
.838f	 a2 00		ldx #$00		ldx  #0         ; jobnum
.8391	 4c 0a e6	jmp $e60a	        jmp  error      ; controller error entry
.8394	 20 ce 81	jsr $81ce	frd_00	jsr  spout
.8397	 24 5e		bit $5e			bit  dkmode     ; gcr or mfm ?
.8399	 10 05		bpl $83a0	        bpl  rdgcr
.839b	 a9 09		lda #$09		lda  #9         ; read cmd
.839d	 4c e6 86	jmp $86e6	        jmp prcmd
.83a0	 20 3d c6	jsr $c63d	rdgcr	jsr  autoi      ; check for auto init
.83a3	 58		cli		frd_01	cli             ; let controller run
.83a4	 a5 3b		lda $3b			lda  switch	; check for B
.83a6	 29 20		and #$20		and  #%00100000
.83a8	 d0 26		bne $83d0		bne  bfonly
.83aa	 ad 03 02	lda $0203	        lda  cmdbuf+3   ; get track
.83ad	 85 06		sta $06		        sta  hdrs
.83af	 ad 04 02	lda $0204	        lda  cmdbuf+4   ; get sector
.83b2	 85 07		sta $07		        sta  hdrs+1
.83b4	 a2 00		ldx #$00	        ldx  #0         ; job #0
.83b6	 a5 5f		lda $5f		        lda  ctl_cmd    ; read ($80) or fread ($88)
.83b8	 95 00		sta $00,x	        sta  jobs,x
.83ba	 20 5e 86	jsr $865e		jsr  stbctt     ; hit controller hard
.83bd	 78		sei		        sei      	; disable irqs
.83be	 20 e9 85	jsr $85e9		jsr  upinst	; update controller status
.83c1	 24 3b		bit $3b			bit  switch	; check E
.83c3	 70 04		bvs $83c9		bvs  igerr
.83c5	 e0 02		cpx #$02	        cpx  #2         ; error
.83c7	 b0 b8		bcs $8381	        bcs  fail
.83c9	 20 f9 85	jsr $85f9	igerr   jsr  hskrd      ; handshake on state of clkin
.83cc	 a5 3b		lda $3b			lda  switch	; check B
.83ce	 30 0d		bmi $83dd		bmi  notran
.83d0	 a0 00		ldy #$00	bfonly  ldy  #0         ; even page
.83d2	 b9 00 03	lda $0300,y	frd_02	lda  $0300,y    ; get data
.83d5	 85 46		sta $46		        sta  ctl_dat    ; setup data
.83d7	 20 f9 85	jsr $85f9	        jsr  hskrd      ; handshake on state
.83da	 c8		iny		        iny
.83db	 d0 f5		bne $83d2	        bne  frd_02
.83dd	 ce 05 02	dec $0205	notran	dec  cmdbuf+5   ; any more sectors ?
.83e0	 f0 06		beq $83e8	        beq  exrd
.83e2	 20 1e 86	jsr $861e	        jsr  sektr      ; next sector
.83e5	 4c a3 83	jmp $83a3	        jmp  frd_01	; more to do
.83e8	 58		cli		exrd    cli
.83e9	 4c af 85	jmp $85af	        jmp  chksee     ; next track ?
.83ec					fstwrt
.83ec	 8d 4d 02	sta $024d		sta  cmd        ; save command for dos
.83ef	 ad 0d 18	lda $180d	        lda  ifr1	; disk change
.83f2	 4a		lsr a		        lsr  a
.83f3	 90 0d		bcc $8402		bcc  fwrt_0	; br, ok
.83f5	 a2 0b		ldx #$0b		ldx  #%00001011	; no channel

>83f7	 2c                       		.byte  skip2

.83f8	 a2 4f		ldx #$4f	ndkwrt	ldx  #%01001111	; no drv 1
.83fa	 86 46		stx $46			stx  ctl_dat	; save status
.83fc	 a5 3b		lda $3b			lda  switch	; set internal switch
.83fe	 09 08		ora #$08	        ora  #%00001000
.8400	 85 3b		sta $3b			sta  switch
.8402	 24 5e		bit $5e		fwrt_0  bit  dkmode     ; gcr or mfm ?
.8404	 10 05		bpl $840b	        bpl  wrtgcr
.8406	 a9 0a		lda #$0a		lda  #10
.8408	 4c e6 86	jmp $86e6		jmp  prcmd
.840b	 20 3d c6	jsr $c63d	wrtgcr	jsr  autoi      ; chk for autoi
.840e	 a5 3b		lda $3b			lda  switch	; transmision required
.8410	 30 29		bmi $843b		bmi  notrx
.8412	 78		sei		fwrt_1	sei             ; no irqs
.8413	 a0 00		ldy #$00		ldy  #0         ; even page
.8415	 ad 00 18	lda $1800	fwrt_2  lda  pb		; debounce
.8418	 49 08		eor #$08	        eor  #clkout    ; toggle state of clock
.841a	 2c 0d 40	bit $400d		bit  icr	; clear pending
.841d	 8d 00 18	sta $1800	        sta  pb
.8420	 ad 00 18	lda $1800	fwrt_4	lda  pb
.8423	 10 03		bpl $8428	        bpl  fwrt_3	; br, attn not low
.8425	 20 59 ea	jsr $ea59		jsr  tstatn     ; chk for atn
.8428	 ad 0d 40	lda $400d	fwrt_3  lda  icr	; wait for byte
.842b	 29 08		and #$08	        and  #8
.842d	 f0 f1		beq $8420	        beq  fwrt_4	; chk for attn low only
.842f	 ad 0c 40	lda $400c	        lda  sdr	; get data
.8432	 99 00 03	sta $0300,y	        sta  $0300,y    ; put away data
.8435	 c8		iny		        iny
.8436	 d0 dd		bne $8415	        bne  fwrt_2	; more ?
.8438	 20 b7 e9	jsr $e9b7		jsr  clkhi	; release clock
.843b	 58		cli		notrx   cli             ; let controller run
.843c	 a5 3b		lda $3b			lda  switch	; check for buffer transfer only
.843e	 29 20		and #$20		and  #%00100000
.8440	 d0 37		bne $8479		bne  nowrt
.8442	 a5 3b		lda $3b			lda  switch	; check internal
.8444	 29 08		and #$08		and  #%00001000
.8446	 f0 05		beq $844d		beq  notrx0	; br, ok...
.8448	 a6 46		ldx $46			ldx  ctl_dat	; get error
.844a	 4c 81 83	jmp $8381		jmp  fail	; abort
.844d	 ad 03 02	lda $0203	notrx0  lda  cmdbuf+3   ; get track
.8450	 85 06		sta $06		        sta  hdrs
.8452	 ad 04 02	lda $0204	        lda  cmdbuf+4   ; get sector
.8455	 85 07		sta $07		        sta  hdrs+1
.8457	 a2 00		ldx #$00		ldx  #0         ; job #0
.8459	 a9 90		lda #$90		lda  #write	; get write job
.845b	 95 00		sta $00,x	        sta  jobs,x
.845d	 20 5e 86	jsr $865e	        jsr  stbctt     ; wack controller in the head
.8460	 78		sei		        sei             ; no irqs ok !
.8461	 20 ce 81	jsr $81ce	        jsr  spout      ; go output
.8464	 20 e9 85	jsr $85e9		jsr  upinst	; update status
.8467	 20 f9 85	jsr $85f9	        jsr  hskrd	; send it
.846a	 20 a0 86	jsr $86a0		jsr  burst	; wait for reverse
.846d	 20 b2 81	jsr $81b2		jsr  spinp
.8470	 58		cli		        cli             ; irqs ok now
.8471	 24 3b		bit $3b			bit  switch	; check error abort switch
.8473	 70 04		bvs $8479		bvs  nowrt
.8475	 e0 02		cpx #$02	        cpx  #2         ; error on job ?
.8477	 b0 0b		bcs $8484	        bcs  fwrt_5	; abort ?
.8479	 ce 05 02	dec $0205	nowrt   dec  cmdbuf+5   ; more sectors ?
.847c	 f0 09		beq $8487	        beq  fwrt_6
.847e	 20 1e 86	jsr $861e	        jsr  sektr      ; increment sector
.8481	 4c 12 84	jmp $8412	        jmp  fwrt_1
.8484	 4c 8c 83	jmp $838c	fwrt_5	jmp  exbad
.8487	 58		cli		fwrt_6  cli		; done
.8488	 4c af 85	jmp $85af		jmp  chksee	; next track ?
.848b					fstsek
.848b	 ad 02 02	lda $0202		lda  cmdbuf+2	; check drive number
.848e	 29 01		and #$01		and  #1
.8490	 d0 20		bne $84b2	        bne  m3		; drive 1 - error
.8492	 a9 01		lda #$01		lda  #1
.8494	 8d 0d 18	sta $180d		sta  ifr1	; new disk
.8497	 a9 05		lda #$05		lda  #5		; read address cmd
.8499	 20 e6 86	jsr $86e6		jsr  prcmd	; give it to controller
.849c	 ae b0 01	ldx $01b0		ldx  mfmcmd	; get status
.849f	 e0 02		cpx #$02		cpx  #2		; ok ?
.84a1	 90 11		bcc $84b4		bcc  m2
.84a3	 a2 00		ldx #$00		ldx  #0
.84a5	 86 5e		stx $5e			stx  dkmode 	; force gcr,drv0,ok
.84a7	 a9 b0		lda #$b0		lda  #seek	; seek
.84a9	 20 75 c0	jsr $c075		jsr  ptch0c	; *** rom ds 12/08/86 ***, set track
.84ac	 95 00		sta $00,x		sta  jobs,x	; give job to controller
.84ae	 20 5e 86	jsr $865e		jsr  stbctt	; bang the controller

>84b1	 2c                       		.byte  skip2	; return status

.84b2	 a2 4f		ldx #$4f	m3	ldx  #%01001111 ; no drv 1
.84b4	 4c 81 83	jmp $8381	m2	jmp  fail	; update status
.84b7					fstfmt
.84b7	 ad 02 02	lda $0202		lda  cmdbuf+2   ; check drive number
.84ba	 29 01		and #$01		and  #1
.84bc	 d0 2b		bne $84e9		bne  m1
.84be	 ad 03 02	lda $0203		lda  cmdbuf+3	; format gcr or mfm ?
.84c1	 10 05		bpl $84c8		bpl  m2
.84c3	 a9 08		lda #$08		lda  #8		; format disk in mfm
.84c5	 4c e6 86	jmp $86e6		jmp  prcmd
.84c8	 a9 00		lda #$00	m2	lda  #0
.84ca	 85 5e		sta $5e			sta  dkmode     ; force GCR,DRV0
.84cc	 85 ff		sta $ff			sta  nodrv	; drive ok
.84ce	 ad 04 02	lda $0204		lda  cmdbuf+4
.84d1	 85 12		sta $12			sta  dskid	; low id
.84d3	 ad 05 02	lda $0205		lda  cmdbuf+5
.84d6	 85 13		sta $13			sta  dskid+1	; high id
.84d8	 20 07 d3	jsr $d307		jsr  clrchn	; close all channels
.84db	 a9 01		lda #$01		lda  #1
.84dd	 85 80		sta $80			sta  track	; track one
.84df	 a9 ff		lda #$ff		lda  #$ff
.84e1	 8d 98 02	sta $0298		sta  jobrtn	; set error recovery
.84e4	 20 4d aa	jsr $aa4d		jsr  ptch55	; *** rom ds 06/18/85 ***, format
.84e7	 aa		tax			tax		; save error

>84e8	 2c                       		.byte skip2

.84e9	 a2 4f		ldx #$4f	m1	ldx  #%01001111
.84eb	 20 e9 85	jsr $85e9		jsr  upinst	; update status
.84ee	 4c 87 83	jmp $8387		jmp  final	; finish up ...
.84f1	 78		sei		cpmint  sei
.84f2	 24 3b		bit $3b			bit  switch	; read ?
.84f4	 10 0a		bpl $8500		bpl  +		; br, write
.84f6	 20 ce 81	jsr $81ce		jsr  spout  	; serial port output
.84f9	 a5 3c		lda $3c			lda  cpmit	; get current interleave
.84fb	 85 46		sta $46			sta  ctl_dat	; send it
.84fd	 4c f9 85	jmp $85f9		jmp  hskrd
.8500	 ae 74 02	ldx $0274	+	ldx  cmdsiz
.8503	 e0 04		cpx #$04	        cpx  #4
.8505	 b0 0a		bcs $8511	        bcs  +
.8507	 a2 0e		ldx #$0e		ldx  #%00001110 ; syntax
.8509	 20 e9 85	jsr $85e9		jsr  upinst	; update dkmode
.850c	 a9 31		lda #$31	        lda  #badcmd
.850e	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.8511	 ad 03 02	lda $0203	+	lda  cmdbuf+3
.8514	 85 3c		sta $3c			sta  cpmit      ; save
.8516	 60		rts			rts
.8517					querdk
.8517	 20 8b 84	jsr $848b		jsr  fstsek	; check disk format
.851a	 24 5e		bit $5e			bit  dkmode	; mfm or gcr ?
.851c	 10 48		bpl $8566		bpl  m2
.851e	 a9 0d		lda #$0d		lda  #13
.8520	 20 e6 86	jsr $86e6		jsr  prcmd	; generate sector table
.8523	 ae b0 01	ldx $01b0		ldx  mfmcmd	; status ok ?
.8526	 e0 02		cpx #$02		cpx  #2
.8528	 b0 08		bcs $8532		bcs  +
.852a	 20 61 89	jsr $8961		jsr  maxmin	; determine low/high sector
.852d	 20 86 89	jsr $8986		jsr  fn_int	; determine interleave
.8530	 8a		txa			txa		; hard interleave
.8531	 48		pha			pha		; save it
.8532	 78		sei		+	sei		; no irq's
.8533	 20 ce 81	jsr $81ce		jsr  spout	; serial port output
.8536	 a5 5e		lda $5e			lda  dkmode	; get status and send it
.8538	 85 46		sta $46			sta  ctl_dat
.853a	 20 f9 85	jsr $85f9		jsr  hskrd	; transmit status
.853d	 ae b0 01	ldx $01b0		ldx  mfmcmd	; was status ok ?
.8540	 e0 02		cpx #$02		cpx  #2
.8542	 b0 23		bcs $8567		bcs  m3
.8544	 a5 97		lda $97			lda  cpmsek	; get number of sectors
.8546	 85 46		sta $46			sta  ctl_dat
.8548	 20 f9 85	jsr $85f9		jsr  hskrd	; send it
.854b	 a5 67		lda $67			lda  cmd_trk	; get logical track number
.854d	 85 46		sta $46			sta  ctl_dat
.854f	 20 f9 85	jsr $85f9		jsr  hskrd	; send track
.8552	 a5 60		lda $60			lda  minsek
.8554	 85 46		sta $46			sta  ctl_dat	; send min.
.8556	 20 f9 85	jsr $85f9		jsr  hskrd	; wait for handshake
.8559	 a5 61		lda $61			lda  maxsek	; send max.
.855b	 85 46		sta $46			sta  ctl_dat
.855d	 20 f9 85	jsr $85f9		jsr  hskrd	; wait for handshake
.8560	 68		pla			pla		; get interleave
.8561	 85 46		sta $46			sta  ctl_dat	; send interleave
.8563	 4c c5 aa	jmp $aac5		jmp  ptch63	; *** rom ds 01/23/86 ***, add sector table
.8566	 60		rts		m2	rts
.8567	 68		pla		m3	pla		; restore stack
.8568	 4c 8c 83	jmp $838c		jmp  exbad
.856b	 24 3b		bit $3b		inqst   bit  switch	; read/write op ?
.856d	 10 27		bpl $8596		bpl  wrstat
.856f	 24 3b		bit $3b			bit  switch	; wp latch ?
.8571	 50 0e		bvc $8581		bvc  statqy
.8573	 ad 0d 18	lda $180d		lda  ifr1
.8576	 4a		lsr a			lsr  a
.8577	 90 08		bcc $8581		bcc  statqy	; ok, give old status
.8579	 a5 5e		lda $5e			lda  dkmode
.857b	 29 f0		and #$f0		and  #$f0	; clr old
.857d	 09 0b		ora #$0b		ora  #$0b	; disk change
.857f	 85 5e		sta $5e			sta  dkmode	; updated status
.8581	 78		sei		statqy  sei 		; disable irqs
.8582	 20 ce 81	jsr $81ce		jsr  spout      ; serial port out
.8585	 a5 5e		lda $5e			lda  dkmode 	; get status
.8587	 85 46		sta $46			sta  ctl_dat
.8589	 20 f9 85	jsr $85f9		jsr  hskrd	; 6526 will send it
.858c	 a9 00		lda #$00		lda  #0
.858e	 8d 6c 02	sta $026c		sta  erword
.8591	 20 b2 81	jsr $81b2	exchnl  jsr  spinp	; serial port input
.8594	 58		cli		exchn2	cli
.8595	 60		rts			rts
.8596	 ad 03 02	lda $0203	wrstat	lda  cmdbuf+3	; new value
.8599	 85 5e		sta $5e			sta  dkmode
.859b	 24 3b		bit $3b			bit  switch	; wp latch ?
.859d	 50 05		bvc $85a4		bvc  +
.859f	 a9 01		lda #$01		lda  #1
.85a1	 8d 0d 18	sta $180d		sta  ifr1	; new disk
.85a4	 60		rts		+	rts
.85a5	 a2 0e		ldx #$0e	duplc1  ldx  #%00001110
.85a7	 20 e9 85	jsr $85e9		jsr  upinst	; update dkmode
.85aa	 a9 31		lda #$31		lda  #badcmd
.85ac	 4c c8 c1	jmp $c1c8		jmp  cmderr
.85af					chksee
.85af	 ad 74 02	lda $0274		lda  cmdsiz     ; chk for next track
.85b2	 c9 07		cmp #$07	        cmp  #7
.85b4	 90 32		bcc $85e8	        bcc  m3
.85b6	 a5 06		lda $06			lda  hdrs	; where are we ?
.85b8	 a8		tay			tay		; save
.85b9	 e9 01		sbc #$01		sbc  #1		; one less
.85bb	 0a		asl a			asl  a
.85bc	 85 64		sta $64			sta  cur_trk
.85be	 c0 24		cpy #$24		cpy  #36
.85c0	 08		php			php		; save status
.85c1	 ac 06 02	ldy $0206		ldy  cmdbuf+6	; destination
.85c4	 84 22		sty $22		        sty  drvtrk
.85c6	 88		dey			dey
.85c7	 84 67		sty $67			sty  cmd_trk	; initial detent
.85c9	 c0 23		cpy #$23		cpy  #35
.85cb	 6a		ror a			ror  a		; rotate carry into neg
.85cc	 28		plp			plp
.85cd	 29 80		and #$80		and  #$80	; set/clr neg
.85cf	 90 0b		bcc $85dc		bcc  m1		; br, we are on side zero
.85d1	 30 12		bmi $85e5		bmi  m2		; br, we are on side one & want to goto side one
.85d3	 18		clc			clc
.85d4	 a5 67		lda $67			lda  cmd_trk	; setup for pete seke
.85d6	 69 23		adc #$23		adc  #35	; select side
.85d8	 85 67		sta $67			sta  cmd_trk
.85da	 30 09		bmi $85e5		bmi  m2		; bra more or less
.85dc	 10 07		bpl $85e5	m1	bpl  m2		; br, we are on side zero & want to goto side zero
.85de	 38		sec			sec
.85df	 a5 67		lda $67			lda  cmd_trk
.85e1	 e9 23		sbc #$23		sbc  #35	; select side
.85e3	 85 67		sta $67			sta  cmd_trk
.85e5	 4c ba 87	jmp $87ba	m2	jmp  seke	; do it
.85e8	 60		rts		m3	rts
.85e9	 86 46		stx $46		upinst  stx  ctl_dat
.85eb	 a5 5e		lda $5e			lda  dkmode     ; update main status w/ controller status
.85ed	 29 f0		and #$f0	        and  #%11110000 ; clear old controller status
.85ef	 05 46		ora $46		        ora  ctl_dat    ; or in controller status
.85f1	 85 5e		sta $5e		        sta  dkmode     ; updated
.85f3	 85 46		sta $46			sta  ctl_dat
.85f5	 60		rts			rts
.85f6	 20 59 ea	jsr $ea59	hsktst  jsr  tstatn     ; test for atn
.85f9					hskrd
.85f9	 ad 00 18	lda $1800	-	lda  pb		; debounce
.85fc	 cd 00 18	cmp $1800	        cmp  pb
.85ff	 d0 f8		bne $85f9	        bne  -
.8601	 29 ff		and #$ff		and  #$ff	; set/clr neg flag
.8603	 30 f1		bmi $85f6	        bmi  hsktst     ; br, attn low
.8605	 45 37		eor $37		        eor  fastsr     ; wait for state chg
.8607	 29 04		and #$04	        and  #4
.8609	 f0 ee		beq $85f9	        beq  -
.860b	 a5 46		lda $46		hsksnd  lda  ctl_dat    ; retrieve data
.860d	 4c 10 ab	jmp $ab10		jmp  ptch68	; *** rom ds 05/16/86 ***
.8610	 a5 37		lda $37		        lda  fastsr
.8612	 49 04		eor #$04	        eor  #4         ; change state of clk
.8614	 85 37		sta $37		        sta  fastsr
.8616	 a9 08		lda #$08	        lda  #8
.8618	 2c 0d 40	bit $400d	-	bit  icr	; wait transmission time
.861b	 f0 fb		beq $8618	        beq  -
.861d	 60		rts		        rts
.861e	 ad 03 02	lda $0203	sektr   lda  cmdbuf+3   ; get track
.8621	 c9 24		cmp #$24		cmp  #36	; side one ?
.8623	 90 02		bcc $8627		bcc  +
.8625	 e9 23		sbc #$23		sbc  #35	; get offset
.8627	 aa		tax		+	tax
.8628	 bd 2b 94	lda $942b,x		lda  num_sec-1,x
.862b	 aa		tax			tax
.862c	 ca		dex			dex
.862d	 86 46		stx $46		        stx  ctl_dat    ; save
.862f	 18		clc			clc
.8630	 ad 04 02	lda $0204	        lda  cmdbuf+4   ; get sector
.8633	 65 3c		adc $3c		        adc  cpmit      ; add interleave
.8635	 c5 46		cmp $46		        cmp  ctl_dat    ; less than maxsec ?
.8637	 90 0a		bcc $8643	        bcc  gtsec
.8639	 e5 46		sbc $46		        sbc  ctl_dat    ; rap around
.863b	 f0 04		beq $8641	        beq  oksec      ; special case on max
.863d	 38		sec		        sec
.863e	 e9 01		sbc #$01	        sbc  #1         ; less one

>8640	 2c                       		.byte skip2

.8641	 a5 46		lda $46		oksec   lda  ctl_dat
.8643	 8d 04 02	sta $0204	gtsec   sta  cmdbuf+4   ; new sector
.8646	 a9 88		lda #$88	        lda  #fread     ; exread job
.8648	 85 5f		sta $5f		        sta  ctl_cmd
.864a	 60		rts		        rts
.864b	 a6 f9		ldx $f9		stbctr	ldx  jobnum
.864d	 08		php			php
.864e	 58		cli			cli		; let controller run free
.864f	 20 b6 9f	jsr $9fb6		jsr  stbctl     ; strobe controller ( hit him hard )
.8652	 c9 02		cmp #$02	        cmp  #2         ; was there an error ?
.8654	 90 05		bcc $865b	        bcc  +		; br, nope
.8656	 20 83 86	jsr $8683		jsr  stbret	; let DOS retry
.8659	 b5 00		lda $00,x		lda  jobs,x	; get error
.865b	 aa		tax		+	tax     	; return status in .x
.865c	 28		plp			plp		; restore status
.865d	 60		rts			rts
.865e	 a2 00		ldx #$00	stbctt	ldx  #0		; buffer zero
.8660	 08		php			php
.8661	 78		sei			sei		; no irq's during i/o access
.8662	 ad 00 1c	lda $1c00		lda  ledprt
.8665	 09 08		ora #$08		ora  #8
.8667	 8d 00 1c	sta $1c00		sta  ledprt	; led on
.866a	 58		cli			cli		; let controller run free
.866b	 20 b6 9f	jsr $9fb6		jsr  stbctl     ; strobe controller ( hit him hard )
.866e	 c9 02		cmp #$02	        cmp  #2         ; was there an error ?
.8670	 90 03		bcc $8675	        bcc  +		; br, nope
.8672	 20 83 86	jsr $8683		jsr  stbret	; let DOS retry
.8675	 78		sei		+	sei
.8676	 ad 00 1c	lda $1c00		lda  ledprt
.8679	 29 f7		and #$f7		and  #$ff-8
.867b	 8d 00 1c	sta $1c00		sta  ledprt	; led off
.867e	 b5 00		lda $00,x		lda  jobs,x	; get error return
.8680	 aa		tax			tax     	; return status in .x
.8681	 28		plp			plp		; restore original status
.8682	 60		rts			rts
.8683	 a9 ff		lda #$ff	stbret	lda  #$ff       ; micro-step if you can
.8685	 8d 98 02	sta $0298		sta  jobrtn	; set error recovery on
.8688	 86 f9		stx $f9			stx  jobnum	; set job #
.868a	 ad 02 02	lda $0202		lda  cmdbuf+2	; get command
.868d	 85 5f		sta $5f			sta  ctl_cmd	; reset command
.868f	 8d 4d 02	sta $024d		sta  cmd	; set for dos
.8692	 9d 5b 02	sta $025b,x		sta  lstjob,x	; set last job
.8695	 95 00		sta $00,x		sta  jobs,x	; -04 fix 02/24/86 ds, give it to the controller
.8697	 20 b6 9f	jsr $9fb6		jsr  stbctl	; wait for it
.869a	 4c 99 d5	jmp $d599		jmp  watjob	; let dos clean it up
.869d	 20 59 ea	jsr $ea59	burtst	jsr  tstatn     ; test for atn
.86a0					burst
.86a0	 ad 00 18	lda $1800	-	lda  pb		; debounce
.86a3	 cd 00 18	cmp $1800	        cmp  pb
.86a6	 d0 f8		bne $86a0	        bne  -		; same ?
.86a8	 29 ff		and #$ff		and  #$ff	; set/clr neg flag
.86aa	 30 f1		bmi $869d	        bmi  burtst	; br, attn low
.86ac	 45 37		eor $37		        eor  fastsr     ; wait for state chg
.86ae	 29 04		and #$04	        and  #4
.86b0	 f0 ee		beq $86a0	        beq  -
.86b2	 a5 37		lda $37			lda  fastsr
.86b4	 49 04		eor #$04		eor  #4
.86b6	 85 37		sta $37			sta  fastsr     ; state change
.86b8	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "mfmcntrl.asm"

;******  Processing file "mfmcntrl.asm"


>86b9	 00 15 00 00 00 15 00 bc  	cmdinf   .byte  $00,$15,$00,$00,$00,$15,$00,$bc
>86c1	 34 de fe dc 15 15 00     	         .byte  $34,$de,$fe,$dc,$15,$15,$00
>86c8	 ec 89                    	cmdjmp   .word    cmdzer         ; reset
>86ca	 ef 89                    	         .word    cmdone         ; bump
>86cc	 fd 89                    	         .word    cmdtwo         ; wp status
>86ce	 03 8a                    	         .word    cmdthr         ; setup for step
>86d0	 08 8a                    	         .word    cmdfor         ; reserved
>86d2	 09 8a                    	         .word    cmdfve         ; read address
>86d4	 ba 87                    	         .word    seke		 ; seek physical
>86d6	 86 8a                    	         .word    cmdsev         ; format track
>86d8	 57 8c                    	         .word    cmdeig         ; format disk
>86da	 67 8d                    	         .word    cmdnin         ; read sector
>86dc	 f6 8d                    	         .word    cmdten         ; write sector
>86de	 c6 8e                    	         .word    cmdele         ; verify
>86e0	 18 8f                    	         .word    cmdtwv         ; verify format
>86e2	 5f 8f                    	         .word    cmdthi         ; create sector table
>86e4	 b3 89                    	         .word    diskin	 ; is the disk home ?
=001e					cmdis    =  *-cmdjmp

.86e6	 78		sei		prcmd   sei
.86e7	 48		pha			pha		; save cmd
.86e8	 aa		tax		        tax
.86e9	 bd b9 86	lda $86b9,x	        lda  cmdinf,x   ; get information
.86ec	 85 1b		sta $1b		        sta  info
.86ee	 a5 5e		lda $5e			lda  dkmode
.86f0	 09 80		ora #$80		ora  #$80	; mfm mode
.86f2	 85 5e		sta $5e			sta  dkmode
.86f4	 06 1b		asl $1b		        asl  info       ; check track
.86f6	 90 05		bcc $86fd	        bcc  prc00
.86f8	 ad 03 02	lda $0203	        lda  cmdbuf+3
.86fb	 85 67		sta $67		        sta  cmd_trk	; save track
.86fd	 06 1b		asl $1b		prc00   asl  info       ; check sector
.86ff	 90 05		bcc $8706	        bcc  prc01
.8701	 ad 04 02	lda $0204	        lda  cmdbuf+4
.8704	 85 43		sta $43		        sta  sectr      ; save sector
.8706	 06 1b		asl $1b		prc01   asl  info       ; check wp for write jobs
.8708	 90 11		bcc $871b	        bcc  prc02
.870a	 ad 00 1c	lda $1c00	        lda  dskcnt
.870d	 29 10		and #$10	        and  #$10
.870f	 d0 0a		bne $871b	        bne  prc02
.8711	 a5 3b		lda $3b			lda  switch	; set kill job switch
.8713	 09 08		ora #$08		ora  #%00001000
.8715	 85 3b		sta $3b			sta  switch	; wp error
.8717	 a2 08		ldx #$08	        ldx  #8
.8719	 86 46		stx $46			stx  ctl_dat
.871b	 06 1b		asl $1b		prc02   asl  info       ; motor on ?
.871d	 90 03		bcc $8722	        bcc  prc03
.871f	 20 94 87	jsr $8794	        jsr  stmtr      ; start motor
.8722	 06 1b		asl $1b		prc03   asl  info       ; seek ?
.8724	 90 03		bcc $8729	        bcc  prc04      ; seek physical while motor is spinning
.8726	 20 ba 87	jsr $87ba	        jsr  seke       ; seek job
.8729	 06 1b		asl $1b		prc04   asl  info       ; wait for motor up to speed ?
.872b	 90 03		bcc $8730	        bcc  prc05
.872d	 20 b0 87	jsr $87b0	        jsr  wtmtr      ; go and wait
.8730	 20 54 89	jsr $8954	prc05   jsr  sel_sid	; select
.8733	 06 1b		asl $1b			asl  info	; logical seek required ?
.8735	 90 03		bcc $873a		bcc  prc06
.8737	 20 2a 89	jsr $892a		jsr  s_log	; seek by reading
.873a	 a9 00		lda #$00	prc06   lda  #0
.873c	 68		pla		        pla		; get jobs
.873d	 0a		asl a		        asl  a
.873e	 aa		tax		        tax
.873f	 bd c8 86	lda $86c8,x	        lda  cmdjmp,x   ; do indirect
.8742	 85 6f		sta $6f		        sta  temp
.8744	 bd c9 86	lda $86c9,x	        lda  cmdjmp+1,x
.8747	 85 70		sta $70		        sta  temp+1
.8749	 20 61 87	jsr $8761		jsr  do_the_command
.874c	 20 8f f9	jsr $f98f		jsr  trnoff	; motor off...
.874f	 ae b0 01	ldx $01b0		ldx  mfmcmd
.8752	 e0 02		cpx #$02		cpx  #2
.8754	 08		php			php
.8755	 06 1b		asl $1b			asl  info
.8757	 b0 06		bcs $875f		bcs  prc07
.8759	 28		plp		  	plp
.875a	 90 04		bcc $8760		bcc  prc08
.875c	 4c 8c 83	jmp $838c		jmp  exbad
.875f	 28		plp		prc07	plp		; restore status
.8760	 60		rts		prc08	rts
.8761	 6c 6f 00	jmp ($006f)	do_the_command	jmp  (temp)
.8764	 08		php		moton   php		; no irq's
.8765	 78		sei			sei
.8766	 ad 00 1c	lda $1c00		lda  dskcnt
.8769	 09 04		ora #$04		ora  #4
.876b	 8d 00 1c	sta $1c00		sta  dskcnt
.876e	 28		plp			plp		; retrieve status
.876f	 60		rts			rts
.8770	 08		php		motoff  php		; no irq's
.8771	 78		sei			sei
.8772	 ad 00 1c	lda $1c00		lda  dskcnt
.8775	 29 fb		and #$fb		and  #$ff-$04
.8777	 8d 00 1c	sta $1c00		sta  dskcnt
.877a	 28		plp			plp		; retrieve status
.877b	 60		rts			rts
.877c	 08		php		led_on	php		; no irq's
.877d	 78		sei			sei
.877e	 ad 00 1c	lda $1c00		lda  dskcnt	; turn on led
.8781	 09 08		ora #$08		ora  #8
.8783	 8d 00 1c	sta $1c00		sta  dskcnt
.8786	 28		plp			plp		; retrieve status
.8787	 60		rts			rts
.8788	 08		php		led_off	php		; no irq's
.8789	 78		sei			sei
.878a	 ad 00 1c	lda $1c00		lda  dskcnt	; turn led off
.878d	 29 f7		and #$f7		and  #$ff-$08
.878f	 8d 00 1c	sta $1c00		sta  dskcnt
.8792	 28		plp			plp		; retrieve status
.8793	 60		rts			rts
.8794					stmtr
.8794	 08		php			php
.8795	 78		sei		        sei
.8796	 a5 20		lda $20		        lda  drvst
.8798	 30 08		bmi $87a2		bmi  m2		; accelerating ?
.879a	 29 30		and #$30		and  #bit5+bit4
.879c	 f0 06		beq $87a4		beq  m1
.879e	 a9 20		lda #$20	        lda  #$20       ; disk up to speed
.87a0	 85 20		sta $20		        sta  drvst
.87a2	 28		plp		m2	plp
.87a3	 60		rts			rts
.87a4	 28		plp		m1	plp
.87a5	 85 3e		sta $3e			sta  cdrive	; set drive
.87a7	 4c 7e f9	jmp $f97e	        jmp  turnon	; turn on motor
.87aa	 ea		nop			nop
.87ab	 ea		nop			nop
.87ac	 ea		nop			nop
.87ad	 ea		nop			nop
.87ae	 ea		nop			nop
.87af	 ea		nop			nop
.87b0	 08		php		wtmtr   php             ; wait for motor up to speed
.87b1	 58		cli		        cli
.87b2	 a5 20		lda $20		wtmtr1  lda  drvst
.87b4	 c9 20		cmp #$20	        cmp  #$20       ; drv ready ?
.87b6	 d0 fa		bne $87b2	        bne  wtmtr1
.87b8	 28		plp		        plp
.87b9	 60		rts		        rts
.87ba	 08		php		seke    php  		; wait for not busy
.87bb	 58		cli		        cli             ; enable irqs for motor on timing
.87bc	 a5 67		lda $67		        lda  cmd_trk
.87be	 0a		asl a		        asl  a          ; half steps
.87bf	 c5 64		cmp $64		        cmp  cur_trk	; correct track ?
.87c1	 f0 1a		beq $87dd	        beq  sekrtn     ; br, yep
.87c3	 a5 67		lda $67		seklop  lda  cmd_trk	; where
.87c5	 0a		asl a		        asl  a
.87c6	 c5 64		cmp $64		        cmp  cur_trk
.87c8	 f0 0e		beq $87d8	        beq  sekdun
.87ca	 b0 06		bcs $87d2	        bcs  sekup      ; hi or lo ?
.87cc	 20 e7 87	jsr $87e7	sekdn   jsr  stout      ; step out
.87cf	 4c c3 87	jmp $87c3	        jmp  seklop     ; next
.87d2	 20 df 87	jsr $87df	sekup   jsr  stin       ; step in
.87d5	 4c c3 87	jmp $87c3	        jmp  seklop     ; next also
.87d8	 a0 10		ldy #$10	sekdun  ldy  #$10	; settle
.87da	 20 29 88	jsr $8829	        jsr  xms        ; delay
.87dd	 28		plp		sekrtn  plp
.87de	 60		rts		        rts
.87df	 a5 64		lda $64		stin    lda  cur_trk	; get current valuestep
.87e1	 18		clc			clc
.87e2	 69 01		adc #$01		adc  #1
.87e4	 4c 14 88	jmp $8814	        jmp  stpfin     ; half step out
.87e7					stout
.87e7	 a0 63		ldy #$63		ldy  #99	; wait for trk_00
.87e9	 ad 0f 18	lda $180f	-	lda  pota1	; check for trk_00
.87ec	 6a		ror a			ror  a		; rotate into carry
.87ed	 08		php			php		; save carry
.87ee	 ad 0f 18	lda $180f		lda  pota1	; debounce it
.87f1	 6a		ror a			ror  a		; carry <=
.87f2	 6a		ror a			ror  a		; bit 7 <=
.87f3	 28		plp			plp		; retrieve carry
.87f4	 29 80		and #$80		and  #$80	; set/clear sign bit
.87f6	 90 04		bcc $87fc		bcc  m3		; on track zero
.87f8	 10 15		bpl $880f		bpl  +		; carry set(off) & sign(on) exit
.87fa	 30 02		bmi $87fe		bmi  m4		; bra
.87fc	 30 11		bmi $880f	m3	bmi  +		; carry clear(on) & sign(off) exit
.87fe	 88		dey		m4	dey
.87ff	 d0 e8		bne $87e9		bne  -		; continue
.8801	 b0 0c		bcs $880f		bcs  +		; br, not track 00 ?
.8803	 ad 00 1c	lda $1c00		lda  dskcnt	; phase 0
.8806	 29 03		and #$03		and  #3
.8808	 d0 05		bne $880f		bne  +
.880a	 a9 00		lda #$00		lda  #0		; trk zero
.880c	 85 64		sta $64			sta  cur_trk	; current trk = 40*2/0
.880e	 60		rts			rts
.880f	 a5 64		lda $64		+	lda  cur_trk	; get current half step
.8811	 38		sec		        sec
.8812	 e9 01		sbc #$01		sbc #1
.8814	 85 64		sta $64		stpfin  sta  cur_trk	; save
.8816	 29 03		and #$03	        and  #3         ; strip unused
.8818	 85 6f		sta $6f		        sta  temp
.881a	 08		php			php		; no irq's
.881b	 78		sei			sei
.881c	 ad 00 1c	lda $1c00	        lda  dskcnt
.881f	 29 fc		and #$fc	        and  #$fc       ; strip step bits
.8821	 05 6f		ora $6f		        ora  temp
.8823	 8d 00 1c	sta $1c00	        sta  dskcnt
.8826	 28		plp			plp		; retrieve status
.8827	 a0 06		ldy #$06	        ldy  #$06	; 6 ms step time, 16 ms settle
.8829	 20 30 88	jsr $8830	xms     jsr  onems      ; delay 1 ms
.882c	 88		dey		        dey
.882d	 d0 fa		bne $8829	        bne  xms
.882f	 60		rts		        rts
.8830	 a2 02		ldx #$02	onems   ldx  #2
.8832	 a9 6f		lda #$6f	        lda  #$6f	; *** rom ds 12/27/85 ***, beta9 1 mS.
.8834	 69 01		adc #$01	onems1  adc  #1
.8836	 d0 fc		bne $8834	        bne  onems1
.8838	 ca		dex		        dex
.8839	 d0 f9		bne $8834	        bne  onems1
.883b	 60		rts		        rts
.883c					cvstat
.883c	 ea		nop			nop		; fill address error
.883d	 ad 00 20	lda $2000		lda  wdstat     ; retrieve status
.8840	 4a		lsr a		        lsr  a
.8841	 4a		lsr a		        lsr  a
.8842	 4a		lsr a		        lsr  a
.8843	 29 03		and #$03	        and  #3         ; check status
.8845	 aa		tax		        tax
.8846	 bd 82 8a	lda $8a82,x	        lda  mfmer,x
.8849	 8d b0 01	sta $01b0		sta  mfmcmd
.884c	 aa		tax			tax
.884d	 60		rts		        rts
.884e	 48		pha		strtwd  pha		; save accum
.884f	 20 7c 87	jsr $877c		jsr  led_on	; act led on
.8852	 68		pla			pla
.8853	 8d 00 20	sta $2000		sta  wdstat	; send cmd to wd 1770
.8856	 a9 01		lda #$01		lda  #1		; wait for busy
.8858	 ea		nop			nop		; fill address error
.8859	 2c 00 20	bit $2000	-	bit  wdstat
.885c	 f0 fb		beq $8859		beq  -
.885e	 4c 7e a4	jmp $a47e		jmp  jslower	; WD1770 bug ????
.8861	 20 88 87	jsr $8788	waitdn  jsr  led_off	; act led off
.8864	 a9 01		lda #$01		lda  #1		; wait for unbusy
.8866	 2c 00 20	bit $2000	-	bit  wdstat
.8869	 d0 fb		bne $8866		bne  -
.886b	 60		rts			rts
.886c	 a5 60		lda $60		sectnx  lda  minsek
.886e	 38		sec			sec
.886f	 e9 01		sbc #$01		sbc  #1
.8871	 85 46		sta $46			sta  ctl_dat	; save min sector - 1
.8873	 ad 04 02	lda $0204		lda  cmdbuf+4	; get original sector
.8876	 18		clc			clc
.8877	 65 3c		adc $3c			adc  cpmit	; next sector
.8879	 c5 61		cmp $61			cmp  maxsek
.887b	 f0 07		beq $8884		beq  +		; equal to or
.887d	 90 05		bcc $8884		bcc  +		;          less than
.887f	 e5 61		sbc $61			sbc  maxsek	; rap around
.8881	 18		clc			clc
.8882	 65 46		adc $46			adc  ctl_dat	; add min now
.8884	 8d 04 02	sta $0204	+	sta  cmdbuf+4	; next sector for controller
.8887	 60		rts			rts
.8888	 a0 00		ldy #$00	sectcv	ldy  #0
.888a	 a2 00		ldx #$00		ldx  #0
.888c	 ad 03 02	lda $0203		lda  cmdbuf+3   ; start at sector x
.888f	 29 3f		and #$3f		and  #$3f	; delete mode bit & table bit
.8891	 8d 03 02	sta $0203		sta  cmdbuf+3
.8894	 85 60		sta $60			sta  minsek	; new min
.8896	 48		pha			pha		; save ss
.8897	 ad 07 02	lda $0207		lda  cmdbuf+7	; save ns
.889a	 48		pha			pha
.889b	 ee 04 02	inc $0204		inc  cmdbuf+4	; interleave + 1
.889e	 ad 03 02	lda $0203	sectop	lda  cmdbuf+3	; ss
.88a1	 99 0b 02	sta $020b,y		sta  cmdbuf+11,y ; table goes to cmdbuf+42
.88a4	 ee 03 02	inc $0203		inc  cmdbuf+3	; increment ss
.88a7	 e8		inx			inx
.88a8	 98		tya			tya		; do addition
.88a9	 18		clc			clc
.88aa	 6d 04 02	adc $0204		adc  cmdbuf+4	; add interleave
.88ad	 a8		tay			tay
.88ae	 c0 20		cpy #$20		cpy  #32	; no more room
.88b0	 b0 0c		bcs $88be		bcs  bd_int
.88b2	 cc 07 02	cpy $0207		cpy  cmdbuf+7	; ns
.88b5	 90 1a		bcc $88d1		bcc  secles	; < than
.88b7	 d0 12		bne $88cb		bne  seclmo	; can't be equal until the end
.88b9	 ec 07 02	cpx $0207		cpx  cmdbuf+7	; ns end ?
.88bc	 f0 0d		beq $88cb		beq  seclmo
.88be	 ce 04 02	dec $0204	bd_int  dec  cmdbuf+4	; restore
.88c1	 68		pla			pla
.88c2	 8d 07 02	sta $0207		sta  cmdbuf+7	; restore ns
.88c5	 68		pla			pla
.88c6	 8d 03 02	sta $0203		sta  cmdbuf+3	; restore ss
.88c9	 38		sec			sec
.88ca	 60		rts			rts		; bad exit
.88cb	 98		tya		seclmo  tya
.88cc	 38		sec			sec
.88cd	 ed 07 02	sbc $0207		sbc  cmdbuf+7	; ns
.88d0	 a8		tay			tay
.88d1	 ec 07 02	cpx $0207	secles	cpx  cmdbuf+7	; ns
.88d4	 d0 c8		bne $889e		bne  sectop
.88d6	 86 97		stx $97			stx  cpmsek	; ns
.88d8	 ca		dex			dex
.88d9	 8a		txa			txa
.88da	 18		clc			clc
.88db	 65 60		adc $60			adc  minsek	; find max
.88dd	 85 61		sta $61			sta  maxsek	; new max
.88df	 c5 60		cmp $60			cmp  minsek	; better be less than max
.88e1	 90 db		bcc $88be		bcc  bd_int	; bad starting sector
.88e3	 68		pla			pla
.88e4	 8d 07 02	sta $0207		sta  cmdbuf+7	; restore ns
.88e7	 68		pla			pla
.88e8	 8d 03 02	sta $0203		sta  cmdbuf+3	; restore ss
.88eb	 ce 04 02	dec $0204		dec  cmdbuf+4	; restore
.88ee	 18		clc			clc		; ok exit
.88ef	 60		rts			rts
.88f0	 ad b0 01	lda $01b0	verfmt	lda  mfmcmd
.88f3	 48		pha			pha		; save current logical track
.88f4	 a0 00		ldy #$00		ldy  #0
.88f6	 84 24		sty $24			sty  mfmhdr	; init index into sector table
.88f8	 a4 24		ldy $24		ver_fm	ldy  mfmhdr	; get current index
.88fa	 b9 0b 02	lda $020b,y		lda  cmdbuf+11,y
.88fd	 8d 02 20	sta $2002		sta  wdsec	; setup sector for wd 1770
.8900	 20 18 8f	jsr $8f18		jsr  cmdtwv	; verify
.8903	 ae b0 01	ldx $01b0		ldx  mfmcmd	; get error
.8906	 e0 02		cpx #$02		cpx  #2
.8908	 b0 0b		bcs $8915		bcs  ver_00
.890a	 e6 24		inc $24			inc  mfmhdr	; next entry in sector table
.890c	 a4 24		ldy $24			ldy  mfmhdr
.890e	 cc 07 02	cpy $0207		cpy  cmdbuf+7	; check with ns
.8911	 d0 e5		bne $88f8		bne  ver_fm	; done ?
.8913	 18		clc			clc

>8914	 24                       		.byte  skip1

.8915	 38		sec		ver_00	sec
.8916	 68		pla			pla
.8917	 8d b0 01	sta $01b0		sta  mfmcmd	; restore track address
.891a	 60		rts		no_trk	rts
.891b	 ad 74 02	lda $0274	chcsee	lda  cmdsiz
.891e	 c9 07		cmp #$07		cmp  #7		; next track parameter given ?
.8920	 90 f8		bcc $891a		bcc  no_trk
.8922	 ad 06 02	lda $0206		lda  cmdbuf+6	; get nt
.8925	 85 67		sta $67			sta  cmd_trk
.8927	 4c ba 87	jmp $87ba		jmp  seke
.892a					s_log
.892a	 ad b0 01	lda $01b0		lda  mfmcmd	; save command
.892d	 48		pha			pha
.892e	 20 27 8a	jsr $8a27		jsr  cmdfiv	; where are we?
.8931	 ae b0 01	ldx $01b0		ldx  mfmcmd	; status ok?
.8934	 e0 02		cpx #$02		cpx  #2
.8936	 90 0d		bcc $8945		bcc  m1		; see if we are there...
.8938	 20 ef 89	jsr $89ef		jsr  cmdone	; restore to trk_00
.893b	 20 27 8a	jsr $8a27		jsr  cmdfiv	; where are we.. better be track 00
.893e	 ae b0 01	ldx $01b0		ldx  mfmcmd	; status ok?
.8941	 e0 02		cpx #$02		cpx  #2
.8943	 b0 0a		bcs $894f		bcs  m2		; on error leave on track 00
.8945	 a5 67		lda $67		m1	lda  cmd_trk	; we there yet ?
.8947	 0a		asl a			asl  a
.8948	 c5 64		cmp $64			cmp  cur_trk	; are we on ?
.894a	 f0 03		beq $894f		beq  m2
.894c	 20 ba 87	jsr $87ba		jsr  seke	; find it...should be there now...hope?
.894f	 68		pla		m2	pla
.8950	 8d b0 01	sta $01b0		sta  mfmcmd	; restore command
.8953	 60		rts			rts
.8954	 08		php		sel_sid php		; no irq's
.8955	 78		sei			sei
.8956	 a5 3b		lda $3b			lda  switch
.8958	 29 10		and #$10		and  #%00010000 ; check side
.895a	 c9 10		cmp #$10		cmp  #%00010000	; set/clr carry
.895c	 20 f3 93	jsr $93f3		jsr  set_side	; set h/w
.895f	 28		plp			plp		; retrieve status
.8960	 60		rts			rts
.8961	 a4 97		ldy $97		maxmin	ldy  cpmsek	; get ns
.8963	 88		dey			dey		; one less
.8964	 a9 ff		lda #$ff		lda  #255	; as small as min can get
.8966	 d9 0b 02	cmp $020b,y	minim	cmp  cmdbuf+11,y
.8969	 90 03		bcc $896e		bcc  no_min	; br, no change
.896b	 b9 0b 02	lda $020b,y		lda  cmdbuf+11,y
.896e	 88		dey		no_min	dey
.896f	 10 f5		bpl $8966		bpl  minim
.8971	 85 60		sta $60			sta  minsek	; save min
.8973	 a4 97		ldy $97			ldy  cpmsek
.8975	 88		dey			dey		; one less
.8976	 a9 00		lda #$00		lda  #0		; as small as max can get
.8978	 d9 0b 02	cmp $020b,y	maxim	cmp  cmdbuf+11,y
.897b	 b0 03		bcs $8980		bcs  no_max	; br, no change
.897d	 b9 0b 02	lda $020b,y		lda  cmdbuf+11,y
.8980	 88		dey		no_max	dey
.8981	 10 f5		bpl $8978		bpl  maxim
.8983	 85 61		sta $61			sta  maxsek	; save max
.8985	 60		rts			rts
.8986	 a6 97		ldx $97		fn_int	ldx  cpmsek	; location of min
.8988	 a0 00		ldy #$00		ldy  #0		; start in beginning
.898a	 b9 0b 02	lda $020b,y	fn_000	lda  cmdbuf+11,y
.898d	 c5 60		cmp $60			cmp  minsek
.898f	 f0 05		beq $8996		beq  fn_001	; min ?
.8991	 c8		iny			iny
.8992	 c4 97		cpy $97			cpy  cpmsek
.8994	 d0 f4		bne $898a		bne  fn_000
.8996	 84 5f		sty $5f		fn_001  sty  ctl_cmd	; save index
.8998	 a5 60		lda $60			lda  minsek	; get min
.899a	 18		clc			clc
.899b	 69 01		adc #$01		adc  #1		; add one to it
.899d	 85 46		sta $46			sta  ctl_dat	; save min + 1
.899f	 a2 ff		ldx #$ff		ldx  #255	; interleave at zero
.89a1	 b9 0b 02	lda $020b,y	fnlook	lda  cmdbuf+11,y
.89a4	 c5 46		cmp $46			cmp  ctl_dat	; find min + 1 ?
.89a6	 f0 0a		beq $89b2		beq  fn_002
.89a8	 e8		inx			inx		; cpmit = cpmit + 1
.89a9	 c8		iny			iny
.89aa	 c4 97		cpy $97			cpy  cpmsek	; index here ?
.89ac	 d0 f3		bne $89a1		bne  fnlook
.89ae	 a0 00		ldy #$00		ldy  #0		; rap around
.89b0	 f0 ef		beq $89a1		beq  fnlook 	; bra
.89b2	 60		rts		fn_002	rts		; return with hard interleave in .x
.89b3					diskin
.89b3	 a5 6f		lda $6f			lda  temp
.89b5	 48		pha			pha		; save temp
.89b6	 08		php			php		; save status
.89b7	 78		sei			sei		; no irq's
.89b8	 ad 01 20	lda $2001		lda  wdtrk	; where are we ?
.89bb	 8d 03 20	sta $2003		sta  wddat	; here we are..
.89be	 a9 18		lda #$18		lda  #$18
.89c0	 20 4e 88	jsr $884e		jsr  strtwd	; seek cmd
.89c3	 20 61 88	jsr $8861		jsr  waitdn	; fin ?
.89c6	 a2 00		ldx #$00		ldx  #0
.89c8	 a0 80		ldy #$80		ldy  #128	; wait a little more than a revolution
.89ca	 ad 00 20	lda $2000		lda  wdstat	; get start status
.89cd	 29 02		and #$02		and  #2
.89cf	 85 6f		sta $6f			sta  temp	; save current status
.89d1	 ad 00 20	lda $2000	-	lda  wdstat	; get current status
.89d4	 29 02		and #$02		and  #2
.89d6	 c5 6f		cmp $6f			cmp  temp	; same go on
.89d8	 f0 04		beq $89de		beq  +
.89da	 28		plp			plp		; retrieve status
.89db	 4c e7 89	jmp $89e7		jmp  m4		; finish up ok disk inserted
.89de	 ca		dex		+	dex
.89df	 d0 f0		bne $89d1		bne  -
.89e1	 88		dey			dey
.89e2	 d0 ed		bne $89d1		bne  -		; timout ?
.89e4	 28		plp			plp		; retrieve status
.89e5	 38		sec			sec		; exit no index sensor toggling

>89e6	 24                       		.byte skip1

.89e7	 18		clc		m4	clc		; ok
.89e8	 68		pla			pla
.89e9	 85 6f		sta $6f			sta  temp	; restore temp
.89eb	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "mfmsubr.asm"

;******  Processing file "mfmsubr.asm"

.89ec	 4c a0 ea	jmp $eaa0	cmdzer  jmp  dskint     ; reset
.89ef	 a9 b4		lda #$b4	cmdone  lda  #180
.89f1	 85 64		sta $64			sta  cur_trk
.89f3	 a9 00		lda #$00		lda  #0		; side zero
.89f5	 8d 01 20	sta $2001		sta  wdtrk	; init to trk zero
.89f8	 85 67		sta $67			sta  cmd_trk	; find zero
.89fa	 4c ba 87	jmp $87ba	        jmp  seke
.89fd	 ad 00 1c	lda $1c00	cmdtwo  lda  dskcnt	; return status of wp
.8a00	 29 10		and #$10	        and  #$10
.8a02	 60		rts		        rts
.8a03	 84 67		sty $67		cmdthr  sty  cmd_trk
.8a05	 86 64		stx $64			stx  cur_trk
.8a07	 60		rts			rts
.8a08	 60		rts		cmdfor  rts             ; reserved
.8a09	 20 ef 89	jsr $89ef	cmdfve	jsr  cmdone	; restore
.8a0c	 20 b3 89	jsr $89b3		jsr  diskin	; is there a disk in the drive ?
.8a0f	 b0 0f		bcs $8a20		bcs  +
.8a11	 20 27 8a	jsr $8a27		jsr  cmdfiv	; seek
.8a14	 bd 7e 8a	lda $8a7e,x		lda  nsectk,x	; get # of sectors
.8a17	 85 97		sta $97			sta  cpmsek	; set def.
.8a19	 85 61		sta $61			sta  maxsek	; store max sector number....def, ok
.8a1b	 a9 01		lda #$01		lda  #1
.8a1d	 85 60		sta $60			sta  minsek	; let query decide otherwise....def, ok
.8a1f	 60		rts			rts
.8a20	 a9 0d		lda #$0d	+	lda  #$0d	; no disk
.8a22	 8d b0 01	sta $01b0		sta  mfmcmd	; error
.8a25	 d0 3e		bne $8a65		bne  abrsk	; abort
.8a27	 a9 00		lda #$00	cmdfiv  lda  #0
.8a29	 8d 71 02	sta $0271	        sta  mfmsiz_lo  ; clear sector size
.8a2c	 85 44		sta $44		        sta  mfmsiz_hi  ; *
.8a2e	 a9 c8		lda #$c8	        lda  #$c8       ; read address
.8a30	 20 4e 88	jsr $884e		jsr  strtwd	; start cmd
.8a33	 a2 00		ldx #$00	        ldx  #0
.8a35	 a0 06		ldy #$06	        ldy  #6
.8a37	 ad 00 20	lda $2000	mseek1  lda  wdstat
.8a3a	 29 03		and #$03		and  #3
.8a3c	 4a		lsr a			lsr  a
.8a3d	 90 0b		bcc $8a4a	        bcc  mrcnf      ; no address mark found
.8a3f	 f0 f6		beq $8a37		beq  mseek1
.8a41	 ad 03 20	lda $2003	        lda  wddat      ; get data
.8a44	 95 24		sta $24,x	        sta  mfmhdr,x   ; data in .a
.8a46	 e8		inx		        inx
.8a47	 88		dey		        dey
.8a48	 d0 ed		bne $8a37	        bne  mseek1
.8a4a	 20 61 88	jsr $8861	mrcnf	jsr  waitdn	; wait for not busy
.8a4d	 20 3c 88	jsr $883c	        jsr  cvstat     ; get status
.8a50	 a5 24		lda $24		mseek3  lda  mfmhdr     ; read track address
.8a52	 0a		asl a			asl  a		; * 2
.8a53	 85 64		sta $64		        sta  cur_trk
.8a55	 a5 27		lda $27		        lda  mfmhdr+3   ; get sector size
.8a57	 29 03		and #$03	consek  and  #3         ; clear remaining
.8a59	 aa		tax		        tax
.8a5a	 bd 72 8a	lda $8a72,x		lda  sectlo,x
.8a5d	 8d 71 02	sta $0271	        sta  mfmsiz_lo  ; sector size low
.8a60	 bd 76 8a	lda $8a76,x	        lda  secthi,x
.8a63	 85 44		sta $44		        sta  mfmsiz_hi  ; sector size high
.8a65	 a5 5e		lda $5e		abrsk   lda  dkmode     ; set sector size in
.8a67	 29 80		and #$80	        and  #%10000000 ; clear all but mode bit
.8a69	 0d b0 01	ora $01b0		ora  mfmcmd	; set status
.8a6c	 1d 7a 8a	ora $8a7a,x		ora  seckzz,x	; shifted sector size
.8a6f	 85 5e		sta $5e		        sta  dkmode
.8a71	 60		rts			rts

>8a72	 7f ff ff ff              	sectlo   .byte  127,255,255,255
>8a76	 01 01 02 04              	secthi   .byte  1,1,2,4
>8a7a	 00 10 20 30              	seckzz   .byte  $00,$10,$20,$30
>8a7e	 1a 10 09 05              	nsectk	 .byte  26, 16, 9, 5
>8a82	 01 09 02 03              	mfmer    .byte  1,9,2,3

;******  Return to file "serlib.asm"

						.include "mfmsubr1.asm"

;******  Processing file "mfmsubr1.asm"


.8a86	 a9 f8		lda #$f8	cmdsev  lda  #$f8	; write track
.8a88	 20 4e 88	jsr $884e		jsr  strtwd	; send command
.8a8b	 24 3b		bit $3b			bit  switch	; system 34 / iso standard switch
.8a8d	 50 62		bvc $8af1		bvc  no_ind	; write index ?
.8a8f	 a2 50		ldx #$50		ldx  #80
.8a91	 ad 00 20	lda $2000	-       lda  wdstat
.8a94	 29 03		and #$03		and  #3
.8a96	 4a		lsr a			lsr  a
.8a97	 90 60		bcc $8af9		bcc  v6
.8a99	 f0 f6		beq $8a91		beq  -
.8a9b	 a9 4e		lda #$4e		lda  #$4e
.8a9d	 8d 03 20	sta $2003		sta  wddat	; give him the data
.8aa0	 ca		dex			dex
.8aa1	 d0 ee		bne $8a91		bne  -
.8aa3	 a2 0c		ldx #$0c		ldx  #12
.8aa5	 ad 00 20	lda $2000	-	lda  wdstat
.8aa8	 29 03		and #$03		and  #3
.8aaa	 4a		lsr a			lsr  a
.8aab	 90 4c		bcc $8af9		bcc  v6
.8aad	 f0 f6		beq $8aa5		beq  -
.8aaf	 a9 00		lda #$00		lda  #0
.8ab1	 8d 03 20	sta $2003		sta  wddat
.8ab4	 ca		dex			dex
.8ab5	 d0 ee		bne $8aa5		bne  -
.8ab7	 a2 03		ldx #$03		ldx  #3
.8ab9	 ad 00 20	lda $2000	-	lda  wdstat
.8abc	 29 03		and #$03		and  #3
.8abe	 4a		lsr a			lsr  a
.8abf	 90 38		bcc $8af9		bcc  v6
.8ac1	 f0 f6		beq $8ab9		beq  -
.8ac3	 a9 f6		lda #$f6		lda  #$f6
.8ac5	 8d 03 20	sta $2003		sta  wddat
.8ac8	 ca		dex			dex
.8ac9	 d0 ee		bne $8ab9		bne  -
.8acb	 ad 00 20	lda $2000	-	lda  wdstat
.8ace	 29 03		and #$03		and  #3
.8ad0	 4a		lsr a			lsr  a
.8ad1	 90 26		bcc $8af9		bcc  v6
.8ad3	 f0 f6		beq $8acb		beq  -
.8ad5	 a9 fc		lda #$fc		lda  #$fc
.8ad7	 8d 03 20	sta $2003		sta  wddat
.8ada	 a2 32		ldx #$32		ldx  #50
.8adc	 ea		nop			nop		; fill address error
.8add	 ad 00 20	lda $2000	-       lda  wdstat
.8ae0	 29 03		and #$03		and  #3
.8ae2	 4a		lsr a			lsr  a
.8ae3	 90 14		bcc $8af9		bcc  v6
.8ae5	 f0 f6		beq $8add		beq  -
.8ae7	 a9 4e		lda #$4e		lda  #$4e
.8ae9	 8d 03 20	sta $2003		sta  wddat	; give him the data
.8aec	 ca		dex			dex
.8aed	 d0 ee		bne $8add		bne  -
.8aef	 f0 14		beq $8b05		beq  inner	; bra... done...
.8af1	 a2 3c		ldx #$3c	no_ind	ldx  #60
.8af3	 ad 00 20	lda $2000	cmd7    lda  wdstat
.8af6	 29 03		and #$03		and  #3
.8af8	 4a		lsr a			lsr  a
.8af9	 90 28		bcc $8b23	v6	bcc  v1
.8afb	 f0 f6		beq $8af3		beq  cmd7
.8afd	 a9 4e		lda #$4e		lda  #$4e
.8aff	 8d 03 20	sta $2003		sta  wddat	; give him the data
.8b02	 ca		dex			dex
.8b03	 d0 ee		bne $8af3		bne  cmd7
.8b05	 a0 01		ldy #$01	inner	ldy  #1  	; ss
.8b07	 a2 0c		ldx #$0c	main7	ldx  #12
.8b09	 ad 00 20	lda $2000	cmd70   lda  wdstat
.8b0c	 29 03		and #$03		and  #3
.8b0e	 4a		lsr a			lsr  a
.8b0f	 90 12		bcc $8b23		bcc  v1
.8b11	 f0 f6		beq $8b09		beq  cmd70
.8b13	 a9 00		lda #$00		lda  #0
.8b15	 8d 03 20	sta $2003		sta  wddat
.8b18	 ca		dex			dex
.8b19	 d0 ee		bne $8b09		bne  cmd70
.8b1b	 a2 03		ldx #$03		ldx  #3
.8b1d	 ad 00 20	lda $2000	cmd71   lda  wdstat
.8b20	 29 03		and #$03		and  #3
.8b22	 4a		lsr a			lsr  a
.8b23	 90 57		bcc $8b7c	v1	bcc  v2
.8b25	 f0 f6		beq $8b1d		beq  cmd71
.8b27	 a9 f5		lda #$f5		lda  #$f5
.8b29	 8d 03 20	sta $2003		sta  wddat
.8b2c	 ca		dex			dex
.8b2d	 d0 ee		bne $8b1d		bne  cmd71
.8b2f	 ad 00 20	lda $2000	cmd7n   lda  wdstat
.8b32	 29 03		and #$03		and  #3
.8b34	 4a		lsr a			lsr  a
.8b35	 90 45		bcc $8b7c		bcc  v2
.8b37	 f0 f6		beq $8b2f		beq  cmd7n
.8b39	 a9 fe		lda #$fe		lda  #$fe   	; id address mark
.8b3b	 8d 03 20	sta $2003		sta  wddat
.8b3e	 ad 00 20	lda $2000	cmd7f   lda  wdstat
.8b41	 29 03		and #$03		and  #3
.8b43	 4a		lsr a			lsr  a
.8b44	 90 36		bcc $8b7c		bcc  v2
.8b46	 f0 f6		beq $8b3e		beq  cmd7f
.8b48	 ad b0 01	lda $01b0		lda  mfmcmd	; give him the track
.8b4b	 8d 03 20	sta $2003		sta  wddat
.8b4e	 ad 00 20	lda $2000	cmd7e   lda  wdstat
.8b51	 29 03		and #$03		and  #3
.8b53	 4a		lsr a			lsr  a
.8b54	 90 26		bcc $8b7c		bcc  v2
.8b56	 f0 f6		beq $8b4e		beq  cmd7e
.8b58	 a5 3b		lda $3b			lda  switch
.8b5a	 29 10		and #$10		and  #%00010000 ; what side are we on ?
.8b5c	 d0 03		bne $8b61		bne  +
.8b5e	 a9 00		lda #$00		lda  #0

>8b60	 2c                       		.byte skip2

.8b61	 a9 01		lda #$01	+	lda  #1
.8b63	 8d 03 20	sta $2003		sta  wddat	; side number is ...
.8b66	 ad 00 20	lda $2000	cmd7d   lda  wdstat
.8b69	 29 03		and #$03		and  #3
.8b6b	 4a		lsr a			lsr  a
.8b6c	 90 0e		bcc $8b7c		bcc  v2
.8b6e	 f0 f6		beq $8b66		beq  cmd7d
.8b70	 b9 0a 02	lda $020a,y		lda  cmdbuf+10,y ; sector number actually cmdbuf+11
.8b73	 8d 03 20	sta $2003		sta  wddat
.8b76	 ad 00 20	lda $2000	cmd7c   lda  wdstat
.8b79	 29 03		and #$03		and  #3
.8b7b	 4a		lsr a			lsr  a
.8b7c	 90 33		bcc $8bb1	v2	bcc  v3
.8b7e	 f0 f6		beq $8b76		beq  cmd7c
.8b80	 ad 05 02	lda $0205		lda  cmdbuf+5	; sz
.8b83	 8d 03 20	sta $2003		sta  wddat
.8b86	 ad 00 20	lda $2000	cmd7b   lda  wdstat
.8b89	 29 03		and #$03		and  #3
.8b8b	 4a		lsr a			lsr  a
.8b8c	 90 23		bcc $8bb1		bcc  v3
.8b8e	 f0 f6		beq $8b86		beq  cmd7b
.8b90	 a9 f7		lda #$f7		lda  #$f7	; crc 2 bytes written
.8b92	 8d 03 20	sta $2003		sta  wddat
.8b95	 a2 16		ldx #$16		ldx  #22
.8b97	 ad 00 20	lda $2000	cmd72   lda  wdstat
.8b9a	 29 03		and #$03		and  #3
.8b9c	 4a		lsr a			lsr  a
.8b9d	 90 12		bcc $8bb1		bcc  v3
.8b9f	 f0 f6		beq $8b97		beq  cmd72
.8ba1	 a9 4e		lda #$4e		lda  #$4e
.8ba3	 8d 03 20	sta $2003		sta  wddat
.8ba6	 ca		dex			dex
.8ba7	 d0 ee		bne $8b97		bne  cmd72
.8ba9	 a2 0c		ldx #$0c		ldx  #12
.8bab	 ad 00 20	lda $2000	cmd73   lda  wdstat
.8bae	 29 03		and #$03		and  #3
.8bb0	 4a		lsr a			lsr  a
.8bb1	 90 38		bcc $8beb	v3	bcc  v4
.8bb3	 f0 f6		beq $8bab		beq  cmd73
.8bb5	 a9 00		lda #$00		lda  #0
.8bb7	 8d 03 20	sta $2003		sta  wddat
.8bba	 ca		dex			dex
.8bbb	 d0 ee		bne $8bab		bne  cmd73
.8bbd	 a2 03		ldx #$03		ldx  #3
.8bbf	 ad 00 20	lda $2000	cmd74   lda  wdstat
.8bc2	 29 03		and #$03		and  #3
.8bc4	 4a		lsr a			lsr  a
.8bc5	 90 24		bcc $8beb		bcc  v4
.8bc7	 f0 f6		beq $8bbf		beq  cmd74
.8bc9	 a9 f5		lda #$f5		lda  #$f5	; a1
.8bcb	 8d 03 20	sta $2003		sta  wddat
.8bce	 ca		dex			dex
.8bcf	 d0 ee		bne $8bbf		bne  cmd74
.8bd1	 ad 00 20	lda $2000	cmd7a   lda  wdstat
.8bd4	 29 03		and #$03		and  #3
.8bd6	 4a		lsr a			lsr  a
.8bd7	 90 12		bcc $8beb		bcc  v4
.8bd9	 f0 f6		beq $8bd1		beq  cmd7a
.8bdb	 a9 fb		lda #$fb		lda  #$fb	; dam
.8bdd	 8d 03 20	sta $2003		sta  wddat
.8be0	 84 6f		sty $6f			sty  temp	; save current sector
.8be2	 a4 44		ldy $44			ldy  mfmsiz_hi	; high
.8be4	 ea		nop			nop		; fill address error
.8be5	 ad 00 20	lda $2000	cmd750  lda  wdstat
.8be8	 29 03		and #$03		and  #3
.8bea	 4a		lsr a			lsr  a
.8beb	 90 60		bcc $8c4d	v4	bcc  v5
.8bed	 f0 f6		beq $8be5		beq  cmd750
.8bef	 ad 0a 02	lda $020a		lda  cmdbuf+10  ; fl
.8bf2	 8d 03 20	sta $2003		sta  wddat
.8bf5	 ec 71 02	cpx $0271		cpx  mfmsiz_lo
.8bf8	 f0 04		beq $8bfe		beq  cmd75x
.8bfa	 e8		inx			inx		; increment
.8bfb	 4c e5 8b	jmp $8be5		jmp  cmd750
.8bfe	 e8		inx		cmd75x	inx
.8bff	 88		dey			dey
.8c00	 d0 e3		bne $8be5		bne  cmd750
.8c02	 ad 00 20	lda $2000	cmd7ff  lda  wdstat
.8c05	 29 03		and #$03		and  #3
.8c07	 4a		lsr a			lsr  a
.8c08	 90 43		bcc $8c4d		bcc  v5
.8c0a	 f0 f6		beq $8c02		beq  cmd7ff
.8c0c	 a9 f7		lda #$f7		lda  #$f7	; crc
.8c0e	 8d 03 20	sta $2003		sta  wddat
.8c11	 ac 05 02	ldy $0205		ldy  cmdbuf+5	; ss
.8c14	 b9 4f 8c	lda $8c4f,y		lda  gapmfm,y
.8c17	 a4 6f		ldy $6f			ldy  temp	; sector restore
.8c19	 aa		tax			tax
.8c1a	 ad 00 20	lda $2000	cmd7fe  lda  wdstat
.8c1d	 29 03		and #$03		and  #3
.8c1f	 4a		lsr a			lsr  a
.8c20	 90 2b		bcc $8c4d		bcc  v5
.8c22	 f0 f6		beq $8c1a		beq  cmd7fe
.8c24	 a9 4e		lda #$4e		lda  #$4e	; gap 3
.8c26	 8d 03 20	sta $2003		sta  wddat
.8c29	 ca		dex			dex
.8c2a	 d0 ee		bne $8c1a		bne  cmd7fe
.8c2c	 cc 07 02	cpy $0207		cpy  cmdbuf+7	; ns
.8c2f	 f0 04		beq $8c35		beq  finmfm
.8c31	 c8		iny			iny		; inc sector
.8c32	 4c 07 8b	jmp $8b07		jmp  main7
.8c35	 ad 00 20	lda $2000	finmfm  lda  wdstat
.8c38	 29 03		and #$03		and  #3
.8c3a	 4a		lsr a			lsr  a
.8c3b	 90 0b		bcc $8c48		bcc  vfin
.8c3d	 f0 f6		beq $8c35		beq  finmfm
.8c3f	 18		clc			clc
.8c40	 a9 4e		lda #$4e		lda  #$4e	; wait for wd to time out
.8c42	 8d 03 20	sta $2003		sta  wddat
.8c45	 4c 35 8c	jmp $8c35		jmp  finmfm
.8c48	 20 61 88	jsr $8861	vfin    jsr  waitdn	; wait for sleepy time
.8c4b	 18		clc			clc		; good carry

>8c4c	 24                       	        .byte skip1

.8c4d	 38		sec		v5     	sec
.8c4e	 60		rts			rts

>8c4f	 07 0c 17 2c              	gapmfm 	.byte 7, 12, 23, 44
>8c53	 1a 10 09 05              	numsek  .byte 26, 16, 9, 5

.8c57	 a5 3b		lda $3b		cmdeig  lda  switch	; check abort command switch
.8c59	 29 08		and #$08		and  #%00001000
.8c5b	 f0 07		beq $8c64		beq  +
.8c5d	 a6 46		ldx $46			ldx  ctl_dat	; get error
.8c5f	 8e b0 01	stx $01b0		stx  mfmcmd	; save for prcmd
.8c62	 38		sec			sec		; wp error usually
.8c63	 60		rts			rts
.8c64	 20 07 d3	jsr $d307	+	jsr  clrchn	; close all channels
.8c67	 ad 74 02	lda $0274		lda  cmdsiz	; setup default parms
.8c6a	 38		sec			sec
.8c6b	 e9 04		sbc #$04		sbc  #4		; less mandatory + 1
.8c6d	 a8		tay			tay
.8c6e	 f0 20		beq $8c90		beq  cp00	; mode only, gave cp
.8c70	 88		dey			dey
.8c71	 f0 22		beq $8c95		beq  sz00	; md, cp only, gave sz
.8c73	 a9 00		lda #$00		lda  #0
.8c75	 8d b0 01	sta $01b0		sta  mfmcmd	; clear status
.8c78	 ad 05 02	lda $0205		lda  cmdbuf+5
.8c7b	 20 57 8a	jsr $8a57		jsr  consek	; setup sector size
.8c7e	 88		dey			dey
.8c7f	 f0 21		beq $8ca2		beq  lt00	; md, cp, sz only, gave lt
.8c81	 88		dey			dey
.8c82	 f0 23		beq $8ca7		beq  ns00	; md, cp, sz, lt only, gave ns
.8c84	 88		dey			dey
.8c85	 f0 26		beq $8cad	 	beq  st00       ; md, cp, sz, lt, ns only, gave st
.8c87	 88		dey			dey
.8c88	 f0 2b		beq $8cb5		beq  s00        ; md, cp, sz, lt, ns, st only, gave s
.8c8a	 88		dey			dey
.8c8b	 f0 2d		beq $8cba		beq  fl00	; md, cp, sz, lt, ns, st, ss only, gave fl
.8c8d	 4c bf 8c	jmp $8cbf		jmp  start8
.8c90	 a9 00		lda #$00	cp00	lda  #0		; default interleave
.8c92	 8d 04 02	sta $0204		sta  cmdbuf+4
.8c95	 a9 00		lda #$00	sz00	lda  #0
.8c97	 8d b0 01	sta $01b0		sta  mfmcmd	; clear status
.8c9a	 a9 01		lda #$01		lda  #1		; 256 byte sectors
.8c9c	 8d 05 02	sta $0205		sta  cmdbuf+5
.8c9f	 20 57 8a	jsr $8a57		jsr  consek	; setup block size
.8ca2	 a9 27		lda #$27	lt00	lda  #39	; last track is #39, 40 tracks total
.8ca4	 8d 06 02	sta $0206		sta  cmdbuf+6
.8ca7	 bd 53 8c	lda $8c53,x	ns00	lda  numsek,x	; x=sector size index for # of sectors per track
.8caa	 8d 07 02	sta $0207		sta  cmdbuf+7
.8cad	 a9 00		lda #$00	st00	lda  #0		; default track #0 start
.8caf	 8d 08 02	sta $0208		sta  cmdbuf+8
.8cb2	 8d 01 20	sta $2001		sta  wdtrk
.8cb5	 a9 00		lda #$00	s00	lda  #0		; default steps from track 00
.8cb7	 8d 09 02	sta $0209		sta  cmdbuf+9
.8cba	 a9 e5		lda #$e5	fl00	lda  #$e5	; default block fill
.8cbc	 8d 0a 02	sta $020a		sta  cmdbuf+10
.8cbf	 20 de 8c	jsr $8cde	start8  jsr  go_fmt	; format side zero
.8cc2	 ad b0 01	lda $01b0		lda  mfmcmd	; error ?
.8cc5	 e0 02		cpx #$02		cpx  #2
.8cc7	 b0 12		bcs $8cdb		bcs  +
.8cc9	 a5 3b		lda $3b			lda  switch	; check for double sided opt
.8ccb	 29 20		and #$20		and  #%00100000
.8ccd	 f0 0c		beq $8cdb		beq  +
.8ccf	 a5 3b		lda $3b			lda  switch	; set single side
.8cd1	 09 10		ora #$10		ora  #%00010000
.8cd3	 85 3b		sta $3b			sta  switch
.8cd5	 20 54 89	jsr $8954		jsr  sel_sid	; select h/w
.8cd8	 20 de 8c	jsr $8cde		jsr  go_fmt	; format side one
.8cdb	 4c ef 89	jmp $89ef	+	jmp  cmdone	; restore
.8cde	 20 b3 89	jsr $89b3	go_fmt	jsr  diskin	; is there a diskette in the unit
.8ce1	 b0 7c		bcs $8d5f		bcs  c_801	; br, nope...
.8ce3	 a9 01		lda #$01		lda  #1
.8ce5	 8d 0d 18	sta $180d		sta  ifr1	; clear irq from write protect
.8ce8	 20 ef 89	jsr $89ef		jsr  cmdone     ; restore to track one/zero ?
.8ceb	 ad 08 02	lda $0208		lda  cmdbuf+8   ; store logical
.8cee	 8d b0 01	sta $01b0		sta  mfmcmd	; in mfmcmd
.8cf1	 8d 01 20	sta $2001		sta  wdtrk
.8cf4	 2c 03 02	bit $0203		bit  cmdbuf+3	; check table bit
.8cf7	 70 05		bvs $8cfe		bvs  +		; br, table has been given to us
.8cf9	 20 88 88	jsr $8888		jsr  sectcv	; generate sector table
.8cfc	 b0 61		bcs $8d5f		bcs  c_801
.8cfe	 ad 09 02	lda $0209	+	lda  cmdbuf+9	; offset track 00 by s steps
.8d01	 29 7f		and #$7f		and  #$7f	; clear mode bit
.8d03	 f0 08		beq $8d0d		beq  c_800
.8d05	 18		clc			clc
.8d06	 65 67		adc $67			adc  cmd_trk	; add to it
.8d08	 85 67		sta $67			sta  cmd_trk	; physical
.8d0a	 20 ba 87	jsr $87ba		jsr  seke	; & seek to it
.8d0d	 78		sei		c_800	sei
.8d0e	 ad 0d 18	lda $180d		lda  ifr1	; check for disk change
.8d11	 4a		lsr a			lsr  a
.8d12	 b0 4b		bcs $8d5f		bcs  c_801
.8d14	 20 86 8a	jsr $8a86		jsr  cmdsev     ; format track
.8d17	 b0 46		bcs $8d5f	        bcs  c_801
.8d19	 ad 0d 18	lda $180d		lda  ifr1	; check for disk change
.8d1c	 4a		lsr a			lsr  a
.8d1d	 b0 40		bcs $8d5f		bcs  c_801
.8d1f	 20 f0 88	jsr $88f0		jsr  verfmt	; verify format
.8d22	 b0 3b		bcs $8d5f	        bcs  c_801
.8d24	 ad 0d 18	lda $180d		lda  ifr1	; check for disk change
.8d27	 4a		lsr a			lsr  a
.8d28	 b0 35		bcs $8d5f		bcs  c_801
.8d2a	 ad b0 01	lda $01b0	        lda  mfmcmd	; last track ?
.8d2d	 cd 06 02	cmp $0206	        cmp  cmdbuf+6   ; lt
.8d30	 f0 0e		beq $8d40	        beq  c_802
.8d32	 e6 67		inc $67		        inc  cmd_trk
.8d34	 ee 01 20	inc $2001		inc  wdtrk
.8d37	 ee b0 01	inc $01b0		inc  mfmcmd	; track to write
.8d3a	 20 ba 87	jsr $87ba	        jsr  seke       ; goto next track
.8d3d	 4c 0d 8d	jmp $8d0d	        jmp  c_800
.8d40	 24 3b		bit $3b		c_802   bit  switch
.8d42	 10 18		bpl $8d5c		bpl c_803	; kill next
.8d44	 38		sec			sec
.8d45	 ad 06 02	lda $0206		lda  cmdbuf+6	; lt
.8d48	 ed 08 02	sbc $0208		sbc  cmdbuf+8	; st
.8d4b	 c9 27		cmp #$27		cmp  #39	; no more than 40 tracks
.8d4d	 b0 0d		bcs $8d5c		bcs  c_803
.8d4f	 e6 67		inc $67			inc  cmd_trk	; clear next track
.8d51	 20 ba 87	jsr $87ba		jsr  seke
.8d54	 a2 1c		ldx #$1c		ldx  #28
.8d56	 20 7f c0	jsr $c07f		jsr  ptch0d	; *** rom ds 01-13-87 ***,no SO
.8d59	 ea		nop			nop
.8d5a	 ea		nop			nop
.8d5b	 ea		nop			nop		; fill
.8d5c	 a2 00		ldx #$00	c_803	ldx  #0

>8d5e	 2c                       		.byte  skip2

.8d5f	 a2 06		ldx #$06	c_801   ldx  #6
.8d61	 8e b0 01	stx $01b0		stx  mfmcmd	; ok exit
.8d64	 4c e9 85	jmp $85e9		jmp  upinst

;******  Return to file "serlib.asm"

						.include "mfmsubr2.asm"

;******  Processing file "mfmsubr2.asm"

.8d67	 a5 3b		lda $3b		cmdnin  lda  switch
.8d69	 29 20		and #$20		and  #%00100000
.8d6b	 d0 59		bne $8dc6		bne  c_904
.8d6d	 a9 03		lda #$03		lda  #3
.8d6f	 85 31		sta $31			sta  bufpnt+1	; buffer #1
.8d71	 a0 00		ldy #$00		ldy  #0         ; even page
.8d73	 84 30		sty $30			sty  bufpnt
.8d75	 a6 44		ldx $44			ldx  mfmsiz_hi	; get sector size
.8d77	 ad 03 02	lda $0203	        lda  cmdbuf+3   ; get track address
.8d7a	 8d 01 20	sta $2001	        sta  wdtrk      ; give track to wd
.8d7d	 ad 04 02	lda $0204	        lda  cmdbuf+4   ; get sector address
.8d80	 8d 02 20	sta $2002	        sta  wdsec      ; give sector to wd
.8d83	 a9 88		lda #$88		lda  #$88       ; read sector command
.8d85	 20 4e 88	jsr $884e		jsr  strtwd	; send cmd
.8d88	 ea		nop			nop		; fill address error
.8d89	 ad 00 20	lda $2000	c_900	lda  wdstat	; get a byte
.8d8c	 29 03		and #$03		and  #3
.8d8e	 4a		lsr a			lsr  a
.8d8f	 90 1a		bcc $8dab		bcc  c_902
.8d91	 29 01		and #$01		and  #1
.8d93	 f0 f4		beq $8d89		beq  c_900
.8d95	 ad 03 20	lda $2003	        lda  wddat      ; get a byte from wd
.8d98	 91 30		sta ($30),y	        sta  (bufpnt),y ; put it in the buffer
.8d9a	 cc 71 02	cpy $0271	        cpy  mfmsiz_lo	; done buffer
.8d9d	 f0 03		beq $8da2	        beq  c_901	; next
.8d9f	 c8		iny		        iny
.8da0	 d0 e7		bne $8d89	        bne  c_900
.8da2	 c8		iny		c_901	iny		; y=0
.8da3	 ca		dex			dex
.8da4	 f0 05		beq $8dab	        beq  c_902
.8da6	 e6 31		inc $31		        inc  bufpnt+1   ; next buffer
.8da8	 4c 89 8d	jmp $8d89	        jmp  c_900
.8dab	 20 61 88	jsr $8861	c_902	jsr  waitdn	; wait for unbusy
.8dae	 20 3c 88	jsr $883c		jsr  cvstat	; convert
.8db1	 20 e9 85	jsr $85e9		jsr  upinst     ; update controller status
.8db4	 24 3b		bit $3b		        bit  switch
.8db6	 70 07		bvs $8dbf		bvs  c_905	; ignore error ?
.8db8	 e0 02		cpx #$02		cpx  #2
.8dba	 90 03		bcc $8dbf		bcc  c_905
.8dbc	 4c 84 83	jmp $8384		jmp  finbad	; send it
.8dbf	 20 f9 85	jsr $85f9	c_905	jsr  hskrd	; send status
.8dc2	 a5 3b		lda $3b			lda  switch
.8dc4	 30 22		bmi $8de8		bmi  c_906	; buffer transfer ?
.8dc6	 a9 03		lda #$03	c_904	lda  #3
.8dc8	 85 31		sta $31			sta  bufpnt+1	; buffer #1
.8dca	 a0 00		ldy #$00		ldy  #0         ; even page
.8dcc	 84 30		sty $30			sty  bufpnt
.8dce	 a6 44		ldx $44			ldx  mfmsiz_hi	; get sector size
.8dd0	 b1 30		lda ($30),y	c_907	lda  (bufpnt),y ; get data from buffer
.8dd2	 85 46		sta $46			sta  ctl_dat
.8dd4	 20 f9 85	jsr $85f9		jsr  hskrd	; handshake data to host
.8dd7	 cc 71 02	cpy $0271	        cpy  mfmsiz_lo	; done buffer ?
.8dda	 f0 03		beq $8ddf	        beq  c_908	; next
.8ddc	 c8		iny		        iny
.8ddd	 d0 f1		bne $8dd0	        bne  c_907
.8ddf	 c8		iny		c_908	iny		; y=0
.8de0	 ca		dex			dex
.8de1	 f0 05		beq $8de8	        beq  c_906
.8de3	 e6 31		inc $31		        inc  bufpnt+1   ; next buffer
.8de5	 4c d0 8d	jmp $8dd0	        jmp  c_907
.8de8	 ce 05 02	dec $0205	c_906	dec  cmdbuf+5	; any more sectors ?
.8deb	 f0 06		beq $8df3		beq  cmd9ex
.8ded	 20 6c 88	jsr $886c		jsr  sectnx     ; next sector rap ?
.8df0	 4c 67 8d	jmp $8d67		jmp  cmdnin	; continue...
.8df3	 4c 1b 89	jmp $891b	cmd9ex  jmp  chcsee     ; next track
.8df6	 a9 03		lda #$03	cmdten  lda  #3
.8df8	 85 31		sta $31			sta  bufpnt+1	; buffer #1
.8dfa	 a0 00		ldy #$00		ldy  #0
.8dfc	 84 30		sty $30			sty  bufpnt
.8dfe	 a6 44		ldx $44			ldx  mfmsiz_hi	; get high byte
.8e00	 a5 3b		lda $3b			lda  switch
.8e02	 30 30		bmi $8e34		bmi  c_100	; buffer transfer ?
.8e04	 ad 00 18	lda $1800	c_101	lda  pb		; debounce
.8e07	 49 08		eor #$08		eor  #clkout	; toggle clock
.8e09	 2c 0d 40	bit $400d		bit  icr	; clear pending
.8e0c	 8d 00 18	sta $1800		sta  pb		; doit
.8e0f	 ad 00 18	lda $1800	c_103	lda  pb
.8e12	 10 03		bpl $8e17		bpl  c_102	; atn ?
.8e14	 20 59 ea	jsr $ea59		jsr  tstatn	; service if appropiate
.8e17	 ad 0d 40	lda $400d	c_102	lda  icr
.8e1a	 29 08		and #$08		and  #8
.8e1c	 f0 f1		beq $8e0f		beq  c_103	; wait for byte ready
.8e1e	 ad 0c 40	lda $400c		lda  sdr	; get data
.8e21	 91 30		sta ($30),y		sta  (bufpnt),y
.8e23	 cc 71 02	cpy $0271		cpy  mfmsiz_lo
.8e26	 f0 03		beq $8e2b		beq  c_104
.8e28	 c8		iny			iny
.8e29	 d0 d9		bne $8e04		bne  c_101
.8e2b	 c8		iny		c_104	iny		; y=0
.8e2c	 ca		dex			dex
.8e2d	 f0 05		beq $8e34		beq  c_100
.8e2f	 e6 31		inc $31			inc  bufpnt+1   ; next buffer
.8e31	 4c 04 8e	jmp $8e04		jmp  c_101
.8e34	 a5 3b		lda $3b		c_100	lda  switch
.8e36	 29 20		and #$20		and  #%00100000
.8e38	 d0 7d		bne $8eb7		bne  c_105	; buffer op
.8e3a	 a5 3b		lda $3b			lda  switch
.8e3c	 29 08		and #$08		and  #%00001000 ; check internal switch
.8e3e	 f0 05		beq $8e45		beq  c_112
.8e40	 a6 46		ldx $46			ldx  ctl_dat
.8e42	 4c 81 83	jmp $8381		jmp  fail
.8e45	 a9 03		lda #$03	c_112	lda  #3         ; write now
.8e47	 85 31		sta $31			sta  bufpnt+1	; buffer #1
.8e49	 a0 00		ldy #$00		ldy  #0
.8e4b	 84 30		sty $30			sty  bufpnt
.8e4d	 a6 44		ldx $44			ldx  mfmsiz_hi
.8e4f	 ad 03 02	lda $0203		lda  cmdbuf+3	; get track
.8e52	 8d 01 20	sta $2001		sta  wdtrk
.8e55	 ad 04 02	lda $0204		lda  cmdbuf+4
.8e58	 8d 02 20	sta $2002		sta  wdsec
.8e5b	 ad 0d 18	lda $180d		lda  ifr1	; check for diskette change
.8e5e	 4a		lsr a			lsr  a
.8e5f	 b0 32		bcs $8e93		bcs  c_110
.8e61	 a9 a8		lda #$a8		lda  #$a8	; normal dam
.8e63	 20 4e 88	jsr $884e		jsr  strtwd
.8e66	 ad 00 20	lda $2000	cmd10	lda  wdstat
.8e69	 29 03		and #$03		and  #3
.8e6b	 4a		lsr a			lsr  a
.8e6c	 90 25		bcc $8e93		bcc  c_110
.8e6e	 29 01		and #$01		and  #1
.8e70	 f0 f4		beq $8e66		beq  cmd10
.8e72	 b1 30		lda ($30),y		lda  (bufpnt),y
.8e74	 8d 03 20	sta $2003		sta  wddat	; send data to wd1770
.8e77	 cc 71 02	cpy $0271		cpy  mfmsiz_lo
.8e7a	 f0 03		beq $8e7f		beq  cmd100
.8e7c	 c8		iny			iny
.8e7d	 d0 e7		bne $8e66		bne  cmd10
.8e7f	 c8		iny		cmd100	iny		; y=0
.8e80	 ca		dex			dex
.8e81	 f0 05		beq $8e88		beq  c_108
.8e83	 e6 31		inc $31			inc  bufpnt+1	; next page...
.8e85	 4c 66 8e	jmp $8e66		jmp  cmd10
.8e88	 ad 0d 18	lda $180d	c_108   lda  ifr1	; check for diskette change
.8e8b	 4a		lsr a			lsr  a
.8e8c	 b0 05		bcs $8e93		bcs  c_110
.8e8e	 20 7c aa	jsr $aa7c		jsr  ptch60	; *** rom ds 01/21/86 ***, chk for verify
.8e91	 90 07		bcc $8e9a		bcc  c_109
.8e93	 20 ce 81	jsr $81ce	c_110	jsr  spout	; go output
.8e96	 a2 07		ldx #$07		ldx  #7
.8e98	 d0 06		bne $8ea0		bne  c_111	; bra
.8e9a	 20 ce 81	jsr $81ce	c_109	jsr  spout
.8e9d	 20 3c 88	jsr $883c		jsr  cvstat
.8ea0	 8e b0 01	stx $01b0	c_111	stx  mfmcmd	; save status
.8ea3	 20 e9 85	jsr $85e9		jsr  upinst
.8ea6	 20 f9 85	jsr $85f9		jsr  hskrd	; send it
.8ea9	 20 a0 86	jsr $86a0		jsr  burst	; wait for clk high
.8eac	 20 b2 81	jsr $81b2		jsr  spinp	; input
.8eaf	 24 3b		bit $3b			bit  switch	; abort on error ?
.8eb1	 70 04		bvs $8eb7		bvs  c_105
.8eb3	 e0 02		cpx #$02		cpx  #2		; error ?
.8eb5	 b0 0e		bcs $8ec5		bcs  c_107
.8eb7	 ce 05 02	dec $0205	c_105	dec  cmdbuf+5	; more sectors
.8eba	 f0 06		beq $8ec2		beq  c_106
.8ebc	 20 6c 88	jsr $886c		jsr  sectnx	; next sector
.8ebf	 4c f6 8d	jmp $8df6		jmp  cmdten
.8ec2	 4c 1b 89	jmp $891b	c_106	jmp  chcsee
.8ec5	 60		rts		c_107	rts

;******  Return to file "serlib.asm"

						.include "mfmsubr3.asm"

;******  Processing file "mfmsubr3.asm"

.8ec6	 a9 03		lda #$03	cmdele  lda  #3
.8ec8	 85 31		sta $31			sta  bufpnt+1	; buffer #0
.8eca	 a0 00		ldy #$00		ldy  #0         ; even page
.8ecc	 84 30		sty $30			sty  bufpnt
.8ece	 a6 44		ldx $44		        ldx  mfmsiz_hi	; get sector high
.8ed0	 ad 03 02	lda $0203	        lda  cmdbuf+3   ; get track address
.8ed3	 8d 01 20	sta $2001	        sta  wdtrk      ; give track to wd
.8ed6	 ad 04 02	lda $0204	        lda  cmdbuf+4   ; get sector address
.8ed9	 8d 02 20	sta $2002	        sta  wdsec      ; give sector to wd
.8edc	 a9 88		lda #$88	cmd_11	lda  #$88       ; read sector command
.8ede	 20 4e 88	jsr $884e		jsr  strtwd	; send cmd
.8ee1	 ad 00 20	lda $2000	c_1100	lda  wdstat     ; get a byte
.8ee4	 29 03		and #$03		and  #3
.8ee6	 4a		lsr a			lsr  a
.8ee7	 90 1c		bcc $8f05		bcc  c_1101
.8ee9	 29 01		and #$01		and  #1
.8eeb	 f0 f4		beq $8ee1		beq  c_1100	; byte ready
.8eed	 ad 03 20	lda $2003	        lda  wddat      ; get a byte from wd
.8ef0	 d1 30		cmp ($30),y	        cmp  (bufpnt),y ; put it in the buffer
.8ef2	 d0 11		bne $8f05	        bne  c_1101	; flag error
.8ef4	 cc 71 02	cpy $0271		cpy  mfmsiz_lo	; done buffer
.8ef7	 f0 03		beq $8efc	        beq  c_1102	; next
.8ef9	 c8		iny		        iny
.8efa	 d0 e5		bne $8ee1	        bne  c_1100
.8efc	 c8		iny		c_1102  iny		; y=0
.8efd	 ca		dex			dex
.8efe	 f0 10		beq $8f10	c_1103	beq  c_1104
.8f00	 e6 31		inc $31		        inc  bufpnt+1   ; next buffer
.8f02	 4c e1 8e	jmp $8ee1	        jmp  c_1100
.8f05	 a9 d0		lda #$d0	c_1101	lda  #$d0	; abort wd1770
.8f07	 8d 00 20	sta $2000		sta  wdstat	; send cmd
.8f0a	 20 83 a4	jsr $a483		jsr  jslowd	; wait 40 uS.
.8f0d	 a2 07		ldx #$07		ldx  #7

>8f0f	 2c                       		.byte skip2

.8f10	 a2 00		ldx #$00	c_1104  ldx  #0
.8f12	 8e b0 01	stx $01b0		stx  mfmcmd
.8f15	 4c 61 88	jmp $8861		jmp  waitdn	; wait for the wd1770 to sleep
.8f18	 a9 03		lda #$03	cmdtwv  lda  #3
.8f1a	 85 31		sta $31			sta  bufpnt+1	; buffer #1
.8f1c	 a0 00		ldy #$00		ldy  #0         ; even page
.8f1e	 84 30		sty $30			sty  bufpnt
.8f20	 a6 44		ldx $44		        ldx  mfmsiz_hi	; get sector high
.8f22	 a9 88		lda #$88	cmd_12	lda  #$88       ; read sector command
.8f24	 20 4e 88	jsr $884e		jsr  strtwd	; send cmd
.8f27	 ad 00 20	lda $2000	c_1200	lda  wdstat     ; get a byte
.8f2a	 29 03		and #$03		and  #3
.8f2c	 4a		lsr a			lsr  a
.8f2d	 90 1d		bcc $8f4c		bcc  c_1201
.8f2f	 29 01		and #$01		and  #1
.8f31	 f0 f4		beq $8f27		beq  c_1200	; byte ready
.8f33	 ad 03 20	lda $2003	        lda  wddat      ; get a byte from wd
.8f36	 cd 0a 02	cmp $020a		cmp  cmdbuf+10  ; same as fill byte ?
.8f39	 d0 11		bne $8f4c		bne  c_1201	; br, on error
.8f3b	 cc 71 02	cpy $0271		cpy  mfmsiz_lo	; get lo sector size
.8f3e	 f0 03		beq $8f43		beq  c_1202
.8f40	 c8		iny			iny
.8f41	 d0 e4		bne $8f27		bne  c_1200	; done ?
.8f43	 c8		iny		c_1202	iny
.8f44	 ca		dex			dex
.8f45	 f0 10		beq $8f57	c_1203	beq  c_1204
.8f47	 e6 31		inc $31		        inc  bufpnt+1   ; next buffer
.8f49	 4c 27 8f	jmp $8f27	        jmp  c_1200
.8f4c	 a9 d0		lda #$d0	c_1201	lda  #$d0	; abort wd1770
.8f4e	 8d 00 20	sta $2000		sta  wdstat	; send cmd
.8f51	 20 83 a4	jsr $a483		jsr  jslowd	; wait 40 uS.
.8f54	 a2 07		ldx #$07		ldx  #7

>8f56	 2c                       		.byte skip2

.8f57	 a2 00		ldx #$00	c_1204  ldx  #0
.8f59	 8e b0 01	stx $01b0		stx  mfmcmd
.8f5c	 4c 61 88	jmp $8861		jmp  waitdn	; wait for the wd1770 to sleep
.8f5f	 08		php		cmdthi  php
.8f60	 78		sei			sei
.8f61	 20 ef 89	jsr $89ef		jsr  cmdone	; track zero start
.8f64	 24 3b		bit $3b			bit  switch	; seek to n-track ?
.8f66	 10 08		bpl $8f70		bpl  +
.8f68	 ad 03 02	lda $0203		lda  cmdbuf+3
.8f6b	 85 67		sta $67			sta  cmd_trk	; goto this track
.8f6d	 20 ba 87	jsr $87ba		jsr  seke
.8f70	 a9 00		lda #$00	+	lda  #0
.8f72	 85 97		sta $97			sta  cpmsek	; clear # of sectors
.8f74	 20 27 8a	jsr $8a27		jsr  cmdfiv	; read address
.8f77	 ae b0 01	ldx $01b0		ldx  mfmcmd	; check status
.8f7a	 e0 02		cpx #$02		cpx  #2
.8f7c	 b0 1f		bcs $8f9d		bcs  +
.8f7e	 a5 26		lda $26			lda  mfmhdr+2
.8f80	 85 96		sta $96			sta  cmd_sec	; this is where we stop
.8f82	 20 27 8a	jsr $8a27	-	jsr  cmdfiv	; read address
.8f85	 a5 26		lda $26			lda  mfmhdr+2	; get next sector
.8f87	 a4 97		ldy $97			ldy  cpmsek
.8f89	 99 0b 02	sta $020b,y		sta  cmdbuf+11,y
.8f8c	 e6 97		inc $97			inc  cpmsek	; inc sector count
.8f8e	 c0 1f		cpy #$1f		cpy  #31	; went too far ?
.8f90	 b0 0b		bcs $8f9d		bcs  +
.8f92	 c5 96		cmp $96			cmp  cmd_sec	; done yet ?
.8f94	 d0 ec		bne $8f82		bne  -		; wait for rap...
.8f96	 a5 24		lda $24			lda  mfmhdr	; get track
.8f98	 85 67		sta $67			sta  cmd_trk	; save for later
.8f9a	 a2 00		ldx #$00		ldx #0

>8f9c	 2c                       		.byte skip2

.8f9d	 a2 02		ldx #$02	+	ldx #2
.8f9f	 8e b0 01	stx $01b0		stx  mfmcmd
.8fa2	 28		plp			plp
.8fa3	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "utl.asm"

;******  Processing file "utl.asm"

.8fa4	 ad 04 02	lda $0204	cmdsec  lda  cmdbuf+4
.8fa7	 85 69		sta $69		        sta  secinc
.8fa9	 60		rts			rts
.8faa	 ad 04 02	lda $0204	cmdret  lda  cmdbuf+4
.8fad	 85 6a		sta $6a		        sta  revcnt
.8faf	 60		rts			rts
.8fb0	 4c 4e 92	jmp $924e	sign	jmp  signature	; finish up there
.8fb3					sside
.8fb3	 78		sei			sei
.8fb4	 ad 0f 18	lda $180f	        lda  pota1
.8fb7	 29 20		and #$20	        and  #$20     ;**TODO**
.8fb9	 d0 66		bne $9021	        bne  utlbad
.8fbb	 ad 04 02	lda $0204	        lda  cmdbuf+4
.8fbe	 c9 31		cmp #$31	        cmp  #'1'
.8fc0	 f0 12		beq $8fd4	        beq  fst
.8fc2	 c9 30		cmp #$30	        cmp  #'0'
.8fc4	 d0 5b		bne $9021	        bne  utlbad
.8fc6	 ad 0f 18	lda $180f	        lda  pota1
.8fc9	 29 fb		and #$fb	        and  #$fb     ;**TODO**
.8fcb	 8d 0f 18	sta $180f	        sta  pota1
.8fce	 58		cli		        cli
.8fcf	 24 3b		bit $3b		        bit  switch
.8fd1	 10 0e		bpl $8fe1	        bpl  ht
.8fd3	 60		rts		        rts
.8fd4	 ad 0f 18	lda $180f	fst     lda  pota1
.8fd7	 09 04		ora #$04	        ora  #4       ;**TODO**
.8fd9	 8d 0f 18	sta $180f	        sta  pota1
.8fdc	 58		cli		        cli
.8fdd	 24 3b		bit $3b		        bit  switch
.8fdf	 30 03		bmi $8fe4	        bmi  +
.8fe1	 4c 42 d0	jmp $d042	ht      jmp  initdr
.8fe4	 60		rts		+       rts
.8fe5	 ae 74 02	ldx $0274	chgutl  ldx  cmdsiz     ; chk cmd size
.8fe8	 e0 04		cpx #$04	        cpx  #4
.8fea	 90 35		bcc $9021		bcc  utlbad     ; br, error no parameters
.8fec	 ad 03 02	lda $0203		lda  cmdbuf+3
.8fef	 c9 53		cmp #$53	        cmp  #'S'       ; sector interleave ?
.8ff1	 f0 b1		beq $8fa4	        beq  cmdsec
.8ff3	 c9 52		cmp #$52	        cmp  #'R'       ; retry
.8ff5	 f0 b3		beq $8faa	        beq  cmdret
.8ff7	 c9 54		cmp #$54	        cmp  #'T'	; test ROM
.8ff9	 f0 b5		beq $8fb0	        beq  sign
.8ffb	 c9 4d		cmp #$4d	        cmp  #'M'	; mode
.8ffd	 f0 27		beq $9026	        beq  smode
.8fff	 c9 48		cmp #$48		cmp  #'H'
.9001	 f0 b0		beq $8fb3		beq  sside
.9003	 4c 86 aa	jmp $aa86		jmp  ptch61
.9006	 90 19		bcc $9021	rtch61	bcc  utlbad
.9008	 c0 1f		cpy #$1f		cpy  #31
.900a	 b0 15		bcs $9021		bcs  utlbad
.900c	 a9 40		lda #$40		lda  #$40	; change device #
.900e	 85 78		sta $78			sta  tlkadr	; clear old
.9010	 a9 20		lda #$20		lda  #$20
.9012	 85 77		sta $77			sta  lsnadr	; *
.9014	 98		tya			tya
.9015	 18		clc			clc
.9016	 65 78		adc $78			adc  tlkadr
.9018	 85 78		sta $78			sta  tlkadr	; new
.901a	 98		tya			tya
.901b	 18		clc			clc
.901c	 65 77		adc $77			adc  lsnadr
.901e	 85 77		sta $77			sta  lsnadr	; new
.9020	 60		rts			rts
.9021	 a9 31		lda #$31	utlbad  lda  #badcmd
.9023	 4c c8 c1	jmp $c1c8		jmp  cmderr
.9026	 78		sei		smode	sei
.9027	 ad 04 02	lda $0204		lda  cmdbuf+4
.902a	 c9 31		cmp #$31		cmp  #'1'
.902c	 f0 20		beq $904e	        beq  +
.902e	 c9 30		cmp #$30	        cmp  #'0'
.9030	 d0 ef		bne $9021	        bne  utlbad
.9032	 ad 0f 18	lda $180f	        lda  pota1
.9035	 29 df		and #$df	        and  #$df     ;**TODO**
.9037	 8d 0f 18	sta $180f	        sta  pota1
.903a	 20 83 a4	jsr $a483	        jsr  jslowd
.903d	 20 82 ff	jsr $ff82	        jsr  ptch10
.9040	 ad af 02	lda $02af	        lda  lock
.9043	 09 80		ora #$80	        ora  #$80
.9045	 8d af 02	sta $02af	        sta  lock
.9048	 58		cli		        cli
.9049	 24 3b		bit $3b		        bit  switch
.904b	 10 2f		bpl $907c	        bpl  chn
.904d	 60		rts		        rts
.904e	 ad 0f 18	lda $180f	+       lda  pota1
.9051	 09 20		ora #$20	        ora  #$20     ;**TODO**
.9053	 8d 0f 18	sta $180f	        sta  pota1
.9056	 20 83 a4	jsr $a483	        jsr  jslowd
.9059	 a9 de		lda #$de	        lda  #<jirq
.905b	 8d a9 02	sta $02a9	        sta  irqjmp
.905e	 a9 9d		lda #$9d	        lda  #>jirq
.9060	 8d aa 02	sta $02aa	        sta  irqjmp+1
.9063	 a9 40		lda #$40	        lda  #$40
.9065	 8d 07 1c	sta $1c07	        sta  t1hl2
.9068	 8d 05 1c	sta $1c05	        sta  t1hc2
.906b	 ad af 02	lda $02af	        lda  lock
.906e	 29 7f		and #$7f	        and  #$7f
.9070	 8d af 02	sta $02af	        sta  lock
.9073	 a9 00		lda #$00	        lda  #0
.9075	 85 62		sta $62		        sta  nxtst
.9077	 58		cli		        cli
.9078	 24 3b		bit $3b		        bit  switch
.907a	 30 03		bmi $907f	        bmi  +
.907c	 4c 42 d0	jmp $d042	chn     jmp  initdr
.907f	 60		rts		+       rts

;******  Return to file "serlib.asm"

						.include "fastld.asm"

;******  Processing file "fastld.asm"

.9080					fstload
.9080	 20 ce 81	jsr $81ce		jsr  spout	; output
.9083	 20 ea 91	jsr $91ea		jsr  set_fil	; setup filename for parser
.9086	 b0 5f		bcs $90e7		bcs  m9
.9088	 20 3d c6	jsr $c63d	        jsr  autoi	; init mechanism
.908b	 a5 ff		lda $ff			lda  nodrv	; chk status
.908d	 d0 58		bne $90e7		bne  m9		; no drive status
.908f	 a5 37		lda $37			lda  fastsr	; set error recovery flag on
.9091	 09 81		ora #$81		ora  #$81	; & eoi flag
.9093	 85 37		sta $37			sta  fastsr
.9095	 20 ca 91	jsr $91ca		jsr  findbuf	; check for buffer availabilty
.9098	 ad 00 02	lda $0200		lda  cmdbuf
.909b	 c9 2a		cmp #$2a		cmp  #'*'	; load last ?
.909d	 d0 0f		bne $90ae		bne  m7
.909f	 a5 7e		lda $7e			lda  prgtrk	; any file ?
.90a1	 f0 0b		beq $90ae		beq  m7
.90a3	 48		pha			pha		; save track
.90a4	 ad 6f 02	lda $026f		lda  prgsec
.90a7	 8d 85 02	sta $0285		sta  filsec	; update
.90aa	 68		pla			pla
.90ab	 4c ec 90	jmp $90ec		jmp  m1
.90ae	 a9 00		lda #$00	m7	lda  #0
.90b0	 a8		tay			tay
.90b1	 aa		tax			tax		; clear .a, .x, .y
.90b2	 8d 8e 02	sta $028e	        sta  lstdrv     ; init drive number
.90b5	 8d 7a 02	sta $027a		sta  filtbl	; set up for file name parser
.90b8	 20 12 c3	jsr $c312	        jsr  onedrv     ; select drive
.90bb	 ad 78 02	lda $0278		lda  f2cnt
.90be	 48		pha			pha
.90bf	 a9 01		lda #$01		lda  #1
.90c1	 8d 78 02	sta $0278		sta  f2cnt
.90c4	 a9 ff		lda #$ff		lda  #$ff
.90c6	 85 86		sta $86			sta  r0		; set flag
.90c8	 20 4f c4	jsr $c44f		jsr  lookup	; locate file
.90cb	 68		pla			pla
.90cc	 8d 78 02	sta $0278		sta  f2cnt	; restore var
.90cf	 a5 37		lda $37			lda  fastsr
.90d1	 29 7f		and #$7f		and  #$7f	; clr error recovery flag
.90d3	 85 37		sta $37			sta  fastsr
.90d5	 24 3b		bit $3b			bit  switch	; seq flag set ?
.90d7	 30 06		bmi $90df		bmi  m8
.90d9	 20 5b aa	jsr $aa5b		jsr  ptch56	; *** rom ds 07/15/85 ***
.90dc	 ea		nop			nop		; fill
.90dd	 d0 05		bne $90e4		bne  m6		; not prg
.90df	 ad 80 02	lda $0280	m8      lda  filtrk     ; check if found. err if not
.90e2	 d0 08		bne $90ec	        bne  m1		; br, file found
.90e4	 a2 02		ldx #$02	m6    	ldx  #%00000010	; file not found

>90e6	 2c                       		.byte skip2

.90e7	 a2 0f		ldx #$0f	m9	ldx  #%00001111	; no drive
.90e9	 4c ad 91	jmp $91ad	        jmp  sys_err
.90ec	 85 7e		sta $7e		m1      sta  prgtrk	; save for next
.90ee	 48		pha			pha		; save track
.90ef	 20 da 91	jsr $91da		jsr  set_buf	; setup buffer allocation
.90f2	 68		pla			pla		; get track
.90f3	 ae b0 02	ldx $02b0		ldx  channel	; get channel offset
.90f6	 95 06		sta $06,x		sta  hdrs,x	; setup track
.90f8	 ad 85 02	lda $0285	        lda  filsec     ; & sector
.90fb	 8d 6f 02	sta $026f		sta  prgsec	; for next time
.90fe	 95 07		sta $07,x	        sta  hdrs+1,x
.9100	 a9 80		lda #$80		lda  #read	; read job
.9102	 8d 02 02	sta $0202		sta  cmdbuf+2	; save read cmd
.9105	 85 5f		sta $5f			sta  ctl_cmd
.9107	 58		cli		m2	cli		; let controller run
.9108	 a6 f9		ldx $f9			ldx  jobnum	; get job #
.910a	 a5 5f		lda $5f			lda  ctl_cmd	; get cmd
.910c	 95 00		sta $00,x		sta  jobs,x	; send cmd
.910e	 20 4b 86	jsr $864b		jsr  stbctr	; whack the controller in the head
.9111	 e0 02		cpx #$02		cpx  #2		; error ?
.9113	 90 03		bcc $9118		bcc  m5
.9115	 4c 99 91	jmp $9199		jmp  ctr_err
.9118	 78		sei		m5	sei
.9119	 a0 00		ldy #$00		ldy  #0
.911b	 b1 94		lda ($94),y		lda  (dirbuf),y	; check status
.911d	 f0 2f		beq $914e		beq  end_of_file
.911f	 a5 37		lda $37			lda  fastsr	; clear flag
.9121	 29 fe		and #$fe		and  #$fe
.9123	 85 37		sta $37			sta  fastsr
.9125	 20 28 92	jsr $9228		jsr  handsk	; handshake error to the host
.9128	 a0 02		ldy #$02		ldy  #2
.912a	 b1 94		lda ($94),y	m3	lda  (dirbuf),y
.912c	 aa		tax			tax		; save data in .x
.912d	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.9130	 c8		iny			iny
.9131	 d0 f7		bne $912a		bne  m3
.9133	 ae b0 02	ldx $02b0		ldx  channel	; jobnum * 2
.9136	 b1 94		lda ($94),y		lda  (dirbuf),y ; .y = 0
.9138	 d5 06		cmp $06,x		cmp  hdrs,x	; same as previous track ?
.913a	 f0 03		beq $913f		beq  m4
.913c	 a0 80		ldy #$80		ldy  #read

>913e	 2c                       		.byte skip2

.913f	 a0 88		ldy #$88	m4	ldy  #fread	; fast read
.9141	 84 5f		sty $5f			sty  ctl_cmd	; command to seek then read
.9143	 95 06		sta $06,x		sta  hdrs,x	; next track
.9145	 a0 01		ldy #$01		ldy  #1		; sector entry
.9147	 b1 94		lda ($94),y		lda  (dirbuf),y
.9149	 95 07		sta $07,x		sta  hdrs+1,x	; next sector
.914b	 4c 07 91	jmp $9107		jmp  m2
.914e					end_of_file
.914e	 a2 1f		ldx #$1f		ldx  #$1f	; eof
.9150	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.9153	 a9 01		lda #$01		lda  #1
.9155	 24 37		bit $37			bit  fastsr	; first time through ?
.9157	 f0 1e		beq $9177		beq  m1	        ; br, nope
.9159	 a8		tay			tay		; .y = 1
.915a	 b1 94		lda ($94),y		lda  (dirbuf),y	; number of bytes
.915c	 38		sec			sec
.915d	 e9 03		sbc #$03		sbc  #3
.915f	 85 46		sta $46			sta  ctl_dat	; save it
.9161	 aa		tax			tax		; send it
.9162	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.9165	 c8		iny			iny		; next
.9166	 b1 94		lda ($94),y		lda  (dirbuf),y	; address low
.9168	 aa		tax			tax
.9169	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.916c	 c8		iny			iny
.916d	 b1 94		lda ($94),y		lda  (dirbuf),y	; address high
.916f	 aa		tax			tax
.9170	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.9173	 a0 04		ldy #$04		ldy  #4		; skip addresses
.9175	 d0 0d		bne $9184		bne  m3		; bra
.9177	 a0 01		ldy #$01	m1      ldy  #1
.9179	 b1 94		lda ($94),y		lda  (dirbuf),y	; number of bytes
.917b	 aa		tax			tax
.917c	 ca		dex			dex
.917d	 86 46		stx $46			stx  ctl_dat	; save here
.917f	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.9182	 a0 02		ldy #$02		ldy  #2		; start at data
.9184	 b1 94		lda ($94),y	m3	lda  (dirbuf),y
.9186	 aa		tax			tax
.9187	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.918a	 c8		iny			iny
.918b	 c6 46		dec $46			dec  ctl_dat	; use it as a temp
.918d	 d0 f5		bne $9184		bne  m3
.918f	 a9 00		lda #$00		lda  #0
.9191	 85 83		sta $83			sta  sa
.9193	 20 c0 da	jsr $dac0		jsr  close	; close channel	(faux)
.9196	 4c 94 c1	jmp $c194		jmp  endcmd
.9199	 78		sei		ctr_err sei		; no irq's
.919a	 86 46		stx $46			stx  ctl_dat	; save status here
.919c	 20 28 92	jsr $9228		jsr  handsk	; handshake it to the host
.919f	 a9 00		lda #$00		lda  #0
.91a1	 85 83		sta $83			sta  sa
.91a3	 20 c0 da	jsr $dac0		jsr  close	; close channel (faux)
.91a6	 a6 f9		ldx $f9			ldx  jobnum
.91a8	 a5 46		lda $46			lda  ctl_dat	; get error
.91aa	 4c 0a e6	jmp $e60a		jmp  error	; error out.....
.91ad	 78		sei		sys_err sei
.91ae	 86 46		stx $46			stx  ctl_dat	; save error
.91b0	 a2 02		ldx #$02		ldx  #2		; file not found
.91b2	 20 28 92	jsr $9228		jsr  handsk	; give it to him
.91b5	 a9 00		lda #$00		lda  #0
.91b7	 85 83		sta $83			sta  sa
.91b9	 20 c0 da	jsr $dac0		jsr  close	; close channel (faux)
.91bc	 a5 46		lda $46			lda  ctl_dat	; get error back
.91be	 c9 02		cmp #$02		cmp  #2
.91c0	 f0 03		beq $91c5		beq  +
.91c2	 a9 74		lda #$74		lda  #nodriv	; no active drive

>91c4	 2c                       		.byte skip2

.91c5	 a9 62		lda #$62	+	lda  #flntfd	; file not found
.91c7	 4c c8 c1	jmp $c1c8		jmp  cmderr	; never more...
.91ca	 a9 00		lda #$00	findbuf lda  #0
.91cc	 85 83		sta $83			sta  sa		; psydo-load
.91ce	 a9 01		lda #$01		lda  #1		; 1 buffer
.91d0	 20 e2 d1	jsr $d1e2		jsr  getrch	; find a read channel
.91d3	 aa		tax			tax
.91d4	 bd e0 fe	lda $fee0,x		lda  bufind,x	; get buffer
.91d7	 85 95		sta $95			sta  dirbuf+1	; set it up indirect
.91d9	 60		rts			rts
.91da	 a5 95		lda $95		set_buf lda  dirbuf+1	; index to determine job
.91dc	 38		sec			sec
.91dd	 e9 03		sbc #$03		sbc  #3
.91df	 85 f9		sta $f9			sta  jobnum	; save in jobnum
.91e1	 0a		asl a			asl  a
.91e2	 8d b0 02	sta $02b0		sta  channel	; save channel off
.91e5	 a9 00		lda #$00		lda  #0
.91e7	 85 94		sta $94			sta  dirbuf	; even page boundary
.91e9	 60		rts			rts
.91ea					set_fil
.91ea	 a0 03		ldy #$03		ldy  #3		; default .y
.91ec	 ad 74 02	lda $0274		lda  cmdsiz	; delete burst load command
.91ef	 38		sec			sec
.91f0	 e9 03		sbc #$03		sbc  #3
.91f2	 8d 74 02	sta $0274		sta  cmdsiz	; new command size
.91f5	 ad 04 02	lda $0204		lda  cmdbuf+4   ; drv # given ?
.91f8	 c9 3a		cmp #$3a		cmp  #':'
.91fa	 d0 0e		bne $920a		bne  +
.91fc	 ad 03 02	lda $0203		lda  cmdbuf+3
.91ff	 aa		tax			tax		; save
.9200	 29 30		and #$30		and  #'0'
.9202	 c9 30		cmp #$30		cmp  #'0'        ; 0:file ?
.9204	 d0 04		bne $920a		bne  +
.9206	 e0 31		cpx #$31		cpx  #'1'	; chk for error
.9208	 f0 1c		beq $9226		beq  m4
.920a	 ad 03 02	lda $0203	+	lda  cmdbuf+3   ; drv # given ?
.920d	 c9 3a		cmp #$3a		cmp  #':'
.920f	 d0 04		bne $9215		bne  +
.9211	 ce 74 02	dec $0274		dec  cmdsiz
.9214	 c8		iny			iny
.9215	 a2 00		ldx #$00	+	ldx  #0		; start at cmdbuf+0
.9217	 b9 00 02	lda $0200,y	-       lda  cmdbuf,y	; extract file-name
.921a	 9d 00 02	sta $0200,x		sta  cmdbuf,x
.921d	 c8		iny			iny
.921e	 e8		inx			inx
.921f	 ec 74 02	cpx $0274		cpx  cmdsiz	; done ?
.9222	 d0 f3		bne $9217		bne  -		; delete cmd from buffer
.9224	 18		clc			clc

>9225	 24                       		.byte skip1

.9226	 38		sec		m4	sec		; error
.9227	 60		rts			rts
.9228					handsk
.9228	 ad 00 18	lda $1800	-	lda  pb		; debounce
.922b	 cd 00 18	cmp $1800	        cmp  pb
.922e	 d0 f8		bne $9228	        bne  -
.9230	 29 ff		and #$ff		and  #$ff	; set/clr neg flag
.9232	 30 17		bmi $924b	        bmi  +		; br, attn low
.9234	 45 37		eor $37		        eor  fastsr     ; wait for state chg
.9236	 29 04		and #$04	        and  #4
.9238	 f0 ee		beq $9228	        beq  -
.923a	 8e 0c 40	stx $400c	        stx  sdr	; send it
.923d	 a5 37		lda $37		        lda  fastsr
.923f	 49 04		eor #$04	        eor  #4         ; change state of clk
.9241	 85 37		sta $37		        sta  fastsr
.9243	 a9 08		lda #$08	        lda  #8
.9245	 2c 0d 40	bit $400d	-	bit  icr	; wait transmission time
.9248	 f0 fb		beq $9245	        beq  -
.924a	 60		rts		        rts
.924b	 4c b3 a7	jmp $a7b3	+	jmp  ptch30	; bye-bye the host wants us

;******  Return to file "serlib.asm"

						.include "signature.asm"

;******  Processing file "signature.asm"

.924e					signature
.924e	 08		php			php
.924f	 78		sei			sei		; no irqs
.9250	 a2 00		ldx #$00		ldx  #0
.9252	 86 00		stx $00			stx  $00  	; sig_lo
.9254	 86 01		stx $01			stx  $01        ; sig_hi
.9256	 a9 03		lda #$03		lda  #3		; skip checksum & signature bytes
.9258	 85 75		sta $75			sta  ip		; even page
.925a	 a8		tay			tay
.925b	 a9 80		lda #$80		lda  #$80	; start at $8000
.925d	 85 76		sta $76			sta  ip+1	; high order
.925f	 b1 75		lda ($75),y	m2	lda  (ip),y	; get a byte
.9261	 85 02		sta $02			sta  $02
.9263	 a2 08		ldx #$08		ldx  #8		; 8 bits in a byte right?
.9265	 a5 02		lda $02		m3	lda  $02
.9267	 29 01		and #$01		and  #1		; bit 0
.9269	 85 03		sta $03			sta  $03
.926b	 a5 01		lda $01			lda  $01  	; get sig_hi
.926d	 10 02		bpl $9271		bpl  +		; test bit 15
.926f	 e6 03		inc $03			inc  $03
.9271	 6a		ror a		+	ror  a
.9272	 90 02		bcc $9276		bcc  +		; test bit 8
.9274	 e6 03		inc $03			inc  $03
.9276	 6a		ror a		+       ror  a
.9277	 6a		ror a			ror  a
.9278	 6a		ror a			ror  a
.9279	 90 02		bcc $927d		bcc  +
.927b	 e6 03		inc $03			inc  $03
.927d	 a5 00		lda $00		+	lda  $00  	; sig_lo
.927f	 2a		rol a			rol  a
.9280	 2a		rol a			rol  a
.9281	 90 02		bcc $9285		bcc  +		; test bit 6
.9283	 e6 03		inc $03			inc  $03
.9285	 66 03		ror $03		+	ror  $03  	; sum into carry
.9287	 26 00		rol $00			rol  $00  	; carry into bit 0 low byte
.9289	 26 01		rol $01			rol  $01  	; carry into bit 0 high byte
.928b	 66 02		ror $02			ror  $02  	; ready for next bit
.928d	 ca		dex			dex
.928e	 d0 d5		bne $9265		bne  m3
.9290	 e6 75		inc $75			inc  ip
.9292	 d0 cb		bne $925f		bne  m2
.9294	 e6 76		inc $76			inc  ip+1	; next page
.9296	 d0 c7		bne $925f		bne  m2
.9298	 88		dey			dey
.9299	 88		dey			dey
.929a	 88		dey			dey		; .y = 0
.929b	 a5 00		lda $00			lda  $00
.929d	 cd 00 80	cmp $8000		cmp  signature_lo
.92a0	 d0 11		bne $92b3		bne  sig_err
.92a2	 a5 01		lda $01			lda  $01
.92a4	 cd 01 80	cmp $8001		cmp  signature_hi
.92a7	 d0 0a		bne $92b3		bne  sig_err
.92a9	 84 00		sty $00			sty  $00  	; clear
.92ab	 84 01		sty $01			sty  $01
.92ad	 84 02		sty $02			sty  $02
.92af	 84 03		sty $03			sty  $03
.92b1	 28		plp			plp
.92b2	 60		rts			rts
.92b3	 a2 03		ldx #$03	sig_err ldx  #3		; 4 blinks
.92b5	 86 6f		stx $6f			stx  temp
.92b7	 4c 71 ea	jmp $ea71		jmp  perr	; bye bye ....

;******  Return to file "serlib.asm"

						.include "lcccntrl1.asm"

;******  Processing file "lcccntrl1.asm"

.92ba					jlcc
.92ba	 ba		tsx		        tsx     	;  save current stack pointer
.92bb	 86 49		stx $49		        stx  savsp
.92bd	 2c 04 1c	bit $1c04	        bit  t1lc2      ; reset irq flag
.92c0	 ad 0c 1c	lda $1c0c	        lda  pcr2       ;  enable s.o. to 6502
.92c3	 09 0e		ora #$0e	        ora  #$0e       ;  hi output
.92c5	 8d 0c 1c	sta $1c0c	        sta  pcr2
.92c8	 a0 05		ldy #$05	jtop    ldy  #numjob-1  ;  pointer into job que
.92ca	 b9 00 00	lda $0000,y	-       lda  jobs,y     ;  find a job (msb set)
.92cd	 30 06		bmi $92d5	        bmi  +
.92cf	 88		dey		        dey
.92d0	 10 f8		bpl $92ca	        bpl  -
.92d2	 4c ca 99	jmp $99ca	        jmp  jend
.92d5					+
.92d5	 c9 88		cmp #$88	        cmp  #fread     ;  test if its a jump command
.92d7	 d0 03		bne $92dc	        bne  +
.92d9	 4c 0d 96	jmp $960d	        jmp  jread01
.92dc	 c9 d0		cmp #$d0	+       cmp  #jumpc     ;  test if its a jump command
.92de	 d0 03		bne $92e3	        bne  +
.92e0	 4c a2 93	jmp $93a2	        jmp  jex2
.92e3	 29 01		and #$01	+       and  #1         ;  get drive #
.92e5	 f0 07		beq $92ee	        beq  +
.92e7	 84 3f		sty $3f		        sty  jobn
.92e9	 a9 0f		lda #$0f	        lda  #$0f       ; bad drive # error
.92eb	 4c b5 99	jmp $99b5	        jmp  jerrr
.92ee	 aa		tax		+       tax
.92ef	 c5 3e		cmp $3e		        cmp  cdrive     ;  test if current drive
.92f1	 f0 08		beq $92fb	        beq  +
.92f3	 85 3e		sta $3e		        sta  cdrive
.92f5	 20 7e f9	jsr $f97e	        jsr  turnon     ;  turn on drive
.92f8	 4c ca 99	jmp $99ca	        jmp  jend       ;  go clean up
.92fb	 a5 20		lda $20		+       lda  drvst      ;  test if motor up to speed
.92fd	 30 03		bmi $9302	        bmi  +
.92ff	 0a		asl a		        asl  a          ;  test if stepping
.9300	 10 03		bpl $9305	        bpl  ++         ;  not stepping
.9302	 4c ca 99	jmp $99ca	+       jmp  jend
.9305	 a9 20		lda #$20	+       lda  #$20       ;  status=running
.9307	 85 20		sta $20		        sta  drvst
.9309	 a0 05		ldy #$05	        ldy  #numjob-1
.930b	 84 3f		sty $3f		        sty  jobn
.930d	 20 d1 93	jsr $93d1	-       jsr  jsetjb
.9310	 30 1a		bmi $932c	        bmi  jque20
.9312	 c6 3f		dec $3f		jque05  dec  jobn
.9314	 10 f7		bpl $930d	        bpl  -
.9316	 a4 41		ldy $41		        ldy  nxtjob
.9318	 20 d3 93	jsr $93d3	        jsr  jsetjb1
.931b	 a5 42		lda $42		        lda  nxtrk
.931d	 85 4a		sta $4a		        sta  steps
.931f	 06 4a		asl $4a		        asl  steps      ;  steps*2
.9321	 a9 60		lda #$60	        lda  #$60       ;  set status=stepping
.9323	 85 20		sta $20		        sta  drvst
.9325	 b1 32		lda ($32),y	        lda  (hdrpnt),y         ;  get dest track #
.9327	 85 22		sta $22		        sta  drvtrk
.9329	 4c ca 99	jmp $99ca	jfin    jmp  jend
.932c	 29 01		and #$01	jque20  and  #1         ;  test if same drive
.932e	 c5 3e		cmp $3e		        cmp  cdrive
.9330	 d0 e0		bne $9312	        bne  jque05
.9332	 a5 22		lda $22		        lda  drvtrk
.9334	 f0 32		beq $9368	        beq  jgotu       ;  uninit. track #
.9336	 a5 22		lda $22			lda  drvtrk
.9338	 c9 24		cmp #$24		cmp  #36
.933a	 08		php			php
.933b	 b1 32		lda ($32),y		lda  (hdrpnt),y
.933d	 c9 24		cmp #$24		cmp  #36
.933f	 6a		ror a			ror  a
.9340	 28		plp			plp
.9341	 29 80		and #$80		and  #$80
.9343	 90 0b		bcc $9350		bcc  +
.9345	 30 11		bmi $9358		bmi  jto
.9347	 a5 22		lda $22		        lda  drvtrk
.9349	 e9 23		sbc #$23	        sbc  #35
.934b	 85 22		sta $22		        sta  drvtrk
.934d	 4c 58 93	jmp $9358	        jmp  jto
.9350	 10 06		bpl $9358	+       bpl  jto
.9352	 a5 22		lda $22		        lda  drvtrk
.9354	 69 23		adc #$23	        adc  #35
.9356	 85 22		sta $22		        sta  drvtrk
.9358					jto
.9358	 38		sec		        sec     	;  calc distance to track
.9359	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.935b	 e5 22		sbc $22		        sbc  drvtrk
.935d	 f0 09		beq $9368	        beq  jgotu       ;  on track
.935f	 85 42		sta $42		        sta  nxtrk
.9361	 a5 3f		lda $3f		        lda  jobn       ;  save job# and dist to track
.9363	 85 41		sta $41		        sta  nxtjob
.9365	 4c 12 93	jmp $9312	        jmp  jque05
.9368	 a2 04		ldx #$04	jgotu   ldx  #4         ;  set track and sectr
.936a	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.936c	 85 40		sta $40		        sta  tracc
.936e	 c9 24		cmp #$24	        cmp  #36
.9370	 a8		tay		        tay
.9371	 20 f3 93	jsr $93f3	        jsr  set_side
.9374	 98		tya		        tya
.9375	 90 02		bcc $9379	        bcc  +
.9377	 e9 23		sbc #$23	        sbc  #35
.9379	 aa		tax		+	tax
.937a	 bd 4b c0	lda $c04b,x		lda  worktable-1,x
.937d	 85 43		sta $43		        sta  sectr
.937f	 ad 00 1c	lda $1c00	        lda  dskcnt
.9382	 29 9f		and #$9f	        and  #$9f       ;  clear density bits
.9384	 05 43		ora $43		        ora  sectr
.9386	 8d 00 1c	sta $1c00	        sta  dskcnt
.9389	 bd 2b 94	lda $942b,x	        lda  num_sec-1,x
.938c	 85 43		sta $43		        sta  sectr
.938e	 a5 45		lda $45		        lda  job        ;  yes, go do the job
.9390	 c9 40		cmp #$40	        cmp  #bumpc     ;  test for bump
.9392	 f0 1c		beq $93b0	        beq  jbmp
.9394	 c9 60		cmp #$60	        cmp  #execd
.9396	 f0 0a		beq $93a2	        beq  jex2
.9398	 c9 70		cmp #$70	        cmp  #frmtt
.939a	 f0 03		beq $939f	        beq  +
.939c	 4c 4f 94	jmp $944f	        jmp  jseak
.939f	 4c 29 9b	jmp $9b29	+       jmp  jformt
.93a2	 a5 3f		lda $3f		jex2    lda  jobn       ;  jump to buffer
.93a4	 18		clc		        clc
.93a5	 69 03		adc #$03	        adc  #>bufs
.93a7	 85 31		sta $31		        sta  bufpnt+1
.93a9	 a9 00		lda #$00	        lda  #0
.93ab	 85 30		sta $30		        sta  bufpnt
.93ad	 6c 30 00	jmp ($0030)	        jmp  (bufpnt)
.93b0					jbmp
.93b0	 a9 60		lda #$60	        lda  #$60       ;  set status=stepping
.93b2	 85 20		sta $20		        sta  drvst
.93b4	 ad 00 1c	lda $1c00	        lda  dskcnt
.93b7	 29 fc		and #$fc	        and  #$ff-$03   ;  set phase a
.93b9	 8d 00 1c	sta $1c00	        sta  dskcnt
.93bc	 a9 a4		lda #$a4	        lda  #256-92    ;  step back 45 traks
.93be	 85 4a		sta $4a		        sta  steps
.93c0	 ad b1 01	lda $01b1		lda  side
.93c3	 30 03		bmi $93c8		bmi  +
.93c5	 a9 01		lda #$01	        lda  #1         ;  drvtrk now 1

>93c7	 2c                       	        .byte skip2

.93c8	 a9 24		lda #$24	+       lda  #36
.93ca	 85 22		sta $22		        sta  drvtrk
.93cc	 a9 01		lda #$01		lda  #1
.93ce	 4c b5 99	jmp $99b5	        jmp  jerrr      ;  job done return 1
.93d1	 a4 3f		ldy $3f		jsetjb  ldy  jobn
.93d3	 b9 00 00	lda $0000,y	jsetjb1 lda  jobs,y
.93d6	 48		pha		        pha
.93d7	 10 14		bpl $93ed	        bpl  +         ;  no job here
.93d9	 29 78		and #$78	        and  #$78
.93db	 85 45		sta $45		        sta  job
.93dd	 98		tya		        tya
.93de	 0a		asl a		        asl  a
.93df	 69 06		adc #$06	        adc  #<hdrs
.93e1	 85 32		sta $32		        sta  hdrpnt
.93e3	 a9 00		lda #$00	        lda  #>hdrs
.93e5	 85 33		sta $33		        sta  hdrpnt+1
.93e7	 98		tya		        tya     	;  point at buffer
.93e8	 18		clc		        clc
.93e9	 69 03		adc #$03	        adc  #>bufs
.93eb	 85 31		sta $31		        sta  bufpnt+1
.93ed	 a0 00		ldy #$00	+       ldy  #0
.93ef	 84 30		sty $30		        sty  bufpnt
.93f1	 68		pla		        pla
.93f2	 60		rts		        rts
.93f3					set_side
.93f3	 b0 03		bcs $93f8		bcs  +
.93f5	 a9 00		lda #$00		lda  #0

>93f7	 2c                       		.byte skip2

.93f8	 a9 84		lda #$84	+	lda  #$84
.93fa	 8d b1 01	sta $01b1	        sta  side
.93fd	 ad 0f 18	lda $180f	        lda  pota1
.9400	 29 fb		and #$fb	        and  #$ff-$04
.9402	 0d b1 01	ora $01b1	        ora  side
.9405	 8d 0f 18	sta $180f	        sta  pota1
.9408	 60		rts		        rts

>9409	 60 60 60 60 60 60 60 60 	        .byte $60, $60, $60, $60, $60, $60, $60, $60, $60
>9411	 60 
>9412	 60 60 60 60 60 60 60 60  	        .byte $60, $60, $60, $60, $60, $60, $60, $60
>941a	 40 40 40 40 40 40 40     	        .byte $40, $40, $40, $40, $40, $40, $40
>9421	 20 20 20 20 20 20        	        .byte $20, $20, $20, $20, $20, $20
>9427	 00 00 00 00 00           	        .byte $00, $00, $00, $00, $00
>942c	 15 15 15 15 15 15 15 15 	num_sec	.byte $15, $15, $15, $15, $15, $15, $15, $15, $15
>9434	 15 
>9435	 15 15 15 15 15 15 15 15  		.byte $15, $15, $15, $15, $15, $15, $15, $15
>943d	 13 13 13 13 13 13 13     		.byte $13, $13, $13, $13, $13, $13, $13
>9444	 12 12 12 12 12 12        		.byte $12, $12, $12, $12, $12, $12
>944a	 11 11 11 11 11           		.byte $11, $11, $11, $11, $11

;******  Return to file "serlib.asm"

						.include "lccseek1.asm"

;******  Processing file "lccseek1.asm"


.944f					jseak
.944f	 a9 5a		lda #$5a		lda  #90        ; search 90 headers
.9451	 85 4b		sta $4b		        sta  tmp
.9453	 20 54 97	jsr $9754	m1	jsr  jsync      ; find sync char
.9456	 2c 0f 18	bit $180f	m2	bit  pota1	; wait for block id
.9459	 30 fb		bmi $9456		bmi  m2
.945b	 ad 01 1c	lda $1c01	        lda  data2      ; clear pa1 in the gate array
.945e	 c9 52		cmp #$52	        cmp  #$52       ; test if header block
.9460	 d0 3e		bne $94a0	        bne  m3		; not header
.9462	 99 24 00	sta $0024,y	        sta  stab,y   	; store 1st byte
.9465	 c8		iny		        iny
.9466	 2c 0f 18	bit $180f	m4	bit  pota1
.9469	 30 fb		bmi $9466		bmi  m4
.946b	 ad 01 1c	lda $1c01	        lda  data2
.946e	 99 24 00	sta $0024,y	        sta  stab,y     ; store gcr header off
.9471	 c8		iny		        iny
.9472	 c0 08		cpy #$08	        cpy  #8         ; 8 gcr bytes in header
.9474	 d0 f0		bne $9466	        bne  m4
.9476	 20 2f 95	jsr $952f	        jsr  jcnvbin    ; convert header in stabof to binary in header
.9479	 a0 04		ldy #$04	        ldy  #4         ; compute checksum
.947b	 a9 00		lda #$00	        lda  #0
.947d	 59 16 00	eor $0016,y	m5	eor  header,y
.9480	 88		dey		        dey
.9481	 10 fa		bpl $947d	        bpl  m5
.9483	 c9 00		cmp #$00	        cmp  #0         ; test if ok
.9485	 d0 30		bne $94b7	        bne  m9		; nope, checksum error in header
.9487	 a5 18		lda $18		        lda  header+2
.9489	 85 22		sta $22		        sta  drvtrk
.948b	 a5 45		lda $45		        lda  job        ; test if a seek job
.948d	 c9 30		cmp #$30	        cmp  #$30
.948f	 f0 18		beq $94a9	        beq  m6
.9491	 a5 12		lda $12		        lda  dskid
.9493	 c5 16		cmp $16		        cmp  header
.9495	 d0 1d		bne $94b4	        bne  m8
.9497	 a5 13		lda $13		        lda  dskid+1
.9499	 c5 17		cmp $17		        cmp  header+1
.949b	 d0 17		bne $94b4	        bne  m8
.949d	 4c bc 94	jmp $94bc		jmp  m7		; find best sector to service
.94a0	 c6 4b		dec $4b		m3	dec  tmp        ; search more?
.94a2	 d0 af		bne $9453	        bne  m1		; yes
.94a4	 a9 02		lda #$02	        lda  #2         ; cant find a sector
.94a6	 20 b5 99	jsr $99b5	        jsr  jerrr
.94a9	 a5 16		lda $16		m6	lda  header     ; sta disk id's
.94ab	 85 12		sta $12		        sta  dskid      ; *
.94ad	 a5 17		lda $17		        lda  header+1
.94af	 85 13		sta $13		        sta  dskid+1
.94b1	 a9 01		lda #$01		lda  #1         ; return ok code

>94b3	 2c                       	        .byte    skip2

.94b4	 a9 0b		lda #$0b	m8	lda  #11        ; disk id mismatch

>94b6	 2c                       	        .byte    skip2

.94b7	 a9 09		lda #$09	m9	lda  #9         ; checksum error in header
.94b9	 4c b5 99	jmp $99b5	        jmp  jerrr
.94bc	 a9 7f		lda #$7f	m7	lda  #$7f       ; find best job
.94be	 85 4c		sta $4c		        sta  csect
.94c0	 a5 19		lda $19		        lda  header+3   ; get upcoming sector #
.94c2	 18		clc		        clc
.94c3	 69 02		adc #$02	        adc  #2
.94c5	 c5 43		cmp $43		        cmp  sectr
.94c7	 90 02		bcc $94cb	        bcc  m10
.94c9	 e5 43		sbc $43		        sbc  sectr      ; wrap around
.94cb	 85 4d		sta $4d		m10	sta  nexts      ; next sector
.94cd	 a2 05		ldx #$05	        ldx  #numjob-1
.94cf	 86 3f		stx $3f		        stx  jobn
.94d1	 a2 ff		ldx #$ff	        ldx  #$ff
.94d3	 20 d1 93	jsr $93d1	m12	jsr  jsetjb
.94d6	 10 43		bpl $951b	        bpl  m11
.94d8	 29 01		and #$01	        and  #drvmsk
.94da	 c5 3e		cmp $3e		        cmp  cdrive     ; test if same drive
.94dc	 d0 3d		bne $951b	        bne  m11	; nope
.94de	 a0 00		ldy #$00	        ldy  #0         ; test if same track
.94e0	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.94e2	 c5 40		cmp $40		        cmp  tracc
.94e4	 d0 35		bne $951b	        bne  m11
.94e6	 a5 45		lda $45			lda  job
.94e8	 c9 60		cmp #$60		cmp  #execd
.94ea	 f0 0c		beq $94f8		beq  m13
.94ec	 a0 01		ldy #$01	        ldy  #1
.94ee	 38		sec		        sec
.94ef	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.94f1	 e5 4d		sbc $4d		        sbc  nexts
.94f3	 10 03		bpl $94f8	        bpl  m13
.94f5	 18		clc		        clc
.94f6	 65 43		adc $43		        adc  sectr
.94f8	 c5 4c		cmp $4c		m13	cmp  csect
.94fa	 b0 1f		bcs $951b	        bcs  m11
.94fc	 48		pha		        pha     	; save it
.94fd	 a5 45		lda $45		        lda  job
.94ff	 f0 15		beq $9516	        beq  m16	; must be a read
.9501	 68		pla		        pla
.9502	 c9 04		cmp #$04	        cmp  #wrtmin    ; +if(csect<4)return;
.9504	 90 15		bcc $951b	        bcc  m11	; +if(csect>8)return;
.9506	 c9 08		cmp #$08	        cmp  #wrtmax
.9508	 b0 11		bcs $951b	        bcs  m11
.950a	 85 4c		sta $4c		m15	sta  csect      ; its better
.950c	 a5 3f		lda $3f		        lda  jobn
.950e	 aa		tax		        tax
.950f	 18		clc		        clc
.9510	 69 03		adc #$03	        adc  #>bufs
.9512	 85 31		sta $31		        sta  bufpnt+1
.9514	 d0 05		bne $951b	        bne  m11
.9516	 68		pla		m16	pla
.9517	 c9 06		cmp #$06	        cmp  #rdmax     ; if(csect>6)return;
.9519	 90 ef		bcc $950a	        bcc  m15
.951b	 c6 3f		dec $3f		m11	dec  jobn
.951d	 10 b4		bpl $94d3	        bpl  m12
.951f	 8a		txa		        txa     	; test if a job to do
.9520	 10 03		bpl $9525	        bpl  m14
.9522	 4c ca 99	jmp $99ca	        jmp  jend       ; no job found
.9525	 86 3f		stx $3f		m14	stx  jobn
.9527	 20 d1 93	jsr $93d1	        jsr  jsetjb
.952a	 a5 45		lda $45		        lda  job
.952c	 4c 06 96	jmp $9606	        jmp  jread
.952f	 a5 30		lda $30		jcnvbin lda  bufpnt
.9531	 48		pha		        pha
.9532	 a5 31		lda $31		        lda  bufpnt+1
.9534	 48		pha		        pha     	; save buffer pntr
.9535	 a9 24		lda #$24	        lda  #<stab	; stab offset
.9537	 85 30		sta $30		        sta  bufpnt     ; point at gcr code
.9539	 a9 00		lda #$00	        lda  #>stab
.953b	 85 31		sta $31		        sta  bufpnt+1
.953d	 a9 00		lda #$00	        lda  #0
.953f	 85 34		sta $34		        sta  gcrpnt
.9541	 20 d9 98	jsr $98d9	        jsr  jget4gb    ; convert 4 bytes
.9544	 a5 55		lda $55		        lda  btab+3
.9546	 85 18		sta $18		        sta  header+2
.9548	 a5 54		lda $54		        lda  btab+2
.954a	 85 19		sta $19		        sta  header+3
.954c	 a5 53		lda $53		        lda  btab+1
.954e	 85 1a		sta $1a		        sta  header+4
.9550	 20 d9 98	jsr $98d9	        jsr  jget4gb    ; get 2 more
.9553	 a5 52		lda $52		        lda  btab       ; get id
.9555	 85 17		sta $17		        sta  header+1
.9557	 a5 53		lda $53		        lda  btab+1
.9559	 85 16		sta $16		        sta  header
.955b	 68		pla		        pla
.955c	 85 31		sta $31		        sta  bufpnt+1   ; restore pointer
.955e	 68		pla		        pla
.955f	 85 30		sta $30		        sta  bufpnt
.9561	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "lccread1.asm"

;******  Processing file "lccread1.asm"

.9600	 20 0f 97	jsr $970f	jdstrt  jsr  jsrch      ;  find header
.9603	 4c 54 97	jmp $9754	        jmp  jsync      ;  and then data block sync
.9606	 c9 00		cmp #$00	jread   cmp  #0         ;  test if read job
.9608	 f0 03		beq $960d	        beq  jread01    ;  go test if write
.960a	 4c 6e 97	jmp $976e	        jmp  jwright
.960d					jread01
.960d	 20 00 96	jsr $9600		jsr  jdstrt     ;  find header and start reading data
.9610	 2c 0f 18	bit $180f	-	bit  pota1	;  4
.9613	 30 fb		bmi $9610		bmi  -		;  3 + 2
.9615	 ad 01 1c	lda $1c01	        lda  data2      ;  4
.9618	 aa		tax		        tax     	;  2   reg x = xxxxx000
.9619	 bd 0d a0	lda $a00d,x	        lda  gcrtb1,x   ;  4   nibble a
.961c	 85 52		sta $52		        sta  btab	;  3
.961e	 8a		txa		        txa		;  2
.961f	 29 07		and #$07	        and  #%00000111 ;  2
.9621	 85 53		sta $53		        sta  btab+1	;  3   extract 3 bits nibble b
.9623	 2c 0f 18	bit $180f	-	bit  pota1	;  4
.9626	 30 fb		bmi $9623		bmi  -		;  3 + 2
.9628	 ad 01 1c	lda $1c01	        lda  data2      ;  4
.962b	 85 54		sta $54		        sta  btab+2	;  3
.962d	 29 c0		and #$c0	        and  #%11000000 ;  2   extract 2 bits nibble b
.962f	 05 53		ora $53		        ora  btab+1	;  3
.9631	 aa		tax		        tax     	;  2   reg x = xx000xxx
.9632	 bd 0d 9f	lda $9f0d,x	        lda  gcrtba,x   ;  4   nibble b
.9635	 05 52		ora $52		        ora  btab	;  3
.9637	 48		pha		        pha             ;  3
.9638	 4c 67 96	jmp $9667	        jmp  m5		;  3
.963b	 2c 0f 18	bit $180f	m3	bit  pota1	;  4
.963e	 30 fb		bmi $963b		bmi  m3		;  3 + 2
.9640	 ad 01 1c	lda $1c01	        lda  data2      ;  4
.9643	 aa		tax		        tax     	;  2   reg x = xxxxx000
.9644	 bd 0d a0	lda $a00d,x	        lda  gcrtb1,x   ;  4   nibble a
.9647	 85 52		sta $52		        sta  btab	;  3
.9649	 8a		txa			txa		;  2
.964a	 29 07		and #$07	        and  #%00000111 ;  2
.964c	 85 53		sta $53		        sta  btab+1	;  3   extract 3 bits nibble b
.964e	 2c 0f 18	bit $180f	-	bit  pota1	;  4
.9651	 30 fb		bmi $964e		bmi  -		;  3 + 2
.9653	 ad 01 1c	lda $1c01		lda  data2      ;  4
.9656	 85 54		sta $54		        sta  btab+2	;  3
.9658	 29 c0		and #$c0	        and  #%11000000 ;  2
.965a	 05 53		ora $53		        ora  btab+1	;  3
.965c	 aa		tax		        tax             ;  2   reg x = xx000xxx
.965d	 bd 0d 9f	lda $9f0d,x	        lda  gcrtba,x   ;  4   nibble b
.9660	 05 52		ora $52		        ora  btab	;  3
.9662	 91 30		sta ($30),y	        sta  (bufpnt),y ;  6
.9664	 c8		iny		        iny     	;  2
.9665	 f0 70		beq $96d7	        beq  m6		;  2
.9667	 a5 54		lda $54		m5	lda  btab+2	;  3
.9669	 aa		tax		        tax     	;  2   reg x = 00xxxxx0
.966a	 bd 0d a1	lda $a10d,x	        lda  gcrtb2,x   ;  4   nibble c
.966d	 85 52		sta $52		        sta  btab	;  3
.966f	 8a		txa			txa		;  2
.9670	 29 01		and #$01	        and  #%00000001 ;  2
.9672	 85 54		sta $54		        sta  btab+2	;  3   extract 1 bits nibble d
.9674	 2c 0f 18	bit $180f	-	bit  pota1	;  4
.9677	 30 fb		bmi $9674		bmi  -		;  3 + 2
.9679	 ad 01 1c	lda $1c01	        lda  data2      ;  4
.967c	 85 55		sta $55		        sta  btab+3	;  3
.967e	 29 f0		and #$f0	        and  #%11110000 ;  2
.9680	 05 54		ora $54		        ora  btab+2	;  3
.9682	 aa		tax		        tax     	;  2   reg x = xxxx000x
.9683	 bd 0f 9f	lda $9f0f,x	        lda  gcrtbd,x   ;  4   nibble d
.9686	 05 52		ora $52		        ora  btab	;  3
.9688	 91 30		sta ($30),y	        sta  (bufpnt),y ;  6
.968a	 c8		iny		        iny     	;  2
.968b	 a5 55		lda $55		        lda  btab+3	;  3
.968d	 29 0f		and #$0f	        and  #%00001111 ;  2
.968f	 85 55		sta $55		        sta  btab+3	;  3   extract 4 bits nibble e
.9691	 2c 0f 18	bit $180f	-	bit  pota1	;  4
.9694	 30 fb		bmi $9691		bmi  -		;  3 + 2
.9696	 ad 01 1c	lda $1c01	        lda  data2      ;  4
.9699	 85 3a		sta $3a		        sta  chksum	;  3
.969b	 29 80		and #$80	        and  #%10000000 ;  2
.969d	 05 55		ora $55		        ora  btab+3	;  3
.969f	 aa		tax		        tax     	;  2   reg x = x000xxxx
.96a0	 bd 1d 9f	lda $9f1d,x	        lda  gcrtbe,x   ;  4   nibble e
.96a3	 85 52		sta $52		        sta  btab	;  3
.96a5	 a5 3a		lda $3a		        lda  chksum	;  3
.96a7	 aa		tax		        tax     	;  2   reg x = 0xxxxx00
.96a8	 bd 0d a2	lda $a20d,x	        lda  gcrtb3,x   ;  4   nibble f
.96ab	 05 52		ora $52		        ora  btab	;  3
.96ad	 91 30		sta ($30),y	        sta  (bufpnt),y ;  6
.96af	 c8		iny		        iny     	;  2
.96b0	 8a		txa			txa		;  2
.96b1	 29 03		and #$03	        and  #%00000011 ;  2
.96b3	 85 3a		sta $3a		        sta  chksum	;  3   extract 2 bits nibble g
.96b5	 2c 0f 18	bit $180f	-	bit  pota1	;  4
.96b8	 30 fb		bmi $96b5		bmi  -		;  3 + 2
.96ba	 ad 01 1c	lda $1c01	        lda  data2      ;  4
.96bd	 85 53		sta $53		        sta  btab+1	;  3
.96bf	 29 e0		and #$e0	        and  #%11100000 ;  2
.96c1	 05 3a		ora $3a		        ora  chksum	;  3
.96c3	 aa		tax		        tax     	;  2   reg x = xxx000xx
.96c4	 bd 2a 9f	lda $9f2a,x	        lda  gcrtbg,x   ;  4   nibble g
.96c7	 85 52		sta $52		        sta  btab	;  3
.96c9	 a5 53		lda $53		        lda  btab+1	;  3
.96cb	 aa		tax		        tax     	;  2   reg x = 000xxxxx
.96cc	 bd 0d a3	lda $a30d,x	        lda  gcrtb4,x   ;  4   nibble h
.96cf	 05 52		ora $52		        ora  btab	;  3
.96d1	 91 30		sta ($30),y	        sta  (bufpnt),y ;  6
.96d3	 c8		iny		        iny     	;  2
.96d4	 4c 3b 96	jmp $963b	        jmp  m3		;  4
.96d7	 a5 54		lda $54		m6	lda  btab+2	;  3
.96d9	 aa		tax		        tax     	;  2   reg x = 00xxxxx0
.96da	 bd 0d a1	lda $a10d,x	        lda  gcrtb2,x   ;  4   nibble c
.96dd	 85 52		sta $52		        sta  btab	;  3
.96df	 8a		txa			txa		;  2
.96e0	 29 01		and #$01	        and  #%00000001 ;  2
.96e2	 85 54		sta $54		        sta  btab+2	;  3
.96e4	 2c 0f 18	bit $180f	-	bit  pota1	;  4
.96e7	 30 fb		bmi $96e4		bmi  -		;  3 + 2
.96e9	 ad 01 1c	lda $1c01	        lda  data2      ;  4
.96ec	 29 f0		and #$f0	        and  #%11110000 ;  2
.96ee	 05 54		ora $54		        ora  btab+2	;  3
.96f0	 aa		tax		        tax     	;  2   reg x = xxxx000x
.96f1	 bd 0f 9f	lda $9f0f,x	        lda  gcrtbd,x   ;  4   nibble d
.96f4	 05 52		ora $52		        ora  btab	;  3
.96f6	 85 53		sta $53		        sta  btab+1	;  3   store off cs byte
.96f8	 68		pla		        pla     	; retrieve first byte off of disk
.96f9	 c5 47		cmp $47		        cmp  dbid       ; see if it is a 7
.96fb	 d0 0a		bne $9707	        bne  m12	; br, nope
.96fd	 20 e9 f5	jsr $f5e9		jsr  chkblk     ; calc checksum
.9700	 c5 53		cmp $53		        cmp  btab+1
.9702	 f0 06		beq $970a	        beq  m11
.9704	 a9 05		lda #$05	        lda  #5         ; data block checksum error

>9706	 2c                       	        .byte    skip2

.9707	 a9 04		lda #$04	m12	lda  #4

>9709	 2c                       	        .byte    skip2

.970a	 a9 01		lda #$01	m11	lda  #1         ; read data block ok
.970c	 4c b5 99	jmp $99b5	        jmp  jerrr
.970f					jsrch
.970f	 a5 12		lda $12			lda  dskid      ; get master id for the drive
.9711	 85 16		sta $16		        sta  header
.9713	 a5 13		lda $13		        lda  dskid+1
.9715	 85 17		sta $17		        sta  header+1
.9717	 a0 00		ldy #$00	        ldy  #0         ; get track,sectr
.9719	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.971b	 85 18		sta $18		        sta  header+2
.971d	 c8		iny		        iny
.971e	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.9720	 85 19		sta $19		        sta  header+3
.9722	 a9 00		lda #$00	        lda  #0
.9724	 45 16		eor $16		        eor  header
.9726	 45 17		eor $17		        eor  header+1
.9728	 45 18		eor $18		        eor  header+2
.972a	 45 19		eor $19		        eor  header+3
.972c	 85 1a		sta $1a		        sta  header+4   ; store the checksum
.972e	 20 34 f9	jsr $f934	        jsr  conhdr     ; convert header to gcr
.9731	 a9 5a		lda #$5a	        lda  #90        ; search 90 sync chars
.9733	 85 4b		sta $4b		        sta  tmp
.9735	 20 54 97	jsr $9754	m1	jsr  jsync      ; find sync
.9738	 b9 24 00	lda $0024,y	m2	lda  stab,y     ; what it should be
.973b	 2c 0f 18	bit $180f	-	bit  pota1
.973e	 30 fb		bmi $973b		bmi  -
.9740	 cd 01 1c	cmp $1c01	        cmp  data2      ; is it the same .cmp absolute
.9743	 d0 06		bne $974b	        bne  m4		; nope
.9745	 c8		iny		        iny
.9746	 c0 08		cpy #$08	        cpy  #8
.9748	 d0 ee		bne $9738	        bne  m2
.974a	 60		rts		        rts
.974b	 c6 4b		dec $4b		m4	dec  tmp        ; try again
.974d	 d0 e6		bne $9735	        bne  m1
.974f	 a9 02		lda #$02	        lda  #2         ; cant find this header
.9751	 4c b5 99	jmp $99b5		jmp  jerrr
.9754	 a2 0f		ldx #$0f	jsync   ldx  #15
.9756	 a0 00		ldy #$00		ldy  #0		; s/w timers ok
.9758	 2c 00 1c	bit $1c00	-	bit  dskcnt	; sync a synch ?
.975b	 10 0b		bpl $9768		bpl  +
.975d	 88		dey			dey
.975e	 d0 f8		bne $9758		bne  -
.9760	 ca		dex			dex
.9761	 d0 f5		bne $9758		bne  -
.9763	 a9 03		lda #$03		lda  #3
.9765	 4c b5 99	jmp $99b5		jmp  jerrr	; sync error
.9768	 ad 01 1c	lda $1c01	+	lda  data2	; clear pa latch
.976b	 a0 00		ldy #$00		ldy  #0         ; clear pointer
.976d	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "lccwrt1.asm"

;******  Processing file "lccwrt1.asm"

.976e					jwright
.976e	 c9 10		cmp #$10		cmp  #$10       ;  test if write
.9770	 f0 03		beq $9775	        beq  +
.9772	 4c 98 98	jmp $9898	        jmp  jvrfy
.9775	 20 e9 f5	jsr $f5e9	+	jsr  chkblk     ;  get block checksum
.9778	 85 3a		sta $3a			sta  chksum
.977a	 ad 00 1c	lda $1c00	        lda  dskcnt	;  test for write protect
.977d	 29 10		and #$10	        and  #$10
.977f	 d0 05		bne $9786	        bne  +		;  not  protected
.9781	 a9 08		lda #$08	        lda  #8         ;  write protect error
.9783	 4c b5 99	jmp $99b5	        jmp  jerrr
.9786	 20 8f f7	jsr $f78f	+	jsr  bingcr     ;  convert buffer to write image
.9789	 20 0f 97	jsr $970f	        jsr  jsrch      ;  find header
.978c	 a0 09		ldy #$09	        ldy  #gap1-2    ;  wait out header gap
.978e	 2c 0f 18	bit $180f	-	bit  pota1
.9791	 30 fb		bmi $978e		bmi  -
.9793	 2c 00 1c	bit $1c00		bit  byt_clr
.9796	 88		dey		        dey     	;  test if done yet
.9797	 d0 f5		bne $978e	        bne  -
.9799	 a9 ff		lda #$ff	        lda  #$ff       ;  make output $ff
.979b	 8d 03 1c	sta $1c03	        sta  ddra2
.979e	 ad 0c 1c	lda $1c0c	        lda  pcr2	;  set write mode
.97a1	 29 1f		and #$1f	        and  #$ff-$e0   ;  0=wr
.97a3	 09 c0		ora #$c0		ora  #$c0
.97a5	 8d 0c 1c	sta $1c0c	        sta  pcr2
.97a8	 a9 ff		lda #$ff	        lda  #$ff       ;  write 4 gcr sync
.97aa	 a0 05		ldy #$05	        ldy  #numsyn
.97ac	 8d 01 1c	sta $1c01	        sta  data2
.97af	 2c 0f 18	bit $180f	-	bit  pota1
.97b2	 30 fb		bmi $97af		bmi  -
.97b4	 2c 00 1c	bit $1c00		bit  byt_clr
.97b7	 88		dey		        dey
.97b8	 d0 f5		bne $97af	        bne  -
.97ba	 a0 bb		ldy #$bb	        ldy  #256-topwrt
.97bc	 b9 00 01	lda $0100,y	m5	lda  ovrbuf,y   ; get a char
.97bf	 2c 0f 18	bit $180f	-	bit  pota1
.97c2	 30 fb		bmi $97bf		bmi  -
.97c4	 8d 01 1c	sta $1c01	        sta  data2      ;  stuff it
.97c7	 c8		iny		        iny
.97c8	 d0 f2		bne $97bc	        bne  m5		;  do next char
.97ca	 b1 30		lda ($30),y	m7	lda  (bufpnt),y ;  now do buffer
.97cc	 2c 0f 18	bit $180f	-	bit  pota1	;  wait until ready
.97cf	 30 fb		bmi $97cc		bmi  -
.97d1	 8d 01 1c	sta $1c01	        sta  data2      ;  stuff it again
.97d4	 c8		iny		        iny      	;  test if done
.97d5	 d0 f3		bne $97ca	        bne  m7		;  do the whole thing
.97d7	 2c 0f 18	bit $180f	-	bit  pota1	;  wait for last char to write out
.97da	 30 fb		bmi $97d7		bmi  -
.97dc	 ad 0c 1c	lda $1c0c	        lda  pcr2	;  goto read mode
.97df	 09 e0		ora #$e0		ora  #$e0
.97e1	 8d 0c 1c	sta $1c0c	        sta  pcr2
.97e4	 a9 00		lda #$00	        lda  #0         ;  make data2 input $00
.97e6	 8d 03 1c	sta $1c03	        sta  ddra2
.97e9	 20 f9 97	jsr $97f9	        jsr  jwtobin    ;  convert write image to binary
.97ec	 a4 3f		ldy $3f		        ldy  jobn       ;  make job a verify
.97ee	 4c ad aa	jmp $aaad		jmp  ptch62	; *** rom ds 01/21/86 ***, chk for verify
.97f1	 49 30		eor #$30	        eor  #$30
.97f3	 99 00 00	sta $0000,y	        sta  jobs,y
.97f6	 4c 4f 94	jmp $944f	        jmp  jseak      ;  scan job que
.97f9					jwtobin
.97f9	 a9 00		lda #$00		lda  #0
.97fb	 85 2e		sta $2e			sta  savpnt
.97fd	 85 30		sta $30			sta  bufpnt     ;  lsb for overflow area
.97ff	 85 4f		sta $4f			sta  nxtpnt
.9801	 a5 31		lda $31		        lda  bufpnt+1
.9803	 85 4e		sta $4e		        sta  nxtbf      ;  save for next buffer.
.9805	 a9 01		lda #$01	        lda  #>ovrbuf	;  overflow first
.9807	 85 31		sta $31		        sta  bufpnt+1   ;  msb for overflow area
.9809	 85 2f		sta $2f		        sta  savpnt+1
.980b	 a9 bb		lda #$bb	        lda  #256-topwrt
.980d	 85 34		sta $34		        sta  gcrpnt     ;  offset
.980f	 85 36		sta $36		        sta  bytcnt     ;  ditto
.9811	 20 d9 98	jsr $98d9	        jsr  jget4gb    ;  get first four- id and 3 data
.9814	 a5 52		lda $52		        lda  btab       ;  save bid
.9816	 85 38		sta $38		        sta  bid
.9818	 a4 36		ldy $36		        ldy  bytcnt
.981a	 a5 53		lda $53		        lda  btab+1
.981c	 91 2e		sta ($2e),y	        sta  (savpnt),y
.981e	 c8		iny		        iny
.981f	 a5 54		lda $54		        lda  btab+2
.9821	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9823	 c8		iny		        iny
.9824	 a5 55		lda $55		        lda  btab+3
.9826	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9828	 c8		iny		        iny
.9829	 84 36		sty $36		        sty  bytcnt
.982b	 20 d9 98	jsr $98d9	-	jsr  jget4gb    ; do rest of overflow buffer
.982e	 a4 36		ldy $36		        ldy  bytcnt
.9830	 a5 52		lda $52		        lda  btab
.9832	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9834	 c8		iny		        iny
.9835	 a5 53		lda $53		        lda  btab+1
.9837	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9839	 c8		iny		        iny
.983a	 f0 0e		beq $984a	        beq  +
.983c	 a5 54		lda $54		        lda  btab+2
.983e	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9840	 c8		iny		        iny
.9841	 a5 55		lda $55		        lda  btab+3
.9843	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9845	 c8		iny		        iny
.9846	 84 36		sty $36		        sty  bytcnt
.9848	 d0 e1		bne $982b	        bne  -		;  jmp till end of overflow buffer
.984a	 a5 54		lda $54		+       lda  btab+2
.984c	 91 30		sta ($30),y	        sta  (bufpnt),y
.984e	 c8		iny		        iny
.984f	 a5 55		lda $55		        lda  btab+3
.9851	 91 30		sta ($30),y	        sta  (bufpnt),y
.9853	 c8		iny		        iny
.9854	 84 36		sty $36		        sty  bytcnt
.9856	 20 d9 98	jsr $98d9	-	jsr  jget4gb
.9859	 a4 36		ldy $36		        ldy  bytcnt
.985b	 a5 52		lda $52		        lda  btab
.985d	 91 30		sta ($30),y	        sta  (bufpnt),y
.985f	 c8		iny		        iny
.9860	 a5 53		lda $53		        lda  btab+1
.9862	 91 30		sta ($30),y	        sta  (bufpnt),y
.9864	 c8		iny		        iny
.9865	 a5 54		lda $54		        lda  btab+2
.9867	 91 30		sta ($30),y	        sta  (bufpnt),y
.9869	 c8		iny		        iny
.986a	 a5 55		lda $55		        lda  btab+3
.986c	 91 30		sta ($30),y	        sta  (bufpnt),y
.986e	 c8		iny		        iny
.986f	 84 36		sty $36		        sty  bytcnt
.9871	 c0 bb		cpy #$bb	        cpy  #187
.9873	 90 e1		bcc $9856	        bcc  -
.9875	 a9 45		lda #$45		lda  #69		;  move buffer up
.9877	 85 2e		sta $2e		        sta  savpnt
.9879	 a5 31		lda $31		        lda  bufpnt+1
.987b	 85 2f		sta $2f		        sta  savpnt+1
.987d	 a0 ba		ldy #$ba	        ldy  #256-topwrt-1
.987f	 b1 30		lda ($30),y	-	lda  (bufpnt),y
.9881	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9883	 88		dey		        dey
.9884	 d0 f9		bne $987f	        bne  -
.9886	 b1 30		lda ($30),y	        lda  (bufpnt),y
.9888	 91 2e		sta ($2e),y	        sta  (savpnt),y
.988a	 a2 bb		ldx #$bb	        ldx  #256-topwrt
.988c	 bd 00 01	lda $0100,x	-	lda  ovrbuf,x
.988f	 91 30		sta ($30),y	        sta  (bufpnt),y
.9891	 c8		iny		        iny
.9892	 e8		inx		        inx
.9893	 d0 f7		bne $988c	        bne  -
.9895	 86 50		stx $50		        stx  gcrflg     ; clear buffer gcr flag
.9897	 60		rts		        rts
.9898					jvrfy
.9898	 c9 20		cmp #$20		cmp  #$20       ;  test if verify
.989a	 f0 02		beq $989e	        beq  +
.989c	 d0 30		bne $98ce	        bne  m7		; bra
.989e	 20 e9 f5	jsr $f5e9	+       jsr  chkblk     ; get block checksum
.98a1	 85 3a		sta $3a			sta  chksum
.98a3	 20 8f f7	jsr $f78f	        jsr  bingcr     ; convert to verify image
.98a6	 20 00 96	jsr $9600	        jsr  jdstrt
.98a9	 a0 bb		ldy #$bb	        ldy  #256-topwrt
.98ab	 b9 00 01	lda $0100,y	m2	lda  ovrbuf,y   ;  get char
.98ae	 2c 0f 18	bit $180f	-	bit  pota1
.98b1	 30 fb		bmi $98ae		bmi  -
.98b3	 4d 01 1c	eor $1c01	        eor  data2      ;  test if same
.98b6	 d0 1c		bne $98d4	        bne  m4		; verify error
.98b8	 c8		iny		        iny
.98b9	 d0 f0		bne $98ab	        bne  m2		;  next byte
.98bb	 b1 30		lda ($30),y	m5	lda  (bufpnt),y ;  now do buffer
.98bd	 2c 0f 18	bit $180f	-	bit  pota1
.98c0	 30 fb		bmi $98bd		bmi  -
.98c2	 4d 01 1c	eor $1c01	        eor  data2      ;  test if same
.98c5	 d0 0d		bne $98d4	        bne  m4		;  error
.98c7	 c8		iny		        iny
.98c8	 c0 fd		cpy #$fd	        cpy  #$fd       ;  dont test off bytes
.98ca	 d0 ef		bne $98bb	        bne  m5
.98cc	 f0 03		beq $98d1		beq  m8		;  bra
.98ce	 20 0f 97	jsr $970f	m7	jsr  jsrch      ;  sector seek
.98d1	 a9 01		lda #$01	m8	lda  #1

>98d3	 2c                       		.byte  skip2

.98d4	 a9 07		lda #$07	m4	lda  #7         ;  verify error
.98d6	 4c b5 99	jmp $99b5	        jmp  jerrr

;******  Return to file "serlib.asm"

					        .include "lccgcrbn.asm"

;******  Processing file "lccgcrbn.asm"

.98d9	 a4 34		ldy $34		jget4gb ldy  gcrpnt
.98db	 b1 30		lda ($30),y	        lda  (bufpnt),y
.98dd	 85 56		sta $56		        sta  gtab       	;  A
.98df	 29 07		and #$07	        and  #mask2
.98e1	 85 57		sta $57		        sta  gtab+1
.98e3	 c8		iny		        iny             	;  next byte
.98e4	 d0 06		bne $98ec	        bne  +			;  test for next buffer
.98e6	 a5 4e		lda $4e		        lda  nxtbf
.98e8	 85 31		sta $31		        sta  bufpnt+1
.98ea	 a4 4f		ldy $4f		        ldy  nxtpnt
.98ec	 b1 30		lda ($30),y	+	lda  (bufpnt),y
.98ee	 85 58		sta $58			sta  gtab+2		;  C
.98f0	 29 c0		and #$c0	        and  #mask2x
.98f2	 05 57		ora $57		        ora  gtab+1
.98f4	 85 57		sta $57		        sta  gtab+1     	;  B
.98f6	 a5 58		lda $58			lda  gtab+2
.98f8	 29 01		and #$01	        and  #mask4
.98fa	 85 59		sta $59		        sta  gtab+3
.98fc	 c8		iny		        iny     		;  next
.98fd	 b1 30		lda ($30),y	        lda  (bufpnt),y
.98ff	 aa		tax		        tax
.9900	 29 f0		and #$f0	        and  #mask4x
.9902	 05 59		ora $59		        ora  gtab+3
.9904	 85 59		sta $59		        sta  gtab+3     	;  D
.9906	 8a		txa		        txa
.9907	 29 0f		and #$0f	        and  #mask5
.9909	 85 5a		sta $5a		        sta  gtab+4
.990b	 c8		iny		        iny     		;  next byte
.990c	 b1 30		lda ($30),y	        lda  (bufpnt),y
.990e	 85 5b		sta $5b			sta  gtab+5		;  F
.9910	 29 80		and #$80	        and  #mask5x
.9912	 05 5a		ora $5a		        ora  gtab+4
.9914	 85 5a		sta $5a		        sta  gtab+4     	;  E
.9916	 a5 5b		lda $5b			lda  gtab+5
.9918	 29 03		and #$03	        and  #mask7
.991a	 85 5c		sta $5c		        sta  gtab+6
.991c	 c8		iny		        iny
.991d	 d0 08		bne $9927	        bne  +
.991f	 a5 4e		lda $4e		        lda  nxtbf
.9921	 85 31		sta $31		        sta  bufpnt+1
.9923	 a4 4f		ldy $4f		        ldy  nxtpnt
.9925	 84 30		sty $30		        sty  bufpnt
.9927	 b1 30		lda ($30),y	+	lda  (bufpnt),y
.9929	 85 5d		sta $5d			sta  gtab+7    		;  H
.992b	 29 e0		and #$e0	        and  #mask7x
.992d	 05 5c		ora $5c		        ora  gtab+6
.992f	 85 5c		sta $5c		        sta  gtab+6    		;  G
.9931	 c8		iny		        iny
.9932	 84 34		sty $34		        sty  gcrpnt
.9934	 a6 56		ldx $56		        ldx  gtab
.9936	 bd 0d a0	lda $a00d,x	        lda  gcrtb1,x  		;  a
.9939	 a6 57		ldx $57		        ldx  gtab+1
.993b	 1d 0d 9f	ora $9f0d,x	        ora  gcrtba,x  		;  b
.993e	 85 52		sta $52		        sta  btab
.9940	 a6 58		ldx $58		        ldx  gtab+2
.9942	 bd 0d a1	lda $a10d,x	        lda  gcrtb2,x    	;  c
.9945	 a6 59		ldx $59		        ldx  gtab+3
.9947	 1d 0f 9f	ora $9f0f,x	        ora  gcrtbd,x    	;  d
.994a	 85 53		sta $53		        sta  btab+1
.994c	 a6 5a		ldx $5a		        ldx  gtab+4
.994e	 bd 1d 9f	lda $9f1d,x	        lda  gcrtbe,x    	;  e
.9951	 a6 5b		ldx $5b		        ldx  gtab+5
.9953	 1d 0d a2	ora $a20d,x		ora  gcrtb3,x    	;  f
.9956	 85 54		sta $54		        sta  btab+2
.9958	 a6 5c		ldx $5c		        ldx  gtab+6
.995a	 bd 2a 9f	lda $9f2a,x	        lda  gcrtbg,x    	;  g
.995d	 a6 5d		ldx $5d		        ldx  gtab+7
.995f	 1d 0d a3	ora $a30d,x	        ora  gcrtb4,x    	;  h
.9962	 85 55		sta $55		        sta  btab+3
.9964	 60		rts		        rts
.9965	 a9 00		lda #$00	jgcrbin lda  #0         ;  setup pointers
.9967	 85 34		sta $34		        sta  gcrpnt
.9969	 85 2e		sta $2e		        sta  savpnt
.996b	 85 36		sta $36		        sta  bytcnt
.996d	 a9 01		lda #$01	        lda  #>ovrbuf	; point to overflow first
.996f	 85 4e		sta $4e		        sta  nxtbf
.9971	 a9 ba		lda #$ba	        lda  #255-toprd	; overflow offset
.9973	 85 4f		sta $4f		        sta  nxtpnt
.9975	 a5 31		lda $31		        lda  bufpnt+1
.9977	 85 2f		sta $2f		        sta  savpnt+1
.9979	 20 d9 98	jsr $98d9	        jsr  jget4gb
.997c	 a5 52		lda $52		        lda  btab
.997e	 85 38		sta $38		        sta  bid        ;  get header id
.9980	 a4 36		ldy $36		        ldy  bytcnt
.9982	 a5 53		lda $53		        lda  btab+1
.9984	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9986	 c8		iny		        iny
.9987	 a5 54		lda $54		        lda  btab+2
.9989	 91 2e		sta ($2e),y	        sta  (savpnt),y
.998b	 c8		iny		        iny
.998c	 a5 55		lda $55		        lda  btab+3
.998e	 91 2e		sta ($2e),y	        sta  (savpnt),y
.9990	 c8		iny		        iny
.9991	 84 36		sty $36		-	sty  bytcnt
.9993	 20 d9 98	jsr $98d9	        jsr  jget4gb
.9996	 a4 36		ldy $36		        ldy  bytcnt
.9998	 a5 52		lda $52		        lda  btab
.999a	 91 2e		sta ($2e),y	        sta  (savpnt),y
.999c	 c8		iny		        iny
.999d	 f0 11		beq $99b0	        beq  +			; test if done yet
.999f	 a5 53		lda $53		        lda  btab+1
.99a1	 91 2e		sta ($2e),y	        sta  (savpnt),y
.99a3	 c8		iny		        iny
.99a4	 a5 54		lda $54		        lda  btab+2
.99a6	 91 2e		sta ($2e),y	        sta  (savpnt),y
.99a8	 c8		iny		        iny
.99a9	 a5 55		lda $55		        lda  btab+3
.99ab	 91 2e		sta ($2e),y	        sta  (savpnt),y
.99ad	 c8		iny		        iny
.99ae	 d0 e1		bne $9991	        bne  -		;  jmp
.99b0	 a5 2f		lda $2f		+       lda  savpnt+1   ; restore buffer pointer
.99b2	 85 31		sta $31		        sta  bufpnt+1
.99b4	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "lccutil1.asm"

;******  Processing file "lccutil1.asm"

.99b5	 a4 3f		ldy $3f		jerrr   ldy  jobn       ; return  job code
.99b7	 99 00 00	sta $0000,y	        sta  jobs,y
.99ba	 a5 50		lda $50		        lda  gcrflg     ; test if buffer left gcr
.99bc	 f0 03		beq $99c1	        beq  +		; no
.99be	 20 f9 97	jsr $97f9	        jsr  jwtobin    ; convert back to binary
.99c1	 20 8f f9	jsr $f98f	+       jsr  trnoff     ; start timeout on drive
.99c4	 a6 49		ldx $49		        ldx  savsp
.99c6	 9a		txs		        txs     	; reset stack pointer
.99c7	 4c c8 92	jmp $92c8	        jmp  jtop       ; back to the top
.99ca					jend
.99ca	 ad 07 1c	lda $1c07	        lda  t1hl2	; set irq timer
.99cd	 8d 05 1c	sta $1c05		sta  t1hc2
.99d0	 ad 00 1c	lda $1c00		lda  dskcnt
.99d3	 29 10		and #$10	        and  #$10	; wpsw
.99d5	 c5 1e		cmp $1e		        cmp  lwpt       ; same as last
.99d7	 85 1e		sta $1e		        sta  lwpt       ; update
.99d9	 d0 07		bne $99e2	        bne  m1
.99db	 ad ab 02	lda $02ab	        lda  mtrcnt     ; anything to do?
.99de	 d0 10		bne $99f0	        bne  m7		; dec & finish up
.99e0	 f0 1c		beq $99fe	        beq  m2		; nothing to do
.99e2	 a9 ff		lda #$ff	m1	lda  #$ff
.99e4	 8d ab 02	sta $02ab	        sta  mtrcnt     ; 255*8ms motor on time
.99e7	 20 64 87	jsr $8764	        jsr  moton
.99ea	 20 96 ab	jsr $ab96		jsr  ptch72	; *** rom ds 05/20/86 ***
.99ed	 ea		nop			nop
.99ee	 d0 0e		bne $99fe	        bne  m2		; bra
.99f0	 ce ab 02	dec $02ab	m7      dec  mtrcnt     ; dec & return
.99f3	 d0 09		bne $99fe	        bne  m2
.99f5	 a5 20		lda $20		        lda  drvst
.99f7	 c9 00		cmp #$00	        cmp  #$00       ; motor off & no active drive ?
.99f9	 d0 03		bne $99fe	        bne  m2		; br, do not turn it off something is going on
.99fb	 20 70 87	jsr $8770	        jsr  motoff
.99fe	 ad fe 02	lda $02fe	m2      lda  phase	; test for phase offset
.9a01	 f0 15		beq $9a18	        beq  m5
.9a03	 c9 02		cmp #$02	        cmp  #2
.9a05	 d0 07		bne $9a0e	        bne  m3
.9a07	 a9 00		lda #$00	        lda  #0
.9a09	 8d fe 02	sta $02fe	        sta  phase
.9a0c	 f0 0a		beq $9a18	        beq  m5		; bra
.9a0e	 85 4a		sta $4a		m3	sta  steps
.9a10	 a9 02		lda #$02	        lda  #2
.9a12	 8d fe 02	sta $02fe	        sta  phase
.9a15	 4c 56 9a	jmp $9a56	        jmp  m6
.9a18	 a6 3e		ldx $3e		m5	ldx  cdrive     ;  work on active drive only
.9a1a	 30 07		bmi $9a23	        bmi  m8		;  no active drive
.9a1c	 a5 20		lda $20		        lda  drvst      ;  test if motor on
.9a1e	 a8		tay		        tay
.9a1f	 c9 20		cmp #$20	        cmp  #$20       ;  test if anything to do
.9a21	 d0 03		bne $9a26	        bne  m9		;  something here
.9a23	 4c c6 9a	jmp $9ac6	m8	jmp  m10	;  motor just running
.9a26	 c6 48		dec $48		m9	dec  acltim     ;  dec timer
.9a28	 d0 1c		bne $9a46	        bne  m11
.9a2a	 98		tya		        tya     	;  test if acel
.9a2b	 10 04		bpl $9a31	        bpl  m12
.9a2d	 29 7f		and #$7f	        and  #$7f       ;  over, clear acel bit
.9a2f	 85 20		sta $20		        sta  drvst
.9a31	 29 10		and #$10	m12	and  #$10       ;  test if time out state
.9a33	 f0 11		beq $9a46	        beq  m11
.9a35	 c6 35		dec $35			dec  acltim2	;  decrement second timer
.9a37	 d0 0d		bne $9a46		bne  m11
.9a39	 20 70 87	jsr $8770		jsr  motoff
.9a3c	 a9 ff		lda #$ff	        lda  #$ff       ;  no active drive now
.9a3e	 85 3e		sta $3e		        sta  cdrive
.9a40	 a9 00		lda #$00	        lda  #0         ;  drive inactive
.9a42	 85 20		sta $20		        sta  drvst      ;  clear on bit and timout
.9a44	 f0 dd		beq $9a23	        beq  m8
.9a46	 98		tya		m11	tya     	;  test if step needed
.9a47	 29 40		and #$40	        and  #$40
.9a49	 d0 03		bne $9a4e	        bne  m13	;  stepping
.9a4b	 4c c6 9a	jmp $9ac6	        jmp  m10
.9a4e	 a5 62		lda $62		m13	lda  nxtst      ; step or settle
.9a50	 d0 50		bne $9aa2	        bne  m18	; go set
.9a52	 a5 4a		lda $4a			lda  steps
.9a54	 f0 43		beq $9a99	        beq  m17
.9a56	 a5 4a		lda $4a		m6      lda  steps
.9a58	 10 59		bpl $9ab3	        bpl  m14
.9a5a	 98		tya			tya
.9a5b	 48		pha			pha		; save regs .y
.9a5c	 a0 63		ldy #$63		ldy  #99	; wait for trk_00
.9a5e	 ad 0f 18	lda $180f	m15	lda  pota1	; check for trk_00
.9a61	 6a		ror a			ror  a		; rotate into carry
.9a62	 08		php			php		; save it
.9a63	 ad 0f 18	lda $180f		lda  pota1	; debounce it
.9a66	 6a		ror a			ror  a		; => carry
.9a67	 6a		ror a			ror  a		; => bit 7
.9a68	 28		plp			plp		; restore carry
.9a69	 29 80		and #$80		and  #$80	; set/clear sign bit
.9a6b	 90 04		bcc $9a71		bcc  m21
.9a6d	 10 1d		bpl $9a8c		bpl  m16	; carry set(off) & sign clear(on) exit
.9a6f	 30 02		bmi $9a73		bmi  m20	; bra
.9a71	 30 19		bmi $9a8c	m21	bmi  m16	; carry clear(on) & sign set(off) exit
.9a73	 88		dey		m20	dey
.9a74	 d0 e8		bne $9a5e		bne  m15	; wait a while
.9a76	 b0 14		bcs $9a8c		bcs  m16	; br, not track 00 ?
.9a78	 a5 7b		lda $7b			lda  adrsed	; enable/disable track 00 sense
.9a7a	 d0 10		bne $9a8c		bne  m16	; br, nope...
.9a7c	 ad 00 1c	lda $1c00		lda  dskcnt	; phase 0
.9a7f	 29 03		and #$03		and  #3
.9a81	 d0 09		bne $9a8c		bne  m16
.9a83	 68		pla			pla
.9a84	 a8		tay			tay		; restore .y
.9a85	 a9 00		lda #$00		lda  #0
.9a87	 85 4a		sta $4a			sta  steps	; nomore steps
.9a89	 4c c6 9a	jmp $9ac6		jmp  m10
.9a8c	 68		pla		m16	pla
.9a8d	 a8		tay			tay		; restore .y
.9a8e	 e6 4a		inc $4a			inc  steps      ; keep stepping
.9a90	 ad 00 1c	lda $1c00	        lda  dskcnt
.9a93	 38		sec		        sec
.9a94	 e9 01		sbc #$01	        sbc  #1        	; -1 to step out
.9a96	 4c bb 9a	jmp $9abb	        jmp  m19
.9a99	 a9 02		lda #$02	m17	lda  #2         ;  settle time
.9a9b	 85 48		sta $48		        sta  acltim
.9a9d	 85 62		sta $62		        sta  nxtst      ; show set status
.9a9f	 4c c6 9a	jmp $9ac6	        jmp  m10
.9aa2	 c6 48		dec $48		m18	dec  acltim
.9aa4	 d0 20		bne $9ac6	        bne  m10
.9aa6	 a5 20		lda $20		        lda  drvst
.9aa8	 29 bf		and #$bf	        and  #$ff-$40
.9aaa	 85 20		sta $20		        sta  drvst
.9aac	 a9 00		lda #$00	        lda  #00
.9aae	 85 62		sta $62		        sta  nxtst
.9ab0	 4c c6 9a	jmp $9ac6	        jmp  m10
.9ab3	 c6 4a		dec $4a		m14	dec  steps
.9ab5	 ad 00 1c	lda $1c00	        lda  dskcnt
.9ab8	 18		clc		        clc
.9ab9	 69 01		adc #$01	        adc  #01
.9abb	 29 03		and #$03	m19	and  #3
.9abd	 85 4b		sta $4b		        sta  tmp
.9abf	 ad 00 1c	lda $1c00	        lda  dskcnt
.9ac2	 4c 38 c0	jmp $c038		jmp  ptch0a	; *** rom ds 11/7/86 ***, finish up
.9ac5	 ea		nop			nop		; fill
.9ac6	 4c 3f c0	jmp $c03f	m10	jmp  ptch0b	; *** rom ds 11/7/86 ***, disable SO
.9ac9	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "lccfmt2a.asm"

;******  Processing file "lccfmt2a.asm"


>9aca	 21 22 23 24 25 26 27 28 	gaptbl  .byte $21,$22,$23,$24,$25,$26,$27,$28,$29
>9ad2	 29 
=0009					gp2cmd=*-gaptbl
>9ad3	 02 02 04 06 08 08 0b 13 	gp2tbl  .byte 2,2,4,6,8,8,11,19,22
>9adb	 16 
=9adc					ouounrlt = spdchk

.9adc					spdchk
.9adc	 a0 00		ldy #$00		ldy  #0         ; 5100/6153  write 82% sync
.9ade	 a2 1c		ldx #$1c		ldx  #28
.9ae0	 20 63 9d	jsr $9d63	        jsr  jclear     ; clear whole disk & more
.9ae3	 20 73 9b	jsr $9b73		jsr  fil_syn	; fill with sync
.9ae6	 20 00 fe	jsr $fe00	        jsr  kill       ; go read mode
.9ae9	 a0 ff		ldy #$ff		ldy  #mscnt
.9aeb	 a2 ff		ldx #$ff	-	ldx  #mscnt
.9aed	 2c 00 1c	bit $1c00	-	bit  dskcnt	; try to find sync
.9af0	 10 0b		bpl $9afd		bpl  m5		; got sync
.9af2	 ca		dex		        dex
.9af3	 d0 f8		bne $9aed	        bne  -
.9af5	 88		dey		        dey
.9af6	 d0 f3		bne $9aeb	        bne  --
.9af8	 a9 02		lda #$02	m4      lda  #2
.9afa	 4c 59 9d	jmp $9d59	        jmp  jfmte10    ; error
.9afd	 a0 00		ldy #$00	m5	ldy  #0
.9aff	 a2 00		ldx #$00	        ldx  #0
.9b01	 2c 00 1c	bit $1c00	-	bit  dskcnt     ; wait for sync to go away
.9b04	 10 fb		bpl $9b01		bpl  -		; got sync
.9b06	 ad 00 1c	lda $1c00	-	lda  dskcnt     ; count time till next sync
.9b09	 c8		iny		        iny     	; lsb not used
.9b0a	 d0 01		bne $9b0d	        bne  +
.9b0c	 e8		inx		        inx     	; msb
.9b0d	 29 80		and #$80	+	and  #$80
.9b0f	 d0 f5		bne $9b06	        bne  -		; br, still no sync
.9b11	 a9 00		lda #$00	        lda  #0
.9b13	 85 3b		sta $3b		        sta  tsttrk
.9b15	 8a		txa			txa		; msb
.9b16	 a2 08		ldx #$08	        ldx  #gp2cmd-1
.9b18	 dd ca 9a	cmp $9aca,x	-	cmp  gaptbl,x   ; lookup timing gap
.9b1b	 f0 05		beq $9b22	        beq  +
.9b1d	 ca		dex		        dex
.9b1e	 10 f8		bpl $9b18	        bpl  -
.9b20	 30 d6		bmi $9af8	        bmi  m4		; none
.9b22	 bd d3 9a	lda $9ad3,x	+	lda  gp2tbl,x   ; look it up
.9b25	 8d 26 06	sta $0626	        sta  dtrck
.9b28	 60		rts		        rts
.9b29					jformt
.9b29	 a5 51		lda $51			lda  ftnum      ; test if formating done
.9b2b	 10 2b		bpl $9b58	        bpl  m1		; yes
.9b2d	 a9 60		lda #$60	        lda  #$60       ; status = stepping
.9b2f	 85 20		sta $20		        sta  drvst
.9b31	 ad b2 01	lda $01b2		lda  fmtsid
.9b34	 d0 03		bne $9b39		bne  +
.9b36	 a9 01		lda #$01	        lda  #01

>9b38	 2c                       		.byte  skip2

.9b39	 a9 24		lda #$24	+       lda  #36
.9b3b	 85 22		sta $22		        sta  drvtrk     ; track 1/36
.9b3d	 85 51		sta $51		        sta  ftnum      ; track count =1/36
.9b3f	 c9 24		cmp #$24		cmp  #36	; set/clr carry flag
.9b41	 20 f3 93	jsr $93f3		jsr  set_side
.9b44	 a9 a4		lda #$a4	        lda  #256-92    ; step back 45 tracks
.9b46	 85 4a		sta $4a		        sta  steps
.9b48	 ad 00 1c	lda $1c00	        lda  dskcnt	; phase a
.9b4b	 29 fc		and #$fc	        and  #$ff-03
.9b4d	 8d 00 1c	sta $1c00	        sta  dskcnt
.9b50	 a9 0a		lda #$0a	        lda  #10
.9b52	 8d 20 06	sta $0620	        sta  cnt        ; init error count
.9b55	 4c ca 99	jmp $99ca	        jmp  jend       ; go back to controler
.9b58	 a0 00		ldy #$00	m1	ldy  #00
.9b5a	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.9b5c	 c5 51		cmp $51		        cmp  ftnum
.9b5e	 f0 07		beq $9b67	        beq  +
.9b60	 a5 51		lda $51		        lda  ftnum
.9b62	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9b64	 4c ca 99	jmp $99ca	        jmp  jend
.9b67	 ad 00 1c	lda $1c00	+	lda  dskcnt	; check wps
.9b6a	 29 10		and #$10		and  #$10
.9b6c	 d0 1b		bne $9b89	        bne  toptst	; ok
.9b6e	 a9 08		lda #$08	        lda  #8
.9b70	 4c 51 9d	jmp $9d51	        jmp  jfmterr    ; wp error
.9b73					fil_syn
.9b73	 a2 14		ldx #$14		ldx  #20        ; 20*256 bytes of sync
.9b75	 a9 ff		lda #$ff	        lda  #$ff       ; write syncs
.9b77	 2c 0f 18	bit $180f	-	bit  pota1
.9b7a	 30 fb		bmi $9b77		bmi  -
.9b7c	 8d 01 1c	sta $1c01	        sta  data2
.9b7f	 2c 00 1c	bit $1c00		bit  byt_clr
.9b82	 88		dey		        dey
.9b83	 d0 f2		bne $9b77	        bne  -
.9b85	 ca		dex		        dex
.9b86	 d0 ef		bne $9b77	        bne  -
.9b88	 60		rts			rts
.9b89					toptst
.9b89	 a5 3b		lda $3b			lda  tsttrk
.9b8b	 10 03		bpl $9b90	        bpl  +
.9b8d	 20 dc 9a	jsr $9adc	        jsr  spdchk
.9b90	 ad 26 06	lda $0626	+	lda  dtrck
.9b93	 18		clc		        clc
.9b94	 a9 03		lda #$03	        lda  #>bufs
.9b96	 85 33		sta $33		        sta  hdrpnt+1
.9b98	 a9 00		lda #$00	        lda  #00
.9b9a	 85 32		sta $32		        sta  hdrpnt     ; point hdr point to buf0
.9b9c	 8d 28 06	sta $0628	        sta  sect
.9b9f	 a0 00		ldy #$00	        ldy  #0
.9ba1	 a5 39		lda $39		m2      lda  hbid       ; hbid cs s t id id 0f 0f
.9ba3	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9ba5	 c8		iny		        iny
.9ba6	 a9 00		lda #$00	        lda  #00        ; check sum is zero for now
.9ba8	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9baa	 c8		iny		        iny
.9bab	 ad 28 06	lda $0628	        lda  sect       ; store sector #
.9bae	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9bb0	 c8		iny		        iny
.9bb1	 a5 51		lda $51		        lda  ftnum      ; store track #
.9bb3	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9bb5	 c8		iny		        iny
.9bb6	 a5 13		lda $13		        lda  dskid+1    ; store id low
.9bb8	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9bba	 c8		iny		        iny
.9bbb	 a5 12		lda $12		        lda  dskid      ; store id hi
.9bbd	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9bbf	 c8		iny		        iny
.9bc0	 a9 0f		lda #$0f	        lda  #$0f       ; store gap1 bytes
.9bc2	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9bc4	 c8		iny		        iny
.9bc5	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9bc7	 c8		iny		        iny
.9bc8	 98		tya		        tya     	; save this point
.9bc9	 48		pha		        pha
.9bca	 a2 07		ldx #$07	        ldx  #07
.9bcc	 a9 00		lda #$00	        lda  #00
.9bce	 85 3a		sta $3a		        sta  chksum     ; zero checksum
.9bd0	 88		dey		-	dey
.9bd1	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.9bd3	 45 3a		eor $3a		        eor  chksum
.9bd5	 85 3a		sta $3a		        sta  chksum
.9bd7	 ca		dex		        dex
.9bd8	 d0 f6		bne $9bd0	        bne  -
.9bda	 91 32		sta ($32),y	        sta  (hdrpnt),y ; store checksum
.9bdc	 68		pla		        pla
.9bdd	 a8		tay		        tay     	; restore pointer
.9bde	 ee 28 06	inc $0628	        inc  sect       ; goto next sector
.9be1	 ad 28 06	lda $0628	        lda  sect       ; test if done yet
.9be4	 c5 43		cmp $43		        cmp  sectr
.9be6	 90 b9		bcc $9ba1	        bcc  m2		; more to do
.9be8	 a9 03		lda #$03		lda  #3
.9bea	 85 31		sta $31			sta  bufpnt+1	; $03XX
.9bec	 20 30 fe	jsr $fe30	        jsr  fbtog      ; convert to gcr with no bid char
.9bef	 a0 ba		ldy #$ba	        ldy  #$ff-69    ; for i=n-1 to 0:mem+i+69|:=mem+i|:next
.9bf1	 b1 32		lda ($32),y	-	lda  (hdrpnt),y ; move buf0 up 69 bytes
.9bf3	 a2 45		ldx #$45	        ldx  #69
.9bf5	 86 32		stx $32		        stx  hdrpnt
.9bf7	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9bf9	 a2 00		ldx #$00	        ldx  #00
.9bfb	 86 32		stx $32		        stx  hdrpnt
.9bfd	 88		dey		        dey
.9bfe	 c0 ff		cpy #$ff	        cpy  #$ff
.9c00	 d0 ef		bne $9bf1	        bne  -
.9c02	 a0 44		ldy #$44	        ldy  #68        ; #bytes to move
.9c04	 b9 bb 01	lda $01bb,y	-	lda  ovrbuf+$bb,y
.9c07	 91 32		sta ($32),y	        sta  (hdrpnt),y
.9c09	 88		dey		        dey
.9c0a	 10 f8		bpl $9c04	        bpl  -
.9c0c	 18		clc		        clc
.9c0d	 a9 03		lda #$03	        lda  #>bufs
.9c0f	 69 02		adc #$02	        adc  #02
.9c11	 85 31		sta $31		        sta  bufpnt+1   ; point to buf2
.9c13	 a9 00		lda #$00	        lda  #00
.9c15	 a8		tay		        tay     	; init offset
.9c16	 91 30		sta ($30),y	-	sta  (bufpnt),y
.9c18	 c8		iny		        iny
.9c19	 d0 fb		bne $9c16	        bne  -
.9c1b	 20 e9 f5	jsr $f5e9	        jsr  chkblk     ; get block checksum
.9c1e	 85 3a		sta $3a			sta  chksum
.9c20	 20 8f f7	jsr $f78f	        jsr  bingcr
.9c23	 a9 00		lda #$00	        lda  #0         ; init counter
.9c25	 85 1b		sta $1b		        sta  fmhdpt
.9c27	 a2 06		ldx #$06	        ldx  #6         ; clear 8% of disk
.9c29	 20 63 9d	jsr $9d63	        jsr  jclear     ; clear disk
.9c2c	 a0 05		ldy #$05	m7	ldy  #numsyn    ; write 4 gcr bytes
.9c2e	 2c 0f 18	bit $180f	-	bit  pota1
.9c31	 30 fb		bmi $9c2e		bmi  -
.9c33	 a9 ff		lda #$ff		lda  #$ff       ; write sync
.9c35	 8d 01 1c	sta $1c01		sta  data2
.9c38	 2c 00 1c	bit $1c00		bit  byt_clr	; clear pa latch
.9c3b	 88		dey		        dey
.9c3c	 d0 f0		bne $9c2e	        bne  -
.9c3e	 a2 0a		ldx #$0a	        ldx  #10        ; write out header
.9c40	 a4 1b		ldy $1b		        ldy  fmhdpt
.9c42	 2c 0f 18	bit $180f	-       bit  pota1
.9c45	 30 fb		bmi $9c42		bmi  -
.9c47	 b1 32		lda ($32),y	        lda  (hdrpnt),y ; get header data
.9c49	 8d 01 1c	sta $1c01	        sta  data2
.9c4c	 2c 00 1c	bit $1c00		bit  byt_clr
.9c4f	 c8		iny			iny
.9c50	 ca		dex		        dex
.9c51	 d0 ef		bne $9c42	        bne  -
.9c53	 a0 09		ldy #$09	        ldy  #gap1-2    ; write  gcr bytes
.9c55	 2c 0f 18	bit $180f	-	bit  pota1
.9c58	 30 fb		bmi $9c55		bmi  -
.9c5a	 a9 55		lda #$55	        lda  #$55
.9c5c	 8d 01 1c	sta $1c01	        sta  data2
.9c5f	 2c 00 1c	bit $1c00		bit  byt_clr
.9c62	 88		dey			dey
.9c63	 d0 f0		bne $9c55	        bne  -
.9c65	 a9 ff		lda #$ff	        lda  #$ff       ; write data block sync
.9c67	 a0 05		ldy #$05	        ldy  #numsyn
.9c69	 2c 0f 18	bit $180f	-	bit  pota1
.9c6c	 30 fb		bmi $9c69		bmi  -
.9c6e	 8d 01 1c	sta $1c01	        sta  data2
.9c71	 2c 00 1c	bit $1c00		bit  byt_clr
.9c74	 88		dey			dey
.9c75	 d0 f2		bne $9c69	        bne  -
.9c77	 a0 bb		ldy #$bb	        ldy  #$bb       ; write out ovrbuf
.9c79	 2c 0f 18	bit $180f	-	bit  pota1
.9c7c	 30 fb		bmi $9c79		bmi  -
.9c7e	 b9 00 01	lda $0100,y	        lda  ovrbuf,y
.9c81	 8d 01 1c	sta $1c01	        sta  data2
.9c84	 2c 00 1c	bit $1c00		bit  byt_clr
.9c87	 c8		iny		        iny
.9c88	 d0 ef		bne $9c79	        bne  -
.9c8a	 2c 0f 18	bit $180f	-	bit  pota1
.9c8d	 30 fb		bmi $9c8a		bmi  -
.9c8f	 b1 30		lda ($30),y	        lda  (bufpnt),y
.9c91	 8d 01 1c	sta $1c01	        sta  data2
.9c94	 2c 00 1c	bit $1c00		bit  byt_clr
.9c97	 c8		iny		        iny
.9c98	 d0 f0		bne $9c8a	        bne - 
.9c9a	 a9 55		lda #$55	        lda  #$55       ; write gap2(dtrck)
.9c9c	 ac 26 06	ldy $0626	        ldy  dtrck
.9c9f	 2c 0f 18	bit $180f	-	bit  pota1
.9ca2	 30 fb		bmi $9c9f		bmi  -
.9ca4	 8d 01 1c	sta $1c01	        sta  data2
.9ca7	 2c 00 1c	bit $1c00		bit  byt_clr
.9caa	 88		dey		        dey
.9cab	 d0 f2		bne $9c9f	        bne  -
.9cad	 a5 1b		lda $1b		        lda  fmhdpt     ; advance header pointer
.9caf	 18		clc		        clc
.9cb0	 69 0a		adc #$0a	        adc  #10
.9cb2	 85 1b		sta $1b		        sta  fmhdpt
.9cb4	 ce 28 06	dec $0628	        dec  sect       ; go to next on
.9cb7	 f0 03		beq $9cbc	        beq  m15	; br, no more to do
.9cb9	 4c 2c 9c	jmp $9c2c	        jmp  m7
.9cbc	 2c 0f 18	bit $180f	m15	bit  pota1	; wait for last one to write
.9cbf	 30 fb		bmi $9cbc		bmi  m15
.9cc1	 2c 00 1c	bit $1c00		bit  byt_clr
.9cc4	 2c 0f 18	bit $180f	-	bit  pota1	;wait for last one to write
.9cc7	 30 fb		bmi $9cc4		bmi  -
.9cc9	 2c 00 1c	bit $1c00		bit  byt_clr
.9ccc	 20 00 fe	jsr $fe00	        jsr  kill       ; goto read mode

;******  Return to file "serlib.asm"

						.include "lccfmt3a.asm"

;******  Processing file "lccfmt3a.asm"

=9ccf					otunoteun = vfmt
.9ccf					vfmt
.9ccf	 a9 c8		lda #$c8		lda  #200       ;  look at 200 syncs
.9cd1	 8d 23 06	sta $0623	        sta  trys
.9cd4	 a9 00		lda #$00	m1	lda  #00
.9cd6	 85 1b		sta $1b		        sta  fmhdpt     ; start with first sector again
.9cd8	 a5 43		lda $43		        lda  sectr      ;  sector counter
.9cda	 8d 28 06	sta $0628	        sta  sect
.9cdd	 20 54 97	jsr $9754	m2	jsr  jsync      ;  find sync
.9ce0	 a2 0a		ldx #$0a		ldx  #10
.9ce2	 a4 1b		ldy $1b		        ldy  fmhdpt     ; current header pointer
.9ce4	 b1 32		lda ($32),y	m3	lda  (hdrpnt),y
.9ce6	 2c 0f 18	bit $180f	-	bit  pota1	;  get header byte
.9ce9	 30 fb		bmi $9ce6		bmi  -
.9ceb	 cd 01 1c	cmp $1c01	        cmp  data2
.9cee	 d0 0e		bne $9cfe	        bne  m5		; error
.9cf0	 c8		iny		        iny
.9cf1	 ca		dex		        dex
.9cf2	 d0 f0		bne $9ce4	        bne  m3		;  test all bytes
.9cf4	 18		clc		        clc     	; update headr pointer
.9cf5	 a5 1b		lda $1b		        lda  fmhdpt
.9cf7	 69 0a		adc #$0a	        adc  #10
.9cf9	 85 1b		sta $1b		        sta  fmhdpt
.9cfb	 4c 08 9d	jmp $9d08	        jmp  m6		;  now test data
.9cfe	 ce 23 06	dec $0623	m5	dec  trys       ;  test if too many errors
.9d01	 d0 d1		bne $9cd4	        bne  m1
.9d03	 a9 06		lda #$06	        lda  #notfnd    ;  too many error
.9d05	 4c 51 9d	jmp $9d51	        jmp  jfmterr
.9d08	 20 54 97	jsr $9754	m6	jsr  jsync      ;  find data sync
.9d0b	 a0 bb		ldy #$bb	        ldy  #256-topwrt
.9d0d	 b9 00 01	lda $0100,y	m7	lda  ovrbuf,y    ; ovr buff offset
.9d10	 2c 0f 18	bit $180f	-	bit  pota1
.9d13	 30 fb		bmi $9d10		bmi  -
.9d15	 cd 01 1c	cmp $1c01	        cmp  data2      ;  compare gcr
.9d18	 d0 e4		bne $9cfe	        bne  m5		; error
.9d1a	 c8		iny		        iny
.9d1b	 d0 f0		bne $9d0d	        bne  m7		;  do all ovrbuf
.9d1d	 b1 30		lda ($30),y	m9	lda  (bufpnt),y
.9d1f	 2c 0f 18	bit $180f	-	bit  pota1
.9d22	 30 fb		bmi $9d1f		bmi  -
.9d24	 cd 01 1c	cmp $1c01	        cmp  data2
.9d27	 d0 d5		bne $9cfe	        bne  m5
.9d29	 c8		iny		        iny
.9d2a	 d0 f1		bne $9d1d	        bne  m9
.9d2c	 ce 28 06	dec $0628	        dec  sect       ; more sectors to test?
.9d2f	 d0 ac		bne $9cdd	        bne  m2		; yes
.9d31	 e6 51		inc $51		        inc  ftnum      ;  goto next track
.9d33	 a5 51		lda $51		        lda  ftnum
.9d35	 2c b1 01	bit $01b1		bit  side 	;  what side are we on ?
.9d38	 30 03		bmi $9d3d		bmi  +
.9d3a	 c9 24		cmp #$24	        cmp  #36        ;  #tracks max

>9d3c	 2c                       		.byte skip2

.9d3d	 c9 47		cmp #$47	+	cmp  #71
.9d3f	 b0 03		bcs $9d44	        bcs  +
.9d41	 4c ca 99	jmp $99ca	        jmp  jend       ;  more to do
.9d44	 a9 ff		lda #$ff	+	lda  #$ff       ;  clear ftnum
.9d46	 85 51		sta $51		        sta  ftnum
.9d48	 a9 00		lda #$00	        lda  #$0        ;  clear gcr buffer flag
.9d4a	 85 50		sta $50		        sta  gcrflg
.9d4c	 a9 01		lda #$01	        lda  #1         ;  return ok code
.9d4e	 4c b5 99	jmp $99b5	        jmp  jerrr

;******  Return to file "serlib.asm"

					        .include "lccfmt4a.asm"

;******  Processing file "lccfmt4a.asm"

.9d51	 ce 20 06	dec $0620	jfmterr dec  cnt        ;  test for retry
.9d54	 f0 03		beq $9d59	        beq  jfmte10
.9d56	 4c ca 99	jmp $99ca	        jmp  jend
.9d59	 a0 ff		ldy #$ff	jfmte10 ldy  #$ff
.9d5b	 84 51		sty $51		        sty  ftnum      ;  clear format
.9d5d	 c8		iny		        iny
.9d5e	 84 50		sty $50		        sty  gcrflg
.9d60	 4c b5 99	jmp $99b5	        jmp  jerrr
.9d63	 ad 0c 1c	lda $1c0c	jclear  lda  pcr2	;  enable write
.9d66	 29 1f		and #$1f		and  #$ff-$e0   ;  wr mode=0
.9d68	 09 c0		ora #$c0		ora  #$c0
.9d6a	 8d 0c 1c	sta $1c0c		sta  pcr2
.9d6d	 a9 ff		lda #$ff	        lda  #$ff       ;  make port an output
.9d6f	 8d 03 1c	sta $1c03	        sta  ddra2      ;  clear pending
.9d72	 a9 55		lda #$55	        lda  #$55       ;  write a 1f pattern
.9d74	 a0 00		ldy #$00	        ldy  #00
.9d76	 2c 0f 18	bit $180f	-	bit  pota1
.9d79	 30 fb		bmi $9d76		bmi  -
.9d7b	 2c 00 1c	bit $1c00		bit  byt_clr
.9d7e	 8d 01 1c	sta $1c01	        sta  data2
.9d81	 88		dey		        dey
.9d82	 d0 f2		bne $9d76	        bne  -
.9d84	 ca		dex		        dex     	;  dex amount * 255
.9d85	 d0 ef		bne $9d76	        bne  -
.9d87	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "irq1541.asm"

;******  Processing file "irq1541.asm"

.9d88	 48		pha		irq	pha
.9d89	 8a		txa			txa
.9d8a	 48		pha			pha
.9d8b	 98		tya			tya
.9d8c	 48		pha			pha
.9d8d	 ad 0d 40	lda $400d		lda  icr
.9d90	 29 08		and #$08		and  #8
.9d92	 f0 26		beq $9dba		beq  +		; fast serial request
.9d94	 2c af 02	bit $02af		bit  lock	; locked ?
.9d97	 30 21		bmi $9dba		bmi  +
.9d99	 ad 0f 18	lda $180f		lda  pota1	; change to 2 Mhz
.9d9c	 09 20		ora #$20		ora  #$20
.9d9e	 8d 0f 18	sta $180f		sta  pota1
.9da1	 a9 de		lda #$de		lda  #<jirq
.9da3	 8d a9 02	sta $02a9		sta  irqjmp
.9da6	 a9 9d		lda #$9d		lda  #>jirq
.9da8	 8d aa 02	sta $02aa		sta  irqjmp+1	; re-vector irq
.9dab	 a9 40		lda #$40		lda  #tim2	; 8 ms irq's at 2 Mhz - controller irq's
.9dad	 8d 07 1c	sta $1c07		sta  t1hl2
.9db0	 8d 05 1c	sta $1c05		sta  t1hc2	; adjust timers for 2 Mhz
.9db3	 a9 00		lda #$00		lda  #0
.9db5	 85 62		sta $62			sta  nxtst	; not a vector
.9db7	 4c ea 9d	jmp $9dea		jmp  irq_0
.9dba	 ad 0d 18	lda $180d	+	lda  ifr1
.9dbd	 29 02		and #$02	        and  #2
.9dbf	 f0 03		beq $9dc4	        beq  +		;  not atn
.9dc1	 20 53 e8	jsr $e853	        jsr  atnirq     ;  handle atn request
.9dc4	 ad 0d 1c	lda $1c0d	+	lda  ifr2       ;  test if timer
.9dc7	 0a		asl a		        asl  a
.9dc8	 10 03		bpl $9dcd	        bpl  +		;  not timer
.9dca	 20 b0 f2	jsr $f2b0	        jsr  lcc        ;  goto controller
.9dcd	 ba		tsx		+ 	tsx
.9dce	 bd 04 01	lda $0104,x		lda  $0104,x	; check processor break flag
.9dd1	 29 10		and #$10		and  #$10
.9dd3	 f0 03		beq $9dd8		beq  +
.9dd5	 20 b0 f2	jsr $f2b0		jsr  lcc
.9dd8	 68		pla		+	pla     	; restore .y, .x, .a
.9dd9	 a8		tay		        tay
.9dda	 68		pla		        pla
.9ddb	 aa		tax		        tax
.9ddc	 68		pla		        pla
.9ddd	 40		rti		        rti

;******  Return to file "serlib.asm"

					        .include "irq1571.asm"

;******  Processing file "irq1571.asm"

.9dde	 48		pha		jirq	pha     	; save .a,.x,.y
.9ddf	 8a		txa		        txa
.9de0	 48		pha		        pha
.9de1	 98		tya		        tya
.9de2	 48		pha		        pha
.9de3	 ad 0d 40	lda $400d	        lda  icr	; chk for fast byte
.9de6	 29 08		and #$08		and  #8
.9de8	 f0 08		beq $9df2		beq  irq_1
.9dea	 a5 37		lda $37		irq_0	lda  fastsr
.9dec	 09 40		ora #$40	        ora  #$40       ; set byte in flag
.9dee	 85 37		sta $37		        sta  fastsr
.9df0	 d0 22		bne $9e14		bne  irq_2	; bra
.9df2	 ad 0d 18	lda $180d	irq_1	lda  ifr1	; test for atn
.9df5	 29 02		and #$02		and  #2
.9df7	 f0 07		beq $9e00		beq  +
.9df9	 2c 01 18	bit $1801		bit  pa1	; clear (ca1)
.9dfc	 a9 01		lda #$01		lda  #1         ; handle atn request
.9dfe	 85 7c		sta $7c		        sta  atnpnd     ; flag atn is pending
.9e00	 ba		tsx		+	tsx     	; check break flag
.9e01	 bd 04 01	lda $0104,x	        lda  $0104,x    ; check processor status
.9e04	 29 10		and #$10	        and  #$10
.9e06	 f0 03		beq $9e0b	        beq  +
.9e08	 20 ba 92	jsr $92ba	        jsr  jlcc       ; forced irq do controller job
.9e0b	 ad 0d 1c	lda $1c0d	+	lda  ifr2	; test if timer
.9e0e	 0a		asl a			asl  a
.9e0f	 10 03		bpl $9e14		bpl  +
.9e11	 20 ba 92	jsr $92ba	        jsr  jlcc       ; goto controller
.9e14					+
.9e14	 68		pla		irq_2	pla     	; restore .y,.x,.a
.9e15	 a8		tay		        tay
.9e16	 68		pla		        pla
.9e17	 aa		tax		        tax
.9e18	 68		pla		        pla
.9e19	 40		rti		        rti

;******  Return to file "serlib.asm"

						.include "gcr9.asm"

;******  Processing file "gcr9.asm"


>9f00	 ff                       	gcrtbh  .byte    $ff    ; -d
>9f01	 ff                       	        .byte    $ff    ; -c
>9f02	 ff                       	        .byte    $ff    ; -b
>9f03	 ff                       	        .byte    $ff    ; -a
>9f04	 ff                       	        .byte    $ff    ; -9
>9f05	 ff                       	        .byte    $ff    ; -8
>9f06	 ff                       	        .byte    $ff    ; -7
>9f07	 ff                       	        .byte    $ff    ; -6
>9f08	 ff                       	        .byte    $ff    ; -5
>9f09	 08                       	        .byte    $08    ; -4  h
>9f0a	 00                       		.byte    $00    ; -3  h
>9f0b	 01                       		.byte    $01    ; -2  h
>9f0c	 ff                       		.byte    $ff    ; -1
>9f0d	 0c                       	gcrtba  .byte    $0c    ; 0  h
>9f0e	 04                       	gcrtbf  .byte    $04    ; 1  h
>9f0f	 05                       	gcrtbd  .byte    $05    ; 2  h
>9f10	 ff                       		.byte    $ff    ; 4
>9f11	 ff                       		.byte    $ff	; 3
>9f12	 02                       		.byte    $02    ; 5  h
>9f13	 03                       		.byte    $03    ; 6  h
>9f14	 ff                       		.byte    $ff    ; 7
>9f15	 0f                       		.byte    $0f    ; 8  h
>9f16	 06                       		.byte    $06    ; 9  h
>9f17	 07                       		.byte    $07    ; a  h
>9f18	 ff                       		.byte    $ff    ; b
>9f19	 09                       		.byte    $09    ; c  h
>9f1a	 0a                       		.byte    $0a    ; d  h
>9f1b	 0b                       		.byte    $0b    ; e  h
>9f1c	 ff                       		.byte    $ff    ; f
>9f1d	 0d                       	gcrtbe  .byte    $0d    ; 10  h
>9f1e	 0e                       		.byte    $0e    ; 11  h
>9f1f	 80                       		.byte    $80    ; 12  c
>9f20	 ff                       		.byte    $ff    ; 13
>9f21	 00                       		.byte    $00    ; 14  c
>9f22	 00                       		.byte    $00    ; 15  e
>9f23	 10                       		.byte    $10    ; 16  c
>9f24	 40                       		.byte    $40    ; 17  e
>9f25	 ff                       		.byte    $ff    ; 18
>9f26	 20                       		.byte    $20    ; 19  e
>9f27	 c0                       		.byte    $c0    ; 1a  c
>9f28	 60                       		.byte    $60    ; 1b  e
>9f29	 40                       		.byte    $40    ; 1c  c
>9f2a	 a0                       	gcrtbg  .byte    $a0    ; 1d  e
>9f2b	 50                       		.byte    $50    ; 1e  c
>9f2c	 e0                       		.byte    $e0    ; 1f  e
>9f2d	 ff                       		.byte    $ff    ; 20
>9f2e	 ff                       		.byte    $ff    ; 21
>9f2f	 ff                       		.byte    $ff    ; 22
>9f30	 02                       		.byte    $02    ; 23  d
>9f31	 20                       		.byte    $20    ; 24  c
>9f32	 08                       		.byte    $08    ; 25  f
>9f33	 30                       		.byte    $30    ; 26  c
>9f34	 ff                       		.byte    $ff    ; 27
>9f35	 ff                       		.byte    $ff    ; 28
>9f36	 00                       	        .byte    $00    ; 29  f
>9f37	 f0                       		.byte    $f0    ; 2a  c
>9f38	 ff                       		.byte    $ff    ; 2b
>9f39	 60                       		.byte    $60    ; 2c  c
>9f3a	 01                       		.byte    $01    ; 2d  f
>9f3b	 70                       		.byte    $70    ; 2e  c
>9f3c	 ff                       		.byte    $ff    ; 2f
>9f3d	 ff                       		.byte    $ff    ; 30
>9f3e	 ff                       		.byte    $ff    ; 31
>9f3f	 90                       		.byte    $90    ; 32  c
>9f40	 03                       		.byte    $03    ; 33  d
>9f41	 a0                       		.byte    $a0    ; 34  c
>9f42	 0c                       		.byte    $0c    ; 35  f
>9f43	 b0                       		.byte    $b0    ; 36  c
>9f44	 ff                       		.byte    $ff    ; 37
>9f45	 ff                       		.byte    $ff    ; 38
>9f46	 04                       		.byte    $04    ; 39  f
>9f47	 d0                       		.byte    $d0    ; 3a  c
>9f48	 ff                       		.byte    $ff    ; 3b
>9f49	 e0                       		.byte    $e0    ; 3c  c
>9f4a	 05                       		.byte    $05    ; 3d  f
>9f4b	 80                       		.byte    $80    ; 3e  g
>9f4c	 ff                       		.byte    $ff    ; 3f
>9f4d	 90                       		.byte    $90    ; 40  g
>9f4e	 ff                       		.byte    $ff    ; 41
>9f4f	 08                       		.byte    $08    ; 42  b
>9f50	 0c                       		.byte    $0c    ; 43  b
>9f51	 ff                       		.byte    $ff    ; 44
>9f52	 0f                       		.byte    $0f    ; 45  b
>9f53	 09                       		.byte    $09    ; 46  b
>9f54	 0d                       		.byte    $0d    ; 47  b
>9f55	 80                       		.byte    $80    ; 48  a
>9f56	 02                       		.byte    $02    ; 49  f
>9f57	 ff                       		.byte    $ff    ; 4a
>9f58	 ff                       		.byte    $ff    ; 4b
>9f59	 ff                       		.byte    $ff    ; 4c
>9f5a	 03                       		.byte    $03    ; 4d  f
>9f5b	 ff                       		.byte    $ff    ; 4e
>9f5c	 ff                       		.byte    $ff    ; 4f
>9f5d	 00                       		.byte    $00    ; 50  a
>9f5e	 ff                       		.byte    $ff    ; 51
>9f5f	 ff                       		.byte    $ff    ; 52
>9f60	 0f                       		.byte    $0f    ; 53  d
>9f61	 ff                       		.byte    $ff    ; 54
>9f62	 0f                       		.byte    $0f    ; 55  f
>9f63	 ff                       		.byte    $ff    ; 56
>9f64	 ff                       		.byte    $ff    ; 57
>9f65	 10                       		.byte    $10    ; 58  a
>9f66	 06                       		.byte    $06    ; 59  f
>9f67	 ff                       		.byte    $ff    ; 5a
>9f68	 ff                       		.byte    $ff    ; 5b
>9f69	 ff                       		.byte    $ff    ; 5c
>9f6a	 07                       		.byte    $07    ; 5d  f
>9f6b	 00                       		.byte    $00    ; 5e  g
>9f6c	 20                       		.byte    $20    ; 5f  g
>9f6d	 a0                       		.byte    $a0    ; 60  g
>9f6e	 ff                       		.byte    $ff    ; 61
>9f6f	 ff                       		.byte    $ff    ; 62
>9f70	 06                       		.byte    $06    ; 63  d
>9f71	 ff                       		.byte    $ff    ; 64
>9f72	 09                       		.byte    $09    ; 65  f
>9f73	 ff                       		.byte    $ff    ; 66
>9f74	 ff                       		.byte    $ff    ; 67
>9f75	 c0                       		.byte    $c0    ; 68  a
>9f76	 0a                       		.byte    $0a    ; 69  f
>9f77	 ff                       		.byte    $ff    ; 6a
>9f78	 ff                       		.byte    $ff    ; 6b
>9f79	 ff                       		.byte    $ff    ; 6c
>9f7a	 0b                       		.byte    $0b    ; 6d  f
>9f7b	 ff                       		.byte    $ff    ; 6e
>9f7c	 ff                       		.byte    $ff    ; 6f
>9f7d	 40                       		.byte    $40    ; 70  a
>9f7e	 ff                       		.byte    $ff    ; 71
>9f7f	 ff                       		.byte    $ff    ; 72
>9f80	 07                       		.byte    $07    ; 73  d
>9f81	 ff                       		.byte    $ff    ; 74
>9f82	 0d                       		.byte    $0d    ; 75  f
>9f83	 ff                       		.byte    $ff    ; 76
>9f84	 ff                       		.byte    $ff    ; 77
>9f85	 50                       		.byte    $50    ; 78  a
>9f86	 0e                       		.byte    $0e    ; 79  f
>9f87	 ff                       		.byte    $ff	; 7a
>9f88	 ff                       		.byte    $ff	; 7b
>9f89	 ff                       		.byte    $ff	; 7c
>9f8a	 ff                       		.byte    $ff	; 7d
>9f8b	 10                       		.byte    $10    ; 7e  g
>9f8c	 30                       		.byte    $30    ; 7f  g
>9f8d	 b0                       		.byte    $b0    ; 80  g
>9f8e	 ff                       		.byte    $ff    ; 81
>9f8f	 00                       		.byte    $00    ; 82  b
>9f90	 04                       		.byte    $04    ; 83  b
>9f91	 02                       		.byte    $02    ; 84  b
>9f92	 06                       		.byte    $06    ; 85  b
>9f93	 0a                       		.byte    $0a    ; 86  b
>9f94	 0e                       		.byte    $0e    ; 87  b
>9f95	 80                       		.byte    $80    ; 88  a
>9f96	 ff                       		.byte    $ff    ; 89
>9f97	 ff                       		.byte    $ff    ; 8a
>9f98	 ff                       		.byte    $ff    ; 8b
>9f99	 ff                       		.byte    $ff    ; 8c
>9f9a	 ff                       		.byte    $ff    ; 8d
>9f9b	 ff                       		.byte    $ff    ; 8e
>9f9c	 ff                       		.byte    $ff    ; 8f
>9f9d	 20                       		.byte    $20    ; 90  a
>9f9e	 ff                       		.byte    $ff    ; 91
>9f9f	 08                       		.byte    $08    ; 92  d
>9fa0	 09                       		.byte    $09    ; 93  d
>9fa1	 80                       		.byte    $80    ; 94  e
>9fa2	 10                       		.byte    $10    ; 95  e
>9fa3	 c0                       		.byte    $c0    ; 96  e
>9fa4	 50                       		.byte    $50    ; 97  e
>9fa5	 30                       		.byte    $30    ; 98  a
>9fa6	 30                       		.byte    $30    ; 99  e
>9fa7	 f0                       		.byte    $f0    ; 9a  e
>9fa8	 70                       		.byte    $70    ; 9b  e
>9fa9	 90                       		.byte    $90    ; 9c  e
>9faa	 b0                       		.byte    $b0    ; 9d  e
>9fab	 d0                       		.byte    $d0    ; 9e  e
>9fac	 ff                       		.byte    $ff    ; 9f
>9fad	 ff                       		.byte    $ff    ; a0
>9fae	 ff                       		.byte    $ff    ; a1
>9faf	 00                       		.byte    $00    ; a2  d
>9fb0	 0a                       		.byte    $0a    ; a3  d
>9fb1	 ff                       		.byte    $ff    ; a4
>9fb2	 ff                       		.byte    $ff    ; a5
>9fb3	 ff                       		.byte    $ff    ; a6
>9fb4	 ff                       		.byte    $ff    ; a7
>9fb5	 f0                       		.byte    $f0    ; a8  a

.9fb6	 00		brk		stbctl  brk     	; a9  *** start code stbctl
.9fb7	 ea		nop		        nop     	; aa
.9fb8	 b5 00		lda $00,x	stbknt  lda  $00,x      ; ab,ac
.9fba	 30 fc		bmi $9fb8	        bmi  stbknt     ; ad,ae
.9fbc	 60		rts		        rts     	; af  *** end code stbctl

>9fbd	 60                       		.byte    $60    ; b0  a
>9fbe	 ff                       		.byte    $ff    ; b1
>9fbf	 01                       		.byte    $01    ; b2  d
>9fc0	 0b                       		.byte    $0b    ; b3  d
>9fc1	 ff                       		.byte    $ff    ; b4
>9fc2	 ff                       		.byte    $ff    ; b5
>9fc3	 ff                       		.byte    $ff    ; b6
>9fc4	 ff                       		.byte    $ff    ; b7
>9fc5	 70                       		.byte    $70    ; b8  a
>9fc6	 ff                       		.byte    $ff    ; b9
>9fc7	 ff                       		.byte    $ff    ; ba
>9fc8	 ff                       		.byte    $ff    ; bb
>9fc9	 ff                       		.byte    $ff    ; bc
>9fca	 ff                       		.byte    $ff    ; bd
>9fcb	 c0                       		.byte    $c0    ; be  g
>9fcc	 f0                       		.byte    $f0    ; bf  g
>9fcd	 d0                       		.byte    $d0    ; c0  g
>9fce	 ff                       		.byte    $ff    ; c1
>9fcf	 01                       		.byte    $01    ; c2  b
>9fd0	 05                       		.byte    $05    ; c3  b
>9fd1	 03                       		.byte    $03    ; c4  b
>9fd2	 07                       		.byte    $07    ; c5  b
>9fd3	 0b                       		.byte    $0b    ; c6  b
>9fd4	 ff                       		.byte    $ff    ; c7
>9fd5	 90                       		.byte    $90    ; c8  a
>9fd6	 ff                       		.byte    $ff    ; c9
>9fd7	 ff                       		.byte    $ff    ; ca
>9fd8	 ff                       		.byte    $ff    ; cb
>9fd9	 ff                       		.byte    $ff    ; cc
>9fda	 ff                       		.byte    $ff    ; cd
>9fdb	 ff                       		.byte    $ff    ; ce
>9fdc	 ff                       		.byte    $ff    ; cf
>9fdd	 a0                       		.byte    $a0    ; d0  a
>9fde	 ff                       		.byte    $ff    ; d1
>9fdf	 0c                       		.byte    $0c    ; d2  d
>9fe0	 0d                       		.byte    $0d    ; d3  d
>9fe1	 ff                       		.byte    $ff    ; d4
>9fe2	 ff                       		.byte    $ff    ; d5
>9fe3	 ff                       		.byte    $ff    ; d6
>9fe4	 ff                       		.byte    $ff    ; d7
>9fe5	 b0                       		.byte    $b0    ; d8  a
>9fe6	 ff                       		.byte    $ff    ; d9
>9fe7	 ff                       		.byte    $ff    ; da
>9fe8	 ff                       		.byte    $ff    ; db
>9fe9	 ff                       		.byte    $ff    ; dc
>9fea	 ff                       		.byte    $ff    ; dd
>9feb	 40                       		.byte    $40    ; de  g
>9fec	 60                       		.byte    $60    ; df  g
>9fed	 e0                       		.byte    $e0    ; e0  g
>9fee	 ff                       		.byte    $ff    ; e1
>9fef	 04                       		.byte    $04    ; e2  d
>9ff0	 0e                       		.byte    $0e    ; e3  d
>9ff1	 ff                       		.byte    $ff    ; e4
>9ff2	 ff                       		.byte    $ff    ; e5
>9ff3	 ff                       		.byte    $ff    ; e6
>9ff4	 ff                       		.byte    $ff    ; e7
>9ff5	 d0                       		.byte    $d0    ; e8  a
>9ff6	 ff                       		.byte    $ff    ; e9
>9ff7	 ff                       		.byte    $ff    ; ea
>9ff8	 ff                       		.byte    $ff    ; eb
>9ff9	 ff                       		.byte    $ff    ; ec
>9ffa	 ff                       		.byte    $ff    ; ed
>9ffb	 ff                       		.byte    $ff    ; ee
>9ffc	 ff                       		.byte    $ff    ; ef
>9ffd	 e0                       		.byte    $e0    ; f0  a
>9ffe	 ff                       		.byte    $ff    ; f1
>9fff	 05                       		.byte    $05    ; f2  d
>a000	 ff                       		.byte    $ff    ; f3
>a001	 ff                       		.byte    $ff    ; f4
>a002	 ff                       		.byte    $ff    ; f5
>a003	 ff                       		.byte    $ff    ; f6
>a004	 ff                       		.byte    $ff    ; f7
>a005	 ff                       		.byte    $ff    ; f8
>a006	 ff                       		.byte    $ff    ; f9
>a007	 ff                       		.byte    $ff    ; fa
>a008	 ff                       		.byte    $ff    ; fb
>a009	 ff                       		.byte    $ff    ; fc
>a00a	 ff                       		.byte    $ff    ; fd
>a00b	 50                       	 	.byte    $50    ; fe  g
>a00c	 70                       		.byte    $70    ; ff  g

;******  Return to file "serlib.asm"

						.include "gcr10.asm"

;******  Processing file "gcr10.asm"

>a00d	 0c                       	gcrtb1	.byte    $0c    ; 0
>a00e	 04                       		.byte    $04    ; 1
>a00f	 05                       		.byte    $05    ; 2
>a010	 ff                       		.byte    $ff    ; 3
>a011	 ff                       		.byte    $ff    ; 4
>a012	 02                       		.byte    $02    ; 5
>a013	 03                       		.byte    $03    ; 6
>a014	 ff                       		.byte    $ff    ; 7
>a015	 0f                       		.byte    $0f    ; 8
>a016	 06                       		.byte    $06    ; 9
>a017	 07                       		.byte    $07    ; a
>a018	 ff                       		.byte    $ff    ; b
>a019	 09                       		.byte    $09    ; c
>a01a	 0a                       		.byte    $0a    ; d
>a01b	 0b                       		.byte    $0b    ; e
>a01c	 ff                       		.byte    $ff    ; f
>a01d	 0d                       		.byte    $0d    ; 10
>a01e	 0e                       		.byte    $0e    ; 11
>a01f	 80                       		.byte    $80    ; 12
>a020	 ff                       		.byte    $ff    ; 13
>a021	 00                       		.byte    $00    ; 14
>a022	 00                       		.byte    $00    ; 15
>a023	 10                       		.byte    $10    ; 16
>a024	 40                       		.byte    $40    ; 17
>a025	 ff                       		.byte    $ff    ; 18
>a026	 20                       		.byte    $20    ; 19
>a027	 c0                       		.byte    $c0    ; 1a
>a028	 60                       		.byte    $60    ; 1b
>a029	 40                       		.byte    $40    ; 1c
>a02a	 a0                       		.byte    $a0    ; 1d
>a02b	 50                       		.byte    $50    ; 1e
>a02c	 e0                       		.byte    $e0    ; 1f
>a02d	 ff                       		.byte    $ff    ; 20
>a02e	 ff                       		.byte    $ff    ; 21
>a02f	 ff                       		.byte    $ff    ; 22
>a030	 02                       		.byte    $02    ; 23
>a031	 20                       		.byte    $20    ; 24
>a032	 08                       		.byte    $08    ; 25
>a033	 30                       		.byte    $30    ; 26
>a034	 30                       		.byte    $30    ; 27
>a035	 30                       		.byte    $30    ; 28
>a036	 00                       		.byte    $00    ; 29
>a037	 f0                       		.byte    $f0    ; 2a
>a038	 ff                       		.byte    $ff    ; 2b
>a039	 60                       		.byte    $60    ; 2c
>a03a	 01                       		.byte    $01    ; 2d
>a03b	 70                       		.byte    $70    ; 2e
>a03c	 ff                       		.byte    $ff    ; 2f
>a03d	 ff                       		.byte    $ff    ; 30
>a03e	 ff                       		.byte    $ff    ; 31
>a03f	 90                       		.byte    $90    ; 32
>a040	 03                       		.byte    $03    ; 33
>a041	 a0                       		.byte    $a0    ; 34
>a042	 0c                       		.byte    $0c    ; 35
>a043	 b0                       		.byte    $b0    ; 36
>a044	 ff                       		.byte    $ff    ; 37
>a045	 ff                       		.byte    $ff    ; 38
>a046	 04                       		.byte    $04    ; 39
>a047	 d0                       		.byte    $d0    ; 3a
>a048	 ff                       		.byte    $ff    ; 3b
>a049	 e0                       		.byte    $e0    ; 3c
>a04a	 05                       		.byte    $05    ; 3d
>a04b	 80                       		.byte    $80    ; 3e
>a04c	 ff                       		.byte    $ff    ; 3f
>a04d	 90                       		.byte    $90    ; 40
>a04e	 ff                       		.byte    $ff    ; 41
>a04f	 08                       		.byte    $08    ; 42
>a050	 0c                       		.byte    $0c    ; 43
>a051	 ff                       		.byte    $ff    ; 44
>a052	 0f                       		.byte    $0f    ; 45
>a053	 09                       		.byte    $09    ; 46
>a054	 0d                       		.byte    $0d    ; 47
>a055	 80                       		.byte    $80    ; 48
>a056	 80                       		.byte    $80    ; 49
>a057	 80                       		.byte    $80    ; 4a
>a058	 80                       		.byte    $80    ; 4b
>a059	 80                       		.byte    $80    ; 4c
>a05a	 80                       		.byte    $80    ; 4d
>a05b	 80                       		.byte    $80    ; 4e
>a05c	 80                       		.byte    $80    ; 4f
>a05d	 00                       		.byte    $00    ; 50
>a05e	 00                       		.byte    $00    ; 51
>a05f	 00                       		.byte    $00    ; 52
>a060	 00                       		.byte    $00    ; 53
>a061	 00                       		.byte    $00    ; 54
>a062	 00                       		.byte    $00    ; 55
>a063	 00                       		.byte    $00    ; 56
>a064	 00                       		.byte    $00    ; 57
>a065	 10                       		.byte    $10    ; 58
>a066	 10                       		.byte    $10    ; 59
>a067	 10                       		.byte    $10    ; 5a
>a068	 10                       		.byte    $10    ; 5b
>a069	 10                       		.byte    $10    ; 5c
>a06a	 10                       		.byte    $10    ; 5d
>a06b	 10                       		.byte    $10    ; 5e
>a06c	 10                       		.byte    $10    ; 5f
>a06d	 a0                       		.byte    $a0    ; 60
>a06e	 ff                       		.byte    $ff    ; 61
>a06f	 ff                       		.byte    $ff    ; 62
>a070	 06                       		.byte    $06    ; 63
>a071	 ff                       		.byte    $ff    ; 64
>a072	 09                       		.byte    $09    ; 65
>a073	 ff                       		.byte    $ff    ; 66
>a074	 ff                       		.byte    $ff    ; 67
>a075	 c0                       		.byte    $c0    ; 68
>a076	 c0                       		.byte    $c0    ; 69
>a077	 c0                       		.byte    $c0    ; 6a
>a078	 c0                       		.byte    $c0    ; 6b
>a079	 c0                       		.byte    $c0    ; 6c
>a07a	 c0                       		.byte    $c0    ; 6d
>a07b	 c0                       		.byte    $c0    ; 6e
>a07c	 c0                       		.byte    $c0    ; 6f
>a07d	 40                       		.byte    $40    ; 70
>a07e	 40                       		.byte    $40    ; 71
>a07f	 40                       		.byte    $40    ; 72
>a080	 40                       		.byte    $40    ; 73
>a081	 40                       		.byte    $40    ; 74
>a082	 40                       		.byte    $40    ; 75
>a083	 40                       		.byte    $40    ; 76
>a084	 40                       		.byte    $40    ; 77
>a085	 50                       		.byte    $50    ; 78
>a086	 50                       		.byte    $50    ; 79
>a087	 50                       		.byte    $50    ; 7a
>a088	 50                       		.byte    $50    ; 7b
>a089	 50                       		.byte    $50    ; 7c
>a08a	 50                       		.byte    $50    ; 7d
>a08b	 50                       		.byte    $50    ; 7e
>a08c	 50                       		.byte    $50    ; 7f
>a08d	 b0                       		.byte    $b0    ; 80
>a08e	 ff                       		.byte    $ff    ; 81
>a08f	 00                       		.byte    $00    ; 82
>a090	 04                       		.byte    $04    ; 83
>a091	 02                       		.byte    $02    ; 84
>a092	 06                       		.byte    $06    ; 85
>a093	 0a                       		.byte    $0a    ; 86
>a094	 0e                       		.byte    $0e    ; 87
>a095	 80                       		.byte    $80    ; 88
>a096	 80                       		.byte    $80    ; 89
>a097	 80                       		.byte    $80    ; 8a
>a098	 80                       		.byte    $80    ; 8b
>a099	 80                       		.byte    $80    ; 8c
>a09a	 80                       		.byte    $80    ; 8d
>a09b	 80                       		.byte    $80    ; 8e
>a09c	 80                       		.byte    $80    ; 8f
>a09d	 20                       		.byte    $20    ; 90
>a09e	 20                       		.byte    $20    ; 91
>a09f	 20                       		.byte    $20    ; 92
>a0a0	 20                       		.byte    $20    ; 93
>a0a1	 20                       		.byte    $20    ; 94
>a0a2	 20                       		.byte    $20    ; 95
>a0a3	 20                       		.byte    $20    ; 96
>a0a4	 20                       		.byte    $20    ; 97
>a0a5	 30                       		.byte    $30    ; 98
>a0a6	 30                       		.byte    $30    ; 99
>a0a7	 30                       		.byte    $30    ; 9a
>a0a8	 30                       		.byte    $30    ; 9b
>a0a9	 30                       		.byte    $30    ; 9c
>a0aa	 30                       		.byte    $30    ; 9d
>a0ab	 30                       		.byte    $30    ; 9e
>a0ac	 30                       		.byte    $30    ; 9f
>a0ad	 ff                       		.byte    $ff    ; a0
>a0ae	 ff                       		.byte    $ff    ; a1
>a0af	 00                       		.byte    $00    ; a2
>a0b0	 0a                       		.byte    $0a    ; a3
>a0b1	 0a                       		.byte    $0a    ; a4
>a0b2	 0a                       		.byte    $0a    ; a5
>a0b3	 0a                       		.byte    $0a    ; a6
>a0b4	 0a                       		.byte    $0a    ; a7
>a0b5	 f0                       		.byte    $f0    ; a8
>a0b6	 f0                       		.byte    $f0    ; a9
>a0b7	 f0                       		.byte    $f0    ; aa
>a0b8	 f0                       		.byte    $f0    ; ab
>a0b9	 f0                       		.byte    $f0    ; ac
>a0ba	 f0                       		.byte    $f0    ; ad
>a0bb	 f0                       		.byte    $f0    ; ae
>a0bc	 f0                       		.byte    $f0    ; af
>a0bd	 60                       		.byte    $60    ; b0
>a0be	 60                       		.byte    $60    ; b1
>a0bf	 60                       		.byte    $60    ; b2
>a0c0	 60                       		.byte    $60    ; b3
>a0c1	 60                       		.byte    $60    ; b4
>a0c2	 60                       		.byte    $60    ; b5
>a0c3	 60                       		.byte    $60    ; b6
>a0c4	 60                       		.byte    $60    ; b7
>a0c5	 70                       		.byte    $70    ; b8
>a0c6	 70                       		.byte    $70    ; b9
>a0c7	 70                       		.byte    $70    ; ba
>a0c8	 70                       		.byte    $70    ; bb
>a0c9	 70                       		.byte    $70    ; bc
>a0ca	 70                       		.byte    $70    ; bd
>a0cb	 70                       		.byte    $70    ; be
>a0cc	 70                       		.byte    $70    ; bf
>a0cd	 d0                       		.byte    $d0    ; c0
>a0ce	 ff                       		.byte    $ff    ; c1
>a0cf	 01                       		.byte    $01    ; c2
>a0d0	 05                       		.byte    $05    ; c3
>a0d1	 03                       		.byte    $03    ; c4
>a0d2	 07                       		.byte    $07    ; c5
>a0d3	 0b                       		.byte    $0b    ; c6
>a0d4	 ff                       		.byte    $ff    ; c7
>a0d5	 90                       		.byte    $90    ; c8
>a0d6	 90                       		.byte    $90    ; c9
>a0d7	 90                       		.byte    $90    ; ca
>a0d8	 90                       		.byte    $90    ; cb
>a0d9	 90                       		.byte    $90    ; cc
>a0da	 90                       		.byte    $90    ; cd
>a0db	 90                       		.byte    $90    ; ce
>a0dc	 90                       		.byte    $90    ; cf
>a0dd	 a0                       		.byte    $a0    ; d0
>a0de	 a0                       		.byte    $a0    ; d1
>a0df	 a0                       		.byte    $a0    ; d2
>a0e0	 a0                       		.byte    $a0    ; d3
>a0e1	 a0                       		.byte    $a0    ; d4
>a0e2	 a0                       		.byte    $a0    ; d5
>a0e3	 a0                       		.byte    $a0    ; d6
>a0e4	 a0                       		.byte    $a0    ; d7
>a0e5	 b0                       		.byte    $b0    ; d8
>a0e6	 b0                       		.byte    $b0    ; d9
>a0e7	 b0                       		.byte    $b0    ; da
>a0e8	 b0                       		.byte    $b0    ; db
>a0e9	 b0                       		.byte    $b0    ; dc
>a0ea	 b0                       		.byte    $b0    ; dd
>a0eb	 b0                       		.byte    $b0    ; de
>a0ec	 b0                       		.byte    $b0    ; df
>a0ed	 e0                       		.byte    $e0    ; e0
>a0ee	 ff                       		.byte    $ff    ; e1
>a0ef	 04                       		.byte    $04    ; e2
>a0f0	 0e                       		.byte    $0e    ; e3
>a0f1	 ff                       		.byte    $ff    ; e4
>a0f2	 ff                       		.byte    $ff    ; e5
>a0f3	 ff                       		.byte    $ff    ; e6
>a0f4	 ff                       		.byte    $ff    ; e7
>a0f5	 d0                       		.byte    $d0    ; e8
>a0f6	 d0                       		.byte    $d0    ; e9
>a0f7	 d0                       		.byte    $d0    ; ea
>a0f8	 d0                       		.byte    $d0    ; eb
>a0f9	 d0                       		.byte    $d0    ; ec
>a0fa	 d0                       		.byte    $d0    ; ed
>a0fb	 d0                       		.byte    $d0    ; ee
>a0fc	 d0                       		.byte    $d0    ; ef
>a0fd	 e0                       		.byte    $e0    ; f0
>a0fe	 e0                       		.byte    $e0    ; f1
>a0ff	 e0                       		.byte    $e0    ; f2
>a100	 e0                       		.byte    $e0    ; f3
>a101	 e0                       		.byte    $e0    ; f4
>a102	 e0                       		.byte    $e0    ; f5
>a103	 e0                       		.byte    $e0    ; f6
>a104	 e0                       		.byte    $e0    ; f7
>a105	 05                       		.byte    $05    ; f8
>a106	 05                       		.byte    $05    ; f9
>a107	 05                       		.byte    $05    ; fa
>a108	 05                       		.byte    $05    ; fb
>a109	 05                       		.byte    $05    ; fc
>a10a	 05                       		.byte    $05    ; fd
>a10b	 50                       		.byte    $50    ; fe
>a10c	 70                       		.byte    $70    ; ff

;******  Return to file "serlib.asm"

						.include "gcrtable.asm"

;******  Processing file "gcrtable.asm"

>a10d	 ff                       	gcrtb2  .byte    $ff    ; 0
>a10e	 ff                       		.byte    $ff    ; 1
>a10f	 ff                       		.byte    $ff    ; 2
>a110	 ff                       		.byte    $ff    ; 3
>a111	 ff                       		.byte    $ff    ; 4
>a112	 ff                       		.byte    $ff    ; 5
>a113	 ff                       		.byte    $ff    ; 6
>a114	 ff                       		.byte    $ff    ; 7
>a115	 ff                       		.byte    $ff    ; 8
>a116	 ff                       		.byte    $ff    ; 9
>a117	 ff                       		.byte    $ff    ; a
>a118	 ff                       		.byte    $ff    ; b
>a119	 ff                       		.byte    $ff    ; c
>a11a	 ff                       		.byte    $ff    ; d
>a11b	 ff                       		.byte    $ff    ; e
>a11c	 ff                       		.byte    $ff    ; f
>a11d	 ff                       		.byte    $ff    ; 10
>a11e	 ff                       		.byte    $ff    ; 11
>a11f	 80                       		.byte    $80    ; 12
>a120	 80                       		.byte    $80    ; 13
>a121	 00                       		.byte    $00    ; 14
>a122	 00                       		.byte    $00    ; 15
>a123	 10                       		.byte    $10    ; 16
>a124	 10                       		.byte    $10    ; 17
>a125	 ff                       		.byte    $ff    ; 18
>a126	 ff                       		.byte    $ff    ; 19
>a127	 c0                       		.byte    $c0    ; 1a
>a128	 c0                       		.byte    $c0    ; 1b
>a129	 40                       		.byte    $40    ; 1c
>a12a	 40                       		.byte    $40    ; 1d
>a12b	 50                       		.byte    $50    ; 1e
>a12c	 50                       		.byte    $50    ; 1f
>a12d	 ff                       		.byte    $ff    ; 20
>a12e	 ff                       		.byte    $ff    ; 21
>a12f	 ff                       		.byte    $ff    ; 22
>a130	 ff                       		.byte    $ff    ; 23
>a131	 20                       		.byte    $20    ; 24
>a132	 20                       		.byte    $20    ; 25
>a133	 30                       		.byte    $30    ; 26
>a134	 30                       		.byte    $30    ; 27
>a135	 ff                       		.byte    $ff    ; 28
>a136	 ff                       	        .byte    $ff    ; 29
>a137	 f0                       		.byte    $f0    ; 2a
>a138	 f0                       		.byte    $f0    ; 2b
>a139	 60                       		.byte    $60    ; 2c
>a13a	 60                       		.byte    $60    ; 2d
>a13b	 70                       		.byte    $70    ; 2e
>a13c	 70                       		.byte    $70    ; 2f
>a13d	 ff                       		.byte    $ff    ; 30
>a13e	 ff                       		.byte    $ff    ; 31
>a13f	 90                       		.byte    $90    ; 32
>a140	 90                       		.byte    $90    ; 33
>a141	 a0                       		.byte    $a0    ; 34
>a142	 a0                       		.byte    $a0    ; 35
>a143	 b0                       		.byte    $b0    ; 36
>a144	 b0                       		.byte    $b0    ; 37
>a145	 ff                       		.byte    $ff    ; 38
>a146	 ff                       		.byte    $ff    ; 39
>a147	 d0                       		.byte    $d0    ; 3a
>a148	 d0                       		.byte    $d0    ; 3b
>a149	 e0                       		.byte    $e0    ; 3c
>a14a	 e0                       		.byte    $e0    ; 3d
>a14b	 ff                       		.byte    $ff    ; 3e
>a14c	 ff                       		.byte    $ff    ; 3f
>a14d	 ff                       		.byte    $ff    ; 40
>a14e	 ff                       		.byte    $ff    ; 41
>a14f	 ff                       		.byte    $ff    ; 42
>a150	 ff                       		.byte    $ff    ; 43
>a151	 ff                       		.byte    $ff    ; 44
>a152	 ff                       		.byte    $ff    ; 45
>a153	 ff                       		.byte    $ff    ; 46
>a154	 ff                       		.byte    $ff    ; 47
>a155	 ff                       		.byte    $ff    ; 48
>a156	 ff                       		.byte    $ff    ; 49
>a157	 ff                       		.byte    $ff    ; 4a
>a158	 ff                       		.byte    $ff    ; 4b
>a159	 ff                       		.byte    $ff    ; 4c
>a15a	 ff                       		.byte    $ff    ; 4d
>a15b	 ff                       		.byte    $ff    ; 4e
>a15c	 ff                       		.byte    $ff    ; 4f
>a15d	 ff                       		.byte    $ff    ; 50
>a15e	 ff                       		.byte    $ff    ; 51
>a15f	 80                       		.byte    $80    ; 52
>a160	 80                       		.byte    $80    ; 53
>a161	 00                       		.byte    $00    ; 54
>a162	 00                       		.byte    $00    ; 55
>a163	 10                       		.byte    $10    ; 56
>a164	 10                       		.byte    $10    ; 57
>a165	 ff                       		.byte    $ff    ; 58
>a166	 ff                       		.byte    $ff    ; 59
>a167	 c0                       		.byte    $c0    ; 5a
>a168	 c0                       		.byte    $c0    ; 5b
>a169	 40                       		.byte    $40    ; 5c
>a16a	 40                       		.byte    $40    ; 5d
>a16b	 50                       		.byte    $50    ; 5e
>a16c	 50                       		.byte    $50    ; 5f
>a16d	 ff                       		.byte    $ff    ; 60
>a16e	 ff                       		.byte    $ff    ; 61
>a16f	 ff                       		.byte    $ff    ; 62
>a170	 ff                       		.byte    $ff    ; 63
>a171	 20                       		.byte    $20    ; 64
>a172	 20                       		.byte    $20    ; 65
>a173	 30                       		.byte    $30    ; 66
>a174	 30                       		.byte    $30    ; 67
>a175	 ff                       		.byte    $ff    ; 68
>a176	 ff                       		.byte    $ff    ; 69
>a177	 f0                       		.byte    $f0    ; 6a
>a178	 f0                       		.byte    $f0    ; 6b
>a179	 60                       		.byte    $60    ; 6c
>a17a	 60                       		.byte    $60    ; 6d
>a17b	 70                       		.byte    $70    ; 6e
>a17c	 70                       		.byte    $70    ; 6f
>a17d	 ff                       		.byte    $ff    ; 70
>a17e	 ff                       		.byte    $ff    ; 71
>a17f	 90                       		.byte    $90    ; 72
>a180	 90                       		.byte    $90    ; 73
>a181	 a0                       		.byte    $a0    ; 74
>a182	 a0                       		.byte    $a0    ; 75
>a183	 b0                       		.byte    $b0    ; 76
>a184	 b0                       		.byte    $b0    ; 77
>a185	 ff                       		.byte    $ff    ; 78
>a186	 ff                       		.byte    $ff    ; 79
>a187	 d0                       		.byte    $d0    ; 7a
>a188	 d0                       		.byte    $d0    ; 7b
>a189	 e0                       		.byte    $e0    ; 7c
>a18a	 e0                       		.byte    $e0    ; 7d
>a18b	 ff                       		.byte    $ff    ; 7e
>a18c	 ff                       		.byte    $ff    ; 7f
>a18d	 ff                       		.byte    $ff    ; 80
>a18e	 ff                       		.byte    $ff    ; 81
>a18f	 ff                       		.byte    $ff    ; 82
>a190	 ff                       		.byte    $ff    ; 83
>a191	 ff                       		.byte    $ff    ; 84
>a192	 ff                       		.byte    $ff    ; 85
>a193	 ff                       		.byte    $ff    ; 86
>a194	 ff                       		.byte    $ff    ; 87
>a195	 ff                       		.byte    $ff    ; 88
>a196	 ff                       		.byte    $ff    ; 89
>a197	 ff                       		.byte    $ff    ; 8a
>a198	 ff                       		.byte    $ff    ; 8b
>a199	 ff                       		.byte    $ff    ; 8c
>a19a	 ff                       		.byte    $ff    ; 8d
>a19b	 ff                       		.byte    $ff    ; 8e
>a19c	 ff                       		.byte    $ff    ; 8f
>a19d	 ff                       		.byte    $ff    ; 90
>a19e	 ff                       		.byte    $ff    ; 91
>a19f	 80                       		.byte    $80    ; 92
>a1a0	 80                       		.byte    $80    ; 93
>a1a1	 00                       		.byte    $00    ; 94
>a1a2	 00                       		.byte    $00    ; 95
>a1a3	 10                       		.byte    $10    ; 96
>a1a4	 10                       		.byte    $10    ; 97
>a1a5	 ff                       		.byte    $ff    ; 98
>a1a6	 ff                       		.byte    $ff    ; 99
>a1a7	 c0                       		.byte    $c0    ; 9a
>a1a8	 c0                       		.byte    $c0    ; 9b
>a1a9	 40                       		.byte    $40    ; 9c
>a1aa	 40                       		.byte    $40    ; 9d
>a1ab	 50                       		.byte    $50    ; 9e
>a1ac	 50                       		.byte    $50    ; 9f
>a1ad	 ff                       		.byte    $ff    ; a0
>a1ae	 ff                       		.byte    $ff    ; a1
>a1af	 ff                       		.byte    $ff    ; a2
>a1b0	 ff                       		.byte    $ff    ; a3
>a1b1	 20                       		.byte    $20    ; a4
>a1b2	 20                       		.byte    $20    ; a5
>a1b3	 30                       		.byte    $30    ; a6
>a1b4	 30                       		.byte    $30    ; a7
>a1b5	 ff                       		.byte    $ff    ; a8
>a1b6	 ff                       		.byte    $ff    ; a9
>a1b7	 f0                       		.byte    $f0    ; aa
>a1b8	 f0                       		.byte    $f0    ; ab
>a1b9	 60                       		.byte    $60    ; ac
>a1ba	 60                       		.byte    $60    ; ad
>a1bb	 70                       		.byte    $70    ; ae
>a1bc	 70                       		.byte    $70    ; af
>a1bd	 ff                       		.byte    $ff    ; b0
>a1be	 ff                       		.byte    $ff    ; b1
>a1bf	 90                       		.byte    $90    ; b2
>a1c0	 90                       		.byte    $90    ; b3
>a1c1	 a0                       		.byte    $a0    ; b4
>a1c2	 a0                       		.byte    $a0    ; b5
>a1c3	 b0                       		.byte    $b0    ; b6
>a1c4	 b0                       		.byte    $b0    ; b7
>a1c5	 ff                       		.byte    $ff    ; b8
>a1c6	 ff                       		.byte    $ff    ; b9
>a1c7	 d0                       		.byte    $d0    ; ba
>a1c8	 d0                       		.byte    $d0    ; bb
>a1c9	 e0                       		.byte    $e0    ; bc
>a1ca	 e0                       		.byte    $e0    ; bd
>a1cb	 ff                       		.byte    $ff    ; be
>a1cc	 ff                       		.byte    $ff    ; bf
>a1cd	 ff                       		.byte    $ff    ; c0
>a1ce	 ff                       		.byte    $ff    ; c1
>a1cf	 ff                       		.byte    $ff    ; c2
>a1d0	 ff                       		.byte    $ff    ; c3
>a1d1	 ff                       		.byte    $ff    ; c4
>a1d2	 ff                       		.byte    $ff    ; c5
>a1d3	 ff                       		.byte    $ff    ; c6
>a1d4	 ff                       		.byte    $ff    ; c7
>a1d5	 ff                       		.byte    $ff    ; c8
>a1d6	 ff                       		.byte    $ff    ; c9
>a1d7	 ff                       		.byte    $ff    ; ca
>a1d8	 ff                       		.byte    $ff    ; cb
>a1d9	 ff                       		.byte    $ff    ; cc
>a1da	 ff                       		.byte    $ff    ; cd
>a1db	 ff                       		.byte    $ff    ; ce
>a1dc	 ff                       		.byte    $ff    ; cf
>a1dd	 ff                       		.byte    $ff    ; d0
>a1de	 ff                       		.byte    $ff    ; d1
>a1df	 80                       		.byte    $80    ; d2
>a1e0	 80                       		.byte    $80    ; d3
>a1e1	 00                       		.byte    $00    ; d4
>a1e2	 00                       		.byte    $00    ; d5
>a1e3	 10                       		.byte    $10    ; d6
>a1e4	 10                       		.byte    $10    ; d7
>a1e5	 ff                       		.byte    $ff    ; d8
>a1e6	 ff                       		.byte    $ff    ; d9
>a1e7	 c0                       		.byte    $c0    ; da
>a1e8	 c0                       		.byte    $c0    ; db
>a1e9	 40                       		.byte    $40    ; dc
>a1ea	 40                       		.byte    $40    ; dd
>a1eb	 50                       		.byte    $50    ; de
>a1ec	 50                       		.byte    $50    ; df
>a1ed	 ff                       		.byte    $ff    ; e0
>a1ee	 ff                       		.byte    $ff    ; e1
>a1ef	 ff                       		.byte    $ff    ; e2
>a1f0	 ff                       		.byte    $ff    ; e3
>a1f1	 20                       		.byte    $20    ; e4
>a1f2	 20                       		.byte    $20    ; e5
>a1f3	 30                       		.byte    $30    ; e6
>a1f4	 30                       		.byte    $30    ; e7
>a1f5	 ff                       		.byte    $ff    ; e8
>a1f6	 ff                       		.byte    $ff    ; e9
>a1f7	 f0                       		.byte    $f0    ; ea
>a1f8	 f0                       		.byte    $f0    ; eb
>a1f9	 60                       		.byte    $60    ; ec
>a1fa	 60                       		.byte    $60    ; ed
>a1fb	 70                       		.byte    $70    ; ee
>a1fc	 70                       		.byte    $70    ; ef
>a1fd	 ff                       		.byte    $ff    ; f0
>a1fe	 ff                       		.byte    $ff    ; f1
>a1ff	 90                       		.byte    $90    ; f2
>a200	 90                       		.byte    $90    ; f3
>a201	 a0                       		.byte    $a0    ; f4
>a202	 a0                       		.byte    $a0    ; f5
>a203	 b0                       		.byte    $b0    ; f6
>a204	 b0                       		.byte    $b0    ; f7
>a205	 ff                       		.byte    $ff    ; f8
>a206	 ff                       		.byte    $ff    ; f9
>a207	 d0                       		.byte    $d0    ; fa
>a208	 d0                       		.byte    $d0    ; fb
>a209	 e0                       		.byte    $e0    ; fc
>a20a	 e0                       		.byte    $e0    ; fd
>a20b	 ff                       	 	.byte    $ff    ; fe
>a20c	 ff                       		.byte    $ff    ; ff

;******  Return to file "serlib.asm"

					        .include "gcr7.asm"

;******  Processing file "gcr7.asm"

>a20d	 ff                       	gcrtb3  .byte    $ff    ; 0
>a20e	 ff                       		.byte    $ff    ; 1
>a20f	 ff                       		.byte    $ff    ; 2
>a210	 ff                       		.byte    $ff    ; 3
>a211	 ff                       		.byte    $ff    ; 4
>a212	 ff                       		.byte    $ff    ; 5
>a213	 ff                       		.byte    $ff    ; 6
>a214	 ff                       		.byte    $ff    ; 7
>a215	 ff                       		.byte    $ff    ; 8
>a216	 ff                       		.byte    $ff    ; 9
>a217	 ff                       		.byte    $ff    ; a
>a218	 ff                       		.byte    $ff    ; b
>a219	 ff                       		.byte    $ff    ; c
>a21a	 ff                       		.byte    $ff    ; d
>a21b	 ff                       		.byte    $ff    ; e
>a21c	 ff                       		.byte    $ff    ; f
>a21d	 ff                       		.byte    $ff    ; 10
>a21e	 ff                       		.byte    $ff    ; 11
>a21f	 ff                       		.byte    $ff    ; 12
>a220	 ff                       		.byte    $ff    ; 13
>a221	 ff                       		.byte    $ff    ; 14
>a222	 ff                       		.byte    $ff    ; 15
>a223	 ff                       		.byte    $ff    ; 16
>a224	 ff                       		.byte    $ff    ; 17
>a225	 ff                       		.byte    $ff    ; 18
>a226	 ff                       		.byte    $ff    ; 19
>a227	 ff                       		.byte    $ff    ; 1a
>a228	 ff                       		.byte    $ff    ; 1b
>a229	 ff                       		.byte    $ff    ; 1c
>a22a	 ff                       		.byte    $ff    ; 1d
>a22b	 ff                       		.byte    $ff    ; 1e
>a22c	 ff                       		.byte    $ff    ; 1f
>a22d	 ff                       		.byte    $ff    ; 20
>a22e	 ff                       		.byte    $ff    ; 21
>a22f	 ff                       		.byte    $ff    ; 22
>a230	 ff                       		.byte    $ff    ; 23
>a231	 08                       		.byte    $08    ; 24
>a232	 08                       		.byte    $08    ; 25
>a233	 08                       		.byte    $08    ; 26
>a234	 08                       		.byte    $08    ; 27
>a235	 00                       		.byte    $00    ; 28
>a236	 00                       	        .byte    $00    ; 29
>a237	 00                       		.byte    $00    ; 2a
>a238	 00                       		.byte    $00    ; 2b
>a239	 01                       		.byte    $01    ; 2c
>a23a	 01                       		.byte    $01    ; 2d
>a23b	 01                       		.byte    $01    ; 2e
>a23c	 01                       		.byte    $01    ; 2f
>a23d	 ff                       		.byte    $ff    ; 30
>a23e	 ff                       		.byte    $ff    ; 31
>a23f	 ff                       		.byte    $ff    ; 32
>a240	 ff                       		.byte    $ff    ; 33
>a241	 0c                       		.byte    $0c    ; 34
>a242	 0c                       		.byte    $0c    ; 35
>a243	 0c                       		.byte    $0c    ; 36
>a244	 0c                       		.byte    $0c    ; 37
>a245	 04                       		.byte    $04    ; 38
>a246	 04                       		.byte    $04    ; 39
>a247	 04                       		.byte    $04    ; 3a
>a248	 04                       		.byte    $04    ; 3b
>a249	 05                       		.byte    $05    ; 3c
>a24a	 05                       		.byte    $05    ; 3d
>a24b	 05                       		.byte    $05    ; 3e
>a24c	 05                       		.byte    $05    ; 3f
>a24d	 ff                       		.byte    $ff    ; 40
>a24e	 ff                       		.byte    $ff    ; 41
>a24f	 ff                       		.byte    $ff    ; 42
>a250	 ff                       		.byte    $ff    ; 43
>a251	 ff                       		.byte    $ff    ; 44
>a252	 ff                       		.byte    $ff    ; 45
>a253	 ff                       		.byte    $ff    ; 46
>a254	 ff                       		.byte    $ff    ; 47
>a255	 02                       		.byte    $02    ; 48
>a256	 02                       		.byte    $02    ; 49
>a257	 02                       		.byte    $02    ; 4a
>a258	 02                       		.byte    $02    ; 4b
>a259	 03                       		.byte    $03    ; 4c
>a25a	 03                       		.byte    $03    ; 4d
>a25b	 03                       		.byte    $03    ; 4e
>a25c	 03                       		.byte    $03    ; 4f
>a25d	 ff                       		.byte    $ff    ; 50
>a25e	 ff                       		.byte    $ff    ; 51
>a25f	 ff                       		.byte    $ff    ; 52
>a260	 ff                       		.byte    $ff    ; 53
>a261	 0f                       		.byte    $0f    ; 54
>a262	 0f                       		.byte    $0f    ; 55
>a263	 0f                       		.byte    $0f    ; 56
>a264	 0f                       		.byte    $0f    ; 57
>a265	 06                       		.byte    $06    ; 58
>a266	 06                       		.byte    $06    ; 59
>a267	 06                       		.byte    $06    ; 5a
>a268	 06                       		.byte    $06    ; 5b
>a269	 07                       		.byte    $07    ; 5c
>a26a	 07                       		.byte    $07    ; 5d
>a26b	 07                       		.byte    $07    ; 5e
>a26c	 07                       		.byte    $07    ; 5f
>a26d	 ff                       		.byte    $ff    ; 60
>a26e	 ff                       		.byte    $ff    ; 61
>a26f	 ff                       		.byte    $ff    ; 62
>a270	 ff                       		.byte    $ff    ; 63
>a271	 09                       		.byte    $09    ; 64
>a272	 09                       		.byte    $09    ; 65
>a273	 09                       		.byte    $09    ; 66
>a274	 09                       		.byte    $09    ; 67
>a275	 0a                       		.byte    $0a    ; 68
>a276	 0a                       		.byte    $0a    ; 69
>a277	 0a                       		.byte    $0a    ; 6a
>a278	 0a                       		.byte    $0a    ; 6b
>a279	 0b                       		.byte    $0b    ; 6c
>a27a	 0b                       		.byte    $0b    ; 6d
>a27b	 0b                       		.byte    $0b    ; 6e
>a27c	 0b                       		.byte    $0b    ; 6f
>a27d	 ff                       		.byte    $ff    ; 70
>a27e	 ff                       		.byte    $ff    ; 71
>a27f	 ff                       		.byte    $ff    ; 72
>a280	 ff                       		.byte    $ff    ; 73
>a281	 0d                       		.byte    $0d    ; 74
>a282	 0d                       		.byte    $0d    ; 75
>a283	 0d                       		.byte    $0d    ; 76
>a284	 0d                       		.byte    $0d    ; 77
>a285	 0e                       		.byte    $0e    ; 78
>a286	 0e                       		.byte    $0e    ; 79
>a287	 0e                       		.byte    $0e    ; 7a
>a288	 0e                       		.byte    $0e    ; 7b
>a289	 ff                       		.byte    $ff    ; 7c
>a28a	 ff                       		.byte    $ff    ; 7d
>a28b	 ff                       		.byte    $ff    ; 7e
>a28c	 ff                       		.byte    $ff    ; 7f
>a28d	 ff                       		.byte    $ff    ; 80
>a28e	 ff                       		.byte    $ff    ; 81
>a28f	 ff                       		.byte    $ff    ; 82
>a290	 ff                       		.byte    $ff    ; 83
>a291	 ff                       		.byte    $ff    ; 84
>a292	 ff                       		.byte    $ff    ; 85
>a293	 ff                       		.byte    $ff    ; 86
>a294	 ff                       		.byte    $ff    ; 87
>a295	 ff                       		.byte    $ff    ; 88
>a296	 ff                       		.byte    $ff    ; 89
>a297	 ff                       		.byte    $ff    ; 8a
>a298	 ff                       		.byte    $ff    ; 8b
>a299	 ff                       		.byte    $ff    ; 8c
>a29a	 ff                       		.byte    $ff    ; 8d
>a29b	 ff                       		.byte    $ff    ; 8e
>a29c	 ff                       		.byte    $ff    ; 8f
>a29d	 ff                       		.byte    $ff    ; 90
>a29e	 ff                       		.byte    $ff    ; 91
>a29f	 ff                       		.byte    $ff    ; 92
>a2a0	 ff                       		.byte    $ff    ; 93
>a2a1	 ff                       		.byte    $ff    ; 94
>a2a2	 ff                       		.byte    $ff    ; 95
>a2a3	 ff                       		.byte    $ff    ; 96
>a2a4	 ff                       		.byte    $ff    ; 97
>a2a5	 ff                       		.byte    $ff    ; 98
>a2a6	 ff                       		.byte    $ff    ; 99
>a2a7	 ff                       		.byte    $ff    ; 9a
>a2a8	 ff                       		.byte    $ff    ; 9b
>a2a9	 ff                       		.byte    $ff    ; 9c
>a2aa	 ff                       		.byte    $ff    ; 9d
>a2ab	 ff                       		.byte    $ff    ; 9e
>a2ac	 ff                       		.byte    $ff    ; 9f
>a2ad	 ff                       		.byte    $ff    ; a0
>a2ae	 ff                       		.byte    $ff    ; a1
>a2af	 ff                       		.byte    $ff    ; a2
>a2b0	 ff                       		.byte    $ff    ; a3
>a2b1	 08                       		.byte    $08    ; a4
>a2b2	 08                       		.byte    $08    ; a5
>a2b3	 08                       		.byte    $08    ; a6
>a2b4	 08                       		.byte    $08    ; a7
>a2b5	 00                       		.byte    $00    ; a8
>a2b6	 00                       		.byte    $00    ; a9
>a2b7	 00                       		.byte    $00    ; aa
>a2b8	 00                       		.byte    $00    ; ab
>a2b9	 01                       		.byte    $01    ; ac
>a2ba	 01                       		.byte    $01    ; ad
>a2bb	 01                       		.byte    $01    ; ae
>a2bc	 01                       		.byte    $01    ; af
>a2bd	 ff                       		.byte    $ff    ; b0
>a2be	 ff                       		.byte    $ff    ; b1
>a2bf	 ff                       		.byte    $ff    ; b2
>a2c0	 ff                       		.byte    $ff    ; b3
>a2c1	 0c                       		.byte    $0c    ; b4
>a2c2	 0c                       		.byte    $0c    ; b5
>a2c3	 0c                       		.byte    $0c    ; b6
>a2c4	 0c                       		.byte    $0c    ; b7
>a2c5	 04                       		.byte    $04    ; b8
>a2c6	 04                       		.byte    $04    ; b9
>a2c7	 04                       		.byte    $04    ; ba
>a2c8	 04                       		.byte    $04    ; bb
>a2c9	 05                       		.byte    $05    ; bc
>a2ca	 05                       		.byte    $05    ; bd
>a2cb	 05                       		.byte    $05    ; be
>a2cc	 05                       		.byte    $05    ; bf
>a2cd	 ff                       		.byte    $ff    ; c0
>a2ce	 ff                       		.byte    $ff    ; c1
>a2cf	 ff                       		.byte    $ff    ; c2
>a2d0	 ff                       		.byte    $ff    ; c3
>a2d1	 ff                       		.byte    $ff    ; c4
>a2d2	 ff                       		.byte    $ff    ; c5
>a2d3	 ff                       		.byte    $ff    ; c6
>a2d4	 ff                       		.byte    $ff    ; c7
>a2d5	 02                       		.byte    $02    ; c8
>a2d6	 02                       		.byte    $02    ; c9
>a2d7	 02                       		.byte    $02    ; ca
>a2d8	 02                       		.byte    $02    ; cb
>a2d9	 03                       		.byte    $03    ; cc
>a2da	 03                       		.byte    $03    ; cd
>a2db	 03                       		.byte    $03    ; ce
>a2dc	 03                       		.byte    $03    ; cf
>a2dd	 ff                       		.byte    $ff    ; d0
>a2de	 ff                       		.byte    $ff    ; d1
>a2df	 ff                       		.byte    $ff    ; d2
>a2e0	 ff                       		.byte    $ff    ; d3
>a2e1	 0f                       		.byte    $0f    ; d4
>a2e2	 0f                       		.byte    $0f    ; d5
>a2e3	 0f                       		.byte    $0f    ; d6
>a2e4	 0f                       		.byte    $0f    ; d7
>a2e5	 06                       		.byte    $06    ; d8
>a2e6	 06                       		.byte    $06    ; d9
>a2e7	 06                       		.byte    $06    ; da
>a2e8	 06                       		.byte    $06    ; db
>a2e9	 07                       		.byte    $07    ; dc
>a2ea	 07                       		.byte    $07    ; dd
>a2eb	 07                       		.byte    $07    ; de
>a2ec	 07                       		.byte    $07    ; df
>a2ed	 ff                       		.byte    $ff    ; e0
>a2ee	 ff                       		.byte    $ff    ; e1
>a2ef	 ff                       		.byte    $ff    ; e2
>a2f0	 ff                       		.byte    $ff    ; e3
>a2f1	 09                       		.byte    $09    ; e4
>a2f2	 09                       		.byte    $09    ; e5
>a2f3	 09                       		.byte    $09    ; e6
>a2f4	 09                       		.byte    $09    ; e7
>a2f5	 0a                       		.byte    $0a    ; e8
>a2f6	 0a                       		.byte    $0a    ; e9
>a2f7	 0a                       		.byte    $0a    ; ea
>a2f8	 0a                       		.byte    $0a    ; eb
>a2f9	 0b                       		.byte    $0b    ; ec
>a2fa	 0b                       		.byte    $0b    ; ed
>a2fb	 0b                       		.byte    $0b    ; ee
>a2fc	 0b                       		.byte    $0b    ; ef
>a2fd	 ff                       		.byte    $ff    ; f0
>a2fe	 ff                       		.byte    $ff    ; f1
>a2ff	 ff                       		.byte    $ff    ; f2
>a300	 ff                       		.byte    $ff    ; f3
>a301	 0d                       		.byte    $0d    ; f4
>a302	 0d                       		.byte    $0d    ; f5
>a303	 0d                       		.byte    $0d    ; f6
>a304	 0d                       		.byte    $0d    ; f7
>a305	 0e                       		.byte    $0e    ; f8
>a306	 0e                       		.byte    $0e    ; f9
>a307	 0e                       		.byte    $0e    ; fa
>a308	 0e                       		.byte    $0e    ; fb
>a309	 ff                       		.byte    $ff    ; fc
>a30a	 ff                       		.byte    $ff    ; fd
>a30b	 ff                       	 	.byte    $ff    ; fe
>a30c	 ff                       		.byte    $ff    ; ff

;******  Return to file "serlib.asm"

						.include "gcr8.asm"

;******  Processing file "gcr8.asm"

>a30d	 ff                       	gcrtb4  .byte    $ff    ; 0
>a30e	 ff                       		.byte    $ff    ; 1
>a30f	 ff                       		.byte    $ff    ; 2
>a310	 ff                       		.byte    $ff    ; 3
>a311	 ff                       		.byte    $ff    ; 4
>a312	 ff                       		.byte    $ff    ; 5
>a313	 ff                       		.byte    $ff    ; 6
>a314	 ff                       		.byte    $ff    ; 7
>a315	 ff                       		.byte    $ff    ; 8
>a316	 08                       		.byte    $08    ; 9
>a317	 00                       		.byte    $00    ; a
>a318	 01                       		.byte    $01    ; b
>a319	 ff                       		.byte    $ff    ; c
>a31a	 0c                       		.byte    $0c    ; d
>a31b	 04                       		.byte    $04    ; e
>a31c	 05                       		.byte    $05    ; f
>a31d	 ff                       		.byte    $ff    ; 10
>a31e	 ff                       		.byte    $ff    ; 11
>a31f	 02                       		.byte    $02    ; 12
>a320	 03                       		.byte    $03    ; 13
>a321	 ff                       		.byte    $ff    ; 14
>a322	 0f                       		.byte    $0f    ; 15
>a323	 06                       		.byte    $06    ; 16
>a324	 07                       		.byte    $07    ; 17
>a325	 ff                       		.byte    $ff    ; 18
>a326	 09                       		.byte    $09    ; 19
>a327	 0a                       		.byte    $0a    ; 1a
>a328	 0b                       		.byte    $0b    ; 1b
>a329	 ff                       		.byte    $ff    ; 1c
>a32a	 0d                       		.byte    $0d    ; 1d
>a32b	 0e                       		.byte    $0e    ; 1e
>a32c	 ff                       		.byte    $ff    ; 1f
>a32d	 ff                       		.byte    $ff    ; 20
>a32e	 ff                       		.byte    $ff    ; 21
>a32f	 ff                       		.byte    $ff    ; 22
>a330	 ff                       		.byte    $ff    ; 23
>a331	 ff                       		.byte    $ff    ; 24
>a332	 ff                       		.byte    $ff    ; 25
>a333	 ff                       		.byte    $ff    ; 26
>a334	 ff                       		.byte    $ff    ; 27
>a335	 ff                       		.byte    $ff    ; 28
>a336	 08                       	        .byte    $08    ; 29
>a337	 00                       		.byte    $00    ; 2a
>a338	 01                       		.byte    $01    ; 2b
>a339	 ff                       		.byte    $ff    ; 2c
>a33a	 0c                       		.byte    $0c    ; 2d
>a33b	 04                       		.byte    $04    ; 2e
>a33c	 05                       		.byte    $05    ; 2f
>a33d	 ff                       		.byte    $ff    ; 30
>a33e	 ff                       		.byte    $ff    ; 31
>a33f	 02                       		.byte    $02    ; 32
>a340	 03                       		.byte    $03    ; 33
>a341	 ff                       		.byte    $ff    ; 34
>a342	 0f                       		.byte    $0f    ; 35
>a343	 06                       		.byte    $06    ; 36
>a344	 07                       		.byte    $07    ; 37
>a345	 ff                       		.byte    $ff    ; 38
>a346	 09                       		.byte    $09    ; 39
>a347	 0a                       		.byte    $0a    ; 3a
>a348	 0b                       		.byte    $0b    ; 3b
>a349	 ff                       		.byte    $ff    ; 3c
>a34a	 0d                       		.byte    $0d    ; 3d
>a34b	 0e                       		.byte    $0e    ; 3e
>a34c	 ff                       		.byte    $ff    ; 3f
>a34d	 ff                       		.byte    $ff    ; 40
>a34e	 ff                       		.byte    $ff    ; 41
>a34f	 ff                       		.byte    $ff    ; 42
>a350	 ff                       		.byte    $ff    ; 43
>a351	 ff                       		.byte    $ff    ; 44
>a352	 ff                       		.byte    $ff    ; 45
>a353	 ff                       		.byte    $ff    ; 46
>a354	 ff                       		.byte    $ff    ; 47
>a355	 ff                       		.byte    $ff    ; 48
>a356	 08                       		.byte    $08    ; 49
>a357	 00                       		.byte    $00    ; 4a
>a358	 01                       		.byte    $01    ; 4b
>a359	 ff                       		.byte    $ff    ; 4c
>a35a	 0c                       		.byte    $0c    ; 4d
>a35b	 04                       		.byte    $04    ; 4e
>a35c	 05                       		.byte    $05    ; 4f
>a35d	 ff                       		.byte    $ff    ; 50
>a35e	 ff                       		.byte    $ff    ; 51
>a35f	 02                       		.byte    $02    ; 52
>a360	 03                       		.byte    $03    ; 53
>a361	 ff                       		.byte    $ff    ; 54
>a362	 0f                       		.byte    $0f    ; 55
>a363	 06                       		.byte    $06    ; 56
>a364	 07                       		.byte    $07    ; 57
>a365	 ff                       		.byte    $ff    ; 58
>a366	 09                       		.byte    $09    ; 59
>a367	 0a                       		.byte    $0a    ; 5a
>a368	 0b                       		.byte    $0b    ; 5b
>a369	 ff                       		.byte    $ff    ; 5c
>a36a	 0d                       		.byte    $0d    ; 5d
>a36b	 0e                       		.byte    $0e    ; 5e
>a36c	 ff                       		.byte    $ff    ; 5f
>a36d	 ff                       		.byte    $ff    ; 60
>a36e	 ff                       		.byte    $ff    ; 61
>a36f	 ff                       		.byte    $ff    ; 62
>a370	 ff                       		.byte    $ff    ; 63
>a371	 ff                       		.byte    $ff    ; 64
>a372	 ff                       		.byte    $ff    ; 65
>a373	 ff                       		.byte    $ff    ; 66
>a374	 ff                       		.byte    $ff    ; 67
>a375	 ff                       		.byte    $ff    ; 68
>a376	 08                       		.byte    $08    ; 69
>a377	 00                       		.byte    $00    ; 6a
>a378	 01                       		.byte    $01    ; 6b
>a379	 ff                       		.byte    $ff    ; 6c
>a37a	 0c                       		.byte    $0c    ; 6d
>a37b	 04                       		.byte    $04    ; 6e
>a37c	 05                       		.byte    $05    ; 6f
>a37d	 ff                       		.byte    $ff    ; 70
>a37e	 ff                       		.byte    $ff    ; 71
>a37f	 02                       		.byte    $02    ; 72
>a380	 03                       		.byte    $03    ; 73
>a381	 ff                       		.byte    $ff    ; 74
>a382	 0f                       		.byte    $0f    ; 75
>a383	 06                       		.byte    $06    ; 76
>a384	 07                       		.byte    $07    ; 77
>a385	 ff                       		.byte    $ff    ; 78
>a386	 09                       		.byte    $09    ; 79
>a387	 0a                       		.byte    $0a    ; 7a
>a388	 0b                       		.byte    $0b    ; 7b
>a389	 ff                       		.byte    $ff    ; 7c
>a38a	 0d                       		.byte    $0d    ; 7d
>a38b	 0e                       		.byte    $0e    ; 7e
>a38c	 ff                       		.byte    $ff    ; 7f
>a38d	 ff                       		.byte    $ff    ; 80
>a38e	 ff                       		.byte    $ff    ; 81
>a38f	 ff                       		.byte    $ff    ; 82
>a390	 ff                       		.byte    $ff    ; 83
>a391	 ff                       		.byte    $ff    ; 84
>a392	 ff                       		.byte    $ff    ; 85
>a393	 ff                       		.byte    $ff    ; 86
>a394	 ff                       		.byte    $ff    ; 87
>a395	 ff                       		.byte    $ff    ; 88
>a396	 08                       		.byte    $08    ; 89
>a397	 00                       		.byte    $00    ; 8a
>a398	 01                       		.byte    $01    ; 8b
>a399	 ff                       		.byte    $ff    ; 8c
>a39a	 0c                       		.byte    $0c    ; 8d
>a39b	 04                       		.byte    $04    ; 8e
>a39c	 05                       		.byte    $05    ; 8f
>a39d	 ff                       		.byte    $ff    ; 90
>a39e	 ff                       		.byte    $ff    ; 91
>a39f	 02                       		.byte    $02    ; 92
>a3a0	 03                       		.byte    $03    ; 93
>a3a1	 ff                       		.byte    $ff    ; 94
>a3a2	 0f                       		.byte    $0f    ; 95
>a3a3	 06                       		.byte    $06    ; 96
>a3a4	 07                       		.byte    $07    ; 97
>a3a5	 ff                       		.byte    $ff    ; 98
>a3a6	 09                       		.byte    $09    ; 99
>a3a7	 0a                       		.byte    $0a    ; 9a
>a3a8	 0b                       		.byte    $0b    ; 9b
>a3a9	 ff                       		.byte    $ff    ; 9c
>a3aa	 0d                       		.byte    $0d    ; 9d
>a3ab	 0e                       		.byte    $0e    ; 9e
>a3ac	 ff                       		.byte    $ff    ; 9f
>a3ad	 ff                       		.byte    $ff    ; a0
>a3ae	 ff                       		.byte    $ff    ; a1
>a3af	 ff                       		.byte    $ff    ; a2
>a3b0	 ff                       		.byte    $ff    ; a3
>a3b1	 ff                       		.byte    $ff    ; a4
>a3b2	 ff                       		.byte    $ff    ; a5
>a3b3	 ff                       		.byte    $ff    ; a6
>a3b4	 ff                       		.byte    $ff    ; a7
>a3b5	 ff                       		.byte    $ff    ; a8
>a3b6	 08                       		.byte    $08    ; a9
>a3b7	 00                       		.byte    $00    ; aa
>a3b8	 01                       		.byte    $01    ; ab
>a3b9	 ff                       		.byte    $ff    ; ac
>a3ba	 0c                       		.byte    $0c    ; ad
>a3bb	 04                       		.byte    $04    ; ae
>a3bc	 05                       		.byte    $05    ; af
>a3bd	 ff                       		.byte    $ff    ; b0
>a3be	 ff                       		.byte    $ff    ; b1
>a3bf	 02                       		.byte    $02    ; b2
>a3c0	 03                       		.byte    $03    ; b3
>a3c1	 ff                       		.byte    $ff    ; b4
>a3c2	 0f                       		.byte    $0f    ; b5
>a3c3	 06                       		.byte    $06    ; b6
>a3c4	 07                       		.byte    $07    ; b7
>a3c5	 ff                       		.byte    $ff    ; b8
>a3c6	 09                       		.byte    $09    ; b9
>a3c7	 0a                       		.byte    $0a    ; ba
>a3c8	 0b                       		.byte    $0b    ; bb
>a3c9	 ff                       		.byte    $ff    ; bc
>a3ca	 0d                       		.byte    $0d    ; bd
>a3cb	 0e                       		.byte    $0e    ; be
>a3cc	 ff                       		.byte    $ff    ; bf
>a3cd	 ff                       		.byte    $ff    ; c0
>a3ce	 ff                       		.byte    $ff    ; c1
>a3cf	 ff                       		.byte    $ff    ; c2
>a3d0	 ff                       		.byte    $ff    ; c3
>a3d1	 ff                       		.byte    $ff    ; c4
>a3d2	 ff                       		.byte    $ff    ; c5
>a3d3	 ff                       		.byte    $ff    ; c6
>a3d4	 ff                       		.byte    $ff    ; c7
>a3d5	 ff                       		.byte    $ff    ; c8
>a3d6	 08                       		.byte    $08    ; c9
>a3d7	 00                       		.byte    $00    ; ca
>a3d8	 01                       		.byte    $01    ; cb
>a3d9	 ff                       		.byte    $ff    ; cc
>a3da	 0c                       		.byte    $0c    ; cd
>a3db	 04                       		.byte    $04    ; ce
>a3dc	 05                       		.byte    $05    ; cf
>a3dd	 ff                       		.byte    $ff    ; d0
>a3de	 ff                       		.byte    $ff    ; d1
>a3df	 02                       		.byte    $02    ; d2
>a3e0	 03                       		.byte    $03    ; d3
>a3e1	 ff                       		.byte    $ff    ; d4
>a3e2	 0f                       		.byte    $0f    ; d5
>a3e3	 06                       		.byte    $06    ; d6
>a3e4	 07                       		.byte    $07    ; d7
>a3e5	 ff                       		.byte    $ff    ; d8
>a3e6	 09                       		.byte    $09    ; d9
>a3e7	 0a                       		.byte    $0a    ; da
>a3e8	 0b                       		.byte    $0b    ; db
>a3e9	 ff                       		.byte    $ff    ; dc
>a3ea	 0d                       		.byte    $0d    ; dd
>a3eb	 0e                       		.byte    $0e    ; de
>a3ec	 ff                       		.byte    $ff    ; df
>a3ed	 ff                       		.byte    $ff    ; e0
>a3ee	 ff                       		.byte    $ff    ; e1
>a3ef	 ff                       		.byte    $ff    ; e2
>a3f0	 ff                       		.byte    $ff    ; e3
>a3f1	 ff                       		.byte    $ff    ; e4
>a3f2	 ff                       		.byte    $ff    ; e5
>a3f3	 ff                       		.byte    $ff    ; e6
>a3f4	 ff                       		.byte    $ff    ; e7
>a3f5	 ff                       		.byte    $ff    ; e8
>a3f6	 08                       		.byte    $08    ; e9
>a3f7	 00                       		.byte    $00    ; ea
>a3f8	 01                       		.byte    $01    ; eb
>a3f9	 ff                       		.byte    $ff    ; ec
>a3fa	 0c                       		.byte    $0c    ; ed
>a3fb	 04                       		.byte    $04    ; ee
>a3fc	 05                       		.byte    $05    ; ef
>a3fd	 ff                       		.byte    $ff    ; f0
>a3fe	 ff                       		.byte    $ff    ; f1
>a3ff	 02                       		.byte    $02    ; f2
>a400	 03                       		.byte    $03    ; f3
>a401	 ff                       		.byte    $ff    ; f4
>a402	 0f                       		.byte    $0f    ; f5
>a403	 06                       		.byte    $06    ; f6
>a404	 07                       		.byte    $07    ; f7
>a405	 ff                       		.byte    $ff    ; f8
>a406	 09                       		.byte    $09    ; f9
>a407	 0a                       		.byte    $0a    ; fa
>a408	 0b                       		.byte    $0b    ; fb
>a409	 ff                       		.byte    $ff    ; fc
>a40a	 0d                       		.byte    $0d    ; fd
>a40b	 0e                       	 	.byte    $0e    ; fe
>a40c	 ff                       		.byte    $ff    ; ff

;******  Return to file "serlib.asm"

						.include "duplct1.asm"

;******  Processing file "duplct1.asm"


.a40d					jformat
.a40d	 a9 47		lda #$47		lda  #71
.a40f	 8d ac 02	sta $02ac		sta  maxtrk	; double sided
.a412	 a9 03		lda #$03		lda  #3
.a414	 20 d3 d6	jsr $d6d3	        jsr  seth
.a417	 a2 03		ldx #$03	        ldx  #3         ; job #3
.a419	 a9 00		lda #$00		lda  #0
.a41b	 8d b2 01	sta $01b2		sta  fmtsid	; side zero first
.a41e	 a9 f0		lda #$f0	        lda  #$f0       ; format cmd
.a420	 85 3b		sta $3b		        sta  tsttrk     ; init speed var
.a422	 95 00		sta $00,x	        sta  jobs,x     ; give job to controller
.a424	 20 b6 9f	jsr $9fb6	        jsr  stbctl     ; wake him up
.a427	 c9 02		cmp #$02	        cmp  #2         ; error?
.a429	 b0 45		bcs $a470	        bcs  m1		; br, error
.a42b	 a0 03		ldy #$03		ldy  #3		; retries
.a42d	 a9 01		lda #$01	m4      lda  #1         ; track 1
.a42f	 85 0c		sta $0c		        sta  hdrs+6     ; *
.a431	 a9 00		lda #$00	        lda  #0         ; sector 0
.a433	 85 0d		sta $0d		        sta  hdrs+7     ; *
.a435	 a9 80		lda #$80	        lda  #$80       ; read
.a437	 95 00		sta $00,x	        sta  jobs,x     ; give job to controller
.a439	 20 b6 9f	jsr $9fb6	        jsr  stbctl     ; wake him up
.a43c	 c9 02		cmp #$02	        cmp  #2         ; error?
.a43e	 90 05		bcc $a445	        bcc  m5		; br, ok...
.a440	 88		dey			dey
.a441	 10 ea		bpl $a42d		bpl  m4		; try 3 times
.a443	 b0 2b		bcs $a470		bcs  m1		; bra
.a445	 a9 01		lda #$01	m5	lda  #1
.a447	 8d b2 01	sta $01b2		sta  fmtsid	; side one second
.a44a	 a9 f0		lda #$f0	        lda  #$f0       ; format cmd
.a44c	 85 3b		sta $3b		        sta  tsttrk     ; init speed var
.a44e	 95 00		sta $00,x	        sta  jobs,x     ; give job to controller
.a450	 20 b6 9f	jsr $9fb6	        jsr  stbctl     ; wake him up
.a453	 c9 02		cmp #$02	        cmp  #2         ; error?
.a455	 b0 19		bcs $a470	        bcs  m1		; br, error
.a457	 a0 03		ldy #$03		ldy  #3		; retries
.a459	 a9 24		lda #$24	m6      lda  #36        ; track 36
.a45b	 85 0c		sta $0c		        sta  hdrs+6     ; *
.a45d	 a9 00		lda #$00	        lda  #0         ; sector 0
.a45f	 85 0d		sta $0d		        sta  hdrs+7     ; *
.a461	 a9 80		lda #$80	        lda  #$80       ; read
.a463	 95 00		sta $00,x	        sta  jobs,x     ; give job to controller
.a465	 20 b6 9f	jsr $9fb6	        jsr  stbctl     ; wake him up
.a468	 c9 02		cmp #$02	        cmp  #2         ; error?
.a46a	 b0 01		bcs $a46d		bcs  m3		; br, bad
.a46c	 60		rts			rts		; ok
.a46d	 88		dey		m3	dey
.a46e	 10 e9		bpl $a459		bpl  m6		; keep trying
.a470	 a2 00		ldx #$00	m1      ldx  #0         ; set for offset for buffer to det. trk & sect.
.a472	 2c 98 02	bit $0298		bit  jobrtn	; return on error ?
.a475	 8e 98 02	stx $0298		stx  jobrtn	; clr
.a478	 10 01		bpl $a47b		bpl  m7
.a47a	 60		rts			rts		; back to caller
.a47b	 4c 0a e6	jmp $e60a	m7	jmp  error

;******  Return to file "serlib.asm"

						.include "patchn.asm"

;******  Processing file "patchn.asm"

.a47e	 8a		txa		jslower txa
.a47f	 a2 05		ldx #$05		ldx  #5
.a481	 d0 03		bne $a486		bne  jslowd+3	; bra
.a483	 8a		txa		jslowd  txa
.a484	 a2 0d		ldx #$0d		ldx  #$0d	; insert 40 us. delay at 2 Mhz
.a486	 ca		dex		-	dex
.a487	 d0 fd		bne $a486		bne  -
.a489	 aa		tax			tax
.a48a	 60		rts			rts
.a48b	 a5 6d		lda $6d		sav_pnt	lda  bmpnt	; save pointers
.a48d	 8d ad 02	sta $02ad		sta  savbm
.a490	 a5 6e		lda $6e			lda  bmpnt+1
.a492	 8d ae 02	sta $02ae		sta  savbm+1
.a495	 60		rts			rts
.a496	 ad ad 02	lda $02ad	res_pnt lda  savbm
.a499	 85 6d		sta $6d			sta  bmpnt	; save pointers
.a49b	 ad ae 02	lda $02ae		lda  savbm+1
.a49e	 85 6e		sta $6e			sta  bmpnt+1
.a4a0	 60		rts			rts
.a4a1					set_bm
.a4a1	 a6 7f		ldx $7f			ldx  drvnum

>a4a3	 bd ff 00                 		.byte $bd,$ff,$00

.a4a6	 f0 05		beq $a4ad		beq  +
.a4a8	 a9 74		lda #$74		lda  #nodriv
.a4aa	 20 45 e6	jsr $e645		jsr  cmder2	; *** rom ds 11/07/85 beta9 ***, set error
.a4ad	 20 19 f1	jsr $f119	+       jsr  bam2x	; get index into bufx
.a4b0	 20 df f0	jsr $f0df		jsr  redbam	; read BAM if neccessary
.a4b3	 4c c2 a4	jmp $a4c2		jmp  m2		; *** rom ds 09/12/85 ***, always in memory!
.a4b6	 f0 07		beq $a4bf		beq  m3
.a4b8	 09 80		ora #$80		ora  #$80
.a4ba	 8d f9 02	sta $02f9		sta  wbam	; set write pending flag
.a4bd	 d0 03		bne $a4c2		bne  m2		; bra
.a4bf	 20 8d a5	jsr $a58d	m3	jsr  wrt_bam	; write out BAM, *** rom ds 9/12/85 ***, never get here
.a4c2	 20 8b a4	jsr $a48b	m2	jsr  sav_pnt	; save current BAM pointers
.a4c5	 20 34 a5	jsr $a534		jsr  where	; find BAM
.a4c8	 a5 80		lda $80			lda  track	; get offset
.a4ca	 38		sec			sec
.a4cb	 e9 24		sbc #$24		sbc  #36
.a4cd	 a8		tay			tay
.a4ce	 b1 6d		lda ($6d),y		lda  (bmpnt),y	; get count
.a4d0	 48		pha			pha
.a4d1	 20 96 a4	jsr $a496		jsr  res_pnt	; restore BAM pointers
.a4d4	 68		pla			pla		; count in .a
.a4d5	 60		rts			rts

>a4d6	 44 41 56 49 44 20 47 2e 	   .byte $44,$41,$56,$49,$44,$20,$47,$2e,$20,$53,$49,$52,$41,$43,$55,$53,$41
>a4de	 20 53 49 52 41 43 55 53 
>a4e6	 41 

.a4e7	 a5 80		lda $80		bam_pt	lda  track
.a4e9	 38		sec			sec
.a4ea	 e9 24		sbc #$24		sbc  #36	; offset
.a4ec	 a8		tay			tay
.a4ed	 a5 81		lda $81			lda  sector	; sector/8
.a4ef	 4a		lsr a			lsr  a
.a4f0	 4a		lsr a			lsr  a
.a4f1	 4a		lsr a			lsr  a
.a4f2	 18		clc			clc
.a4f3	 79 db a5	adc $a5db,y		adc  bmindx,y	; get location
.a4f6	 a8		tay			tay
.a4f7	 a5 81		lda $81			lda  sector
.a4f9	 29 07		and #$07		and  #7
.a4fb	 aa		tax			tax		; which sector
.a4fc	 b9 46 01	lda $0146,y		lda  ovrbuf+$46,y
.a4ff	 3d e9 ef	and $efe9,x		and  bmask,x
.a502	 08		php			php		; save status
.a503	 b9 46 01	lda $0146,y		lda  ovrbuf+$46,y
.a506	 28		plp			plp		; retrieve status set/clr (z)
.a507	 60		rts			rts
.a508	 20 8b a4	jsr $a48b	deall_b	jsr  sav_pnt	; save pointers
.a50b	 20 34 a5	jsr $a534		jsr  where	; where is the BAM
.a50e	 a5 80		lda $80			lda  track
.a510	 38		sec			sec
.a511	 e9 24		sbc #$24		sbc  #36	; offset
.a513	 a8		tay			tay		; index into table
.a514	 18		clc			clc
.a515	 b1 6d		lda ($6d),y		lda  (bmpnt),y	; goto location and add 1
.a517	 69 01		adc #$01		adc  #1
.a519	 91 6d		sta ($6d),y		sta  (bmpnt),y
.a51b	 4c 96 a4	jmp $a496		jmp  res_pnt	; restore BAM pointers
.a51e	 20 8b a4	jsr $a48b	alloc_b jsr  sav_pnt	; save pointers
.a521	 20 34 a5	jsr $a534		jsr  where	; find location of the BAM
.a524	 a5 80		lda $80			lda  track
.a526	 38		sec			sec
.a527	 e9 24		sbc #$24		sbc  #36	; offset
.a529	 a8		tay			tay		; index into table
.a52a	 38		sec			sec
.a52b	 b1 6d		lda ($6d),y		lda  (bmpnt),y	; goto location and sub 1
.a52d	 e9 01		sbc #$01		sbc  #1
.a52f	 91 6d		sta ($6d),y		sta  (bmpnt),y
.a531	 4c 96 a4	jmp $a496		jmp  res_pnt	; restore pointers
.a534	 a2 0d		ldx #$0d	where	ldx  #blindx+7
.a536	 b5 a7		lda $a7,x		lda  buf0,x
.a538	 29 0f		and #$0f		and  #$0f
.a53a	 aa		tax			tax
.a53b	 bd e0 fe	lda $fee0,x		lda  bufind,x	; which buffer is the BAM in
.a53e	 85 6e		sta $6e			sta  bmpnt+1
.a540	 a9 dd		lda #$dd		lda  #$dd
.a542	 85 6d		sta $6d			sta  bmpnt
.a544	 60		rts			rts
.a545					chk_blk
.a545	 a5 6f		lda $6f			lda  temp
.a547	 48		pha			pha		; save temp
.a548	 20 8d ab	jsr $ab8d		jsr  ptch71	; *** rom ds 05/19/86 ***
.a54b	 a5 80		lda $80			lda  track
.a54d	 38		sec			sec
.a54e	 e9 24		sbc #$24		sbc  #36	; get offset
.a550	 a8		tay			tay
.a551	 48		pha			pha		; save
.a552	 20 34 a5	jsr $a534		jsr  where	; where is the BAM
.a555	 b1 6d		lda ($6d),y		lda  (bmpnt),y
.a557	 48		pha			pha
.a558	 a9 00		lda #$00		lda  #0
.a55a	 85 6f		sta $6f			sta  temp	; start at zero
.a55c	 a9 01		lda #$01		lda  #>bam_one
.a55e	 85 6e		sta $6e			sta  bmpnt+1	; msb
.a560	 b9 db a5	lda $a5db,y		lda  bmindx,y	; starts here
.a563	 18		clc			clc
.a564	 69 46		adc #$46		adc  #<bam_one	; add offset
.a566	 85 6d		sta $6d			sta  bmpnt
.a568	 a0 02		ldy #$02		ldy  #2
.a56a	 a2 07		ldx #$07	m1	ldx  #7		; verify bit map to count value
.a56c	 b1 6d		lda ($6d),y	-	lda  (bmpnt),y
.a56e	 3d e9 ef	and $efe9,x		and  bmask,x
.a571	 f0 02		beq $a575		beq  +
.a573	 e6 6f		inc $6f			inc  temp	; on free increment
.a575	 ca		dex		+	dex
.a576	 10 f4		bpl $a56c		bpl  -
.a578	 88		dey			dey
.a579	 10 ef		bpl $a56a		bpl  m1
.a57b	 68		pla			pla
.a57c	 c5 6f		cmp $6f			cmp  temp
.a57e	 f0 05		beq $a585		beq  +
.a580	 a9 71		lda #$71		lda  #direrr
.a582	 20 45 e6	jsr $e645		jsr  cmder2
.a585	 68		pla		+	pla
.a586	 a8		tay			tay		; restore track offset
.a587	 68		pla			pla
.a588	 85 6f		sta $6f			sta  temp	; restore temp
.a58a	 4c 96 a4	jmp $a496		jmp  res_pnt
.a58d	 ad 0f 18	lda $180f	wrt_bam lda  pota1	; 1/2 Mhz ?
.a590	 29 20		and #$20		and  #$20
.a592	 d0 03		bne $a597		bne  +
.a594	 4c 8a d5	jmp $d58a	-	jmp  dowrit
.a597	 ad ac 02	lda $02ac	+	lda  maxtrk
.a59a	 c9 25		cmp #$25		cmp  #37
.a59c	 90 f6		bcc $a594		bcc  -
.a59e	 a6 f9		ldx $f9			ldx  jobnum
.a5a0	 bd 5b 02	lda $025b,x		lda  lstjob,x	; save last job
.a5a3	 48		pha			pha
.a5a4	 20 8a d5	jsr $d58a		jsr  dowrit	; write out side zero
.a5a7	 20 8b a4	jsr $a48b		jsr  sav_pnt	; save bmpnt
.a5aa	 20 3a ef	jsr $ef3a		jsr  setbpt
.a5ad	 20 08 f0	jsr $f008		jsr  clrbam+3	; clear buffer
.a5b0	 a5 f9		lda $f9			lda  jobnum
.a5b2	 0a		asl a			asl  a
.a5b3	 aa		tax			tax
.a5b4	 a9 35		lda #$35		lda  #53
.a5b6	 95 06		sta $06,x		sta  hdrs,x	; put track in job queue, same sector
.a5b8	 a0 68		ldy #$68		ldy  #104
.a5ba	 b9 46 01	lda $0146,y	-	lda  ovrbuf+$46,y
.a5bd	 91 6d		sta ($6d),y		sta  (bmpnt),y
.a5bf	 88		dey			dey
.a5c0	 10 f8		bpl $a5ba		bpl  -		; transfer to buffer
.a5c2	 20 96 a4	jsr $a496		jsr  res_pnt	; restore pointers
.a5c5	 20 8a d5	jsr $d58a		jsr  dowrit	; write this track out
.a5c8	 a5 f9		lda $f9			lda  jobnum
.a5ca	 0a		asl a			asl  a
.a5cb	 aa		tax			tax
.a5cc	 ad 85 fe	lda $fe85		lda  dirtrk     ; *2
.a5cf	 95 06		sta $06,x		sta  hdrs,x	; read back BAM side zero
.a5d1	 20 86 d5	jsr $d586		jsr  doread	; done
.a5d4	 68		pla			pla
.a5d5	 a6 f9		ldx $f9			ldx  jobnum
.a5d7	 9d 5b 02	sta $025b,x		sta  lstjob,x	; restore last job
.a5da	 60		rts			rts

>a5db	 00 03 06 09 0c 0f 12 15 	bmindx  .byte 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54
>a5e3	 18 1b 1e 21 24 27 2a 2d 
>a5eb	 30 33 36 
>a5ee	 39 3c 3f 42 45 48 4b 4e 		.byte 57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102
>a5f6	 51 54 57 5a 5d 60 63 66 

.a5fe	 ad 0f 18	lda $180f	ptch18  lda  pota1	; 1/2 Mhz ?
.a601	 29 20		and #$20		and  #$20
.a603	 f0 0f		beq $a614		beq  +
.a605	 a0 00		ldy #$00		ldy  #0		; clr regs
.a607	 a2 00		ldx #$00		ldx  #0
.a609	 a9 01		lda #$01		lda  #1		; place filename
.a60b	 8d 7a 02	sta $027a		sta  filtbl
.a60e	 20 12 c3	jsr $c312		jsr  onedrv	; setup drv
.a611	 4c a8 e7	jmp $e7a8		jmp  rtch18	; ret
.a614	 a9 8d		lda #$8d	+	lda  #$8d	; 1541 mode
.a616	 20 68 c2	jsr $c268		jsr  parse
.a619	 4c a8 e7	jmp $e7a8		jmp  rtch18	; ret
.a61c	 20 46 c1	jsr $c146	ptch19	jsr  parsxq	; parse & xeq cmd
.a61f	 20 b2 81	jsr $81b2		jsr  spinp	; input
.a622	 a5 37		lda $37			lda  fastsr	; clr error
.a624	 29 7f		and #$7f		and  #$7f
.a626	 85 37		sta $37			sta  fastsr
.a628	 4c ff eb	jmp $ebff		jmp  rtch19
.a62b	 a9 ff		lda #$ff	ptch20	lda  #255
.a62d	 85 48		sta $48			sta  acltim
.a62f	 a9 06		lda #$06		lda  #6		; setup timer2
.a631	 85 35		sta $35			sta  acltim2
.a633	 60		rts			rts
.a634					ptch21
.a634	 d0 07		bne $a63d		bne  m1
.a636	 ad ab 02	lda $02ab		lda  mtrcnt	; anything to do ?
.a639	 d0 10		bne $a64b		bne  m2
.a63b	 f0 1a		beq $a657		beq  m3
.a63d	 a9 ff		lda #$ff	m1	lda  #255
.a63f	 8d ab 02	sta $02ab		sta  mtrcnt	; irq * 255
.a642	 20 64 87	jsr $8764		jsr  moton	; turn on the motor
.a645	 20 96 ab	jsr $ab96		jsr  ptch72	; *** rom ds 05/20/86 ***
.a648	 ea		nop			nop
.a649	 d0 0c		bne $a657		bne  m3		; bra
.a64b	 ce ab 02	dec $02ab	m2	dec  mtrcnt
.a64e	 d0 07		bne $a657		bne  m3
.a650	 a5 20		lda $20			lda  drvst
.a652	 d0 03		bne $a657		bne  m3
.a654	 20 70 87	jsr $8770		jsr  motoff	; turn off the motor
.a657	 4c b1 f9	jmp $f9b1	m3	jmp  rtch21	; return
.a65a	 a9 02		lda #$02	ptch22  lda  #2
.a65c	 8d 00 18	sta $1800		sta  pb
.a65f	 a9 20		lda #$20		lda  #$20	; *,_atn,2 mhz,*,*,side 0,sr-in,*
.a661	 8d 01 18	sta $1801		sta  pa1
.a664	 4c 18 ff	jmp $ff18		jmp  ptch22r	; ret
.a667	 ad 0f 18	lda $180f	ptch23  lda  pota1	; 1/2 Mhz ?
.a66a	 29 20		and #$20		and  #$20
.a66c	 d0 03		bne $a671		bne  +
.a66e	 4c 86 d5	jmp $d586	-	jmp  doread	; 1541 mode read BAM side 0
.a671	 ad ac 02	lda $02ac	+	lda  maxtrk	; seek ok, on other side ?
.a674	 c9 25		cmp #$25		cmp  #37
.a676	 90 f6		bcc $a66e		bcc  -		; seek regular method
.a678	 20 8b a4	jsr $a48b		jsr  sav_pnt	; save pointers
.a67b	 a9 00		lda #$00		lda  #0
.a67d	 85 6d		sta $6d			sta  bmpnt	; even page
.a67f	 a6 f9		ldx $f9			ldx  jobnum
.a681	 bd e0 fe	lda $fee0,x		lda  bufind,x	; which buffer is it in
.a684	 85 6e		sta $6e			sta  bmpnt+1
.a686	 a9 ff		lda #$ff		lda  #$ff
.a688	 4c 72 ab	jmp $ab72		jmp  ptch70	; *** rom ds 05/14/86 ***
.a68b					rtch70
.a68b	 a5 f9		lda $f9			lda  jobnum
.a68d	 0a		asl a			asl  a
.a68e	 aa		tax			tax
.a68f	 a9 35		lda #$35		lda  #53	; read BAM side one
.a691	 95 06		sta $06,x		sta  hdrs,x	; put track in job queue, same sector
.a693	 20 86 d5	jsr $d586		jsr  doread	; read it
.a696	 c9 02		cmp #$02		cmp  #2		; ok ?
.a698	 6a		ror a			ror  a		; carry set bad return
.a699	 29 80		and #$80		and  #$80	; isolate sign bit
.a69b	 49 80		eor #$80		eor  #$80
.a69d	 8d af 01	sta $01af		sta  dside
.a6a0	 10 0a		bpl $a6ac		bpl  +		; br, error
.a6a2	 a0 68		ldy #$68		ldy  #104
.a6a4	 b1 6d		lda ($6d),y	-	lda  (bmpnt),y	; get BAM 1 and put somewhere in God's country
.a6a6	 99 46 01	sta $0146,y		sta  ovrbuf+$46,y
.a6a9	 88		dey			dey
.a6aa	 10 f8		bpl $a6a4		bpl  -
.a6ac					+
.a6ac	 a9 ff		lda #$ff		lda  #$ff
.a6ae	 8d 98 02	sta $0298		sta  jobrtn	; set error recovery on
.a6b1					rtch70a
.a6b1	 a5 f9		lda $f9			lda  jobnum
.a6b3	 0a		asl a			asl  a
.a6b4	 aa		tax			tax
.a6b5	 ad 85 fe	lda $fe85		lda  dirtrk	; read BAM side zero
.a6b8	 95 06		sta $06,x		sta  hdrs,x	; put track in job queue, same sector
.a6ba	 20 86 d5	jsr $d586		jsr  doread	; read it
.a6bd	 c9 02		cmp #$02		cmp  #2
.a6bf	 90 10		bcc $a6d1		bcc  +
.a6c1	 aa		tax			tax		; save error
.a6c2	 a9 24		lda #$24		lda  #36
.a6c4	 8d ac 02	sta $02ac		sta  maxtrk	; def single sided
.a6c7	 20 96 a4	jsr $a496		jsr  res_pnt	; save BAM pointers
.a6ca	 8a		txa			txa
.a6cb	 20 0a e6	jsr $e60a		jsr  error      ; let the error handler do the rest
.a6ce	 4c 44 d6	jmp $d644		jmp  rec7	; consist
.a6d1	 a0 03		ldy #$03	+	ldy  #3
.a6d3	 b1 6d		lda ($6d),y		lda  (bmpnt),y	; check double sided flag
.a6d5	 2d af 01	and $01af		and  dside	; both must be ok....
.a6d8	 30 03		bmi $a6dd		bmi  +
.a6da	 a9 24		lda #$24		lda  #36

>a6dc	 2c                       		.byte skip2

.a6dd	 a9 47		lda #$47	+	lda  #71
.a6df	 8d ac 02	sta $02ac		sta  maxtrk	; double sided
.a6e2	 4c 24 ab	jmp $ab24		jmp  ptch69	; *** rom ds 05/14/86 fix swap problem ***
.a6e5					ptch24
.a6e5	 20 8c d5	jsr $d58c		jsr  dojob	; seek side zero
.a6e8	 48		pha			pha		; save status
.a6e9	 c9 02		cmp #$02		cmp  #2		; error ?
.a6eb	 b0 49		bcs $a736		bcs  m1		; br, error...
.a6ed	 ad 0f 18	lda $180f		lda  pota1
.a6f0	 29 20		and #$20		and  #$20
.a6f2	 f0 42		beq $a736		beq  m1		; 1/2 Mhz ?
.a6f4	 a9 47		lda #$47		lda  #71
.a6f6	 8d ac 02	sta $02ac		sta  maxtrk	; let DOS think he has double sided capability
.a6f9	 a9 ff		lda #$ff		lda  #$ff
.a6fb	 8d 98 02	sta $0298		sta  jobrtn	; return from error
.a6fe	 a5 16		lda $16			lda  header	; get id's
.a700	 48		pha			pha
.a701	 a5 17		lda $17			lda  header+1
.a703	 48		pha			pha		; save them
.a704	 a5 f9		lda $f9			lda  jobnum
.a706	 0a		asl a			asl  a
.a707	 aa		tax			tax
.a708	 a9 35		lda #$35		lda  #53	; seek side one BAM track
.a70a	 95 06		sta $06,x		sta  hdrs,x	; put track in job queue, same sector
.a70c	 a9 b0		lda #$b0		lda  #seek
.a70e	 20 de aa	jsr $aade		jsr  ptch64 	; make it faster...
.a711	 c9 02		cmp #$02		cmp  #2		; error ?
.a713	 68		pla			pla
.a714	 a8		tay			tay		; header+1
.a715	 68		pla			pla
.a716	 aa		tax			tax		; header
.a717	 b0 0b		bcs $a724		bcs  m2		; error on last job ?
.a719	 e4 16		cpx $16			cpx  header	; same id's ?
.a71b	 d0 07		bne $a724		bne  m2
.a71d	 c4 17		cpy $17		      	cpy  header+1	; same id's ?
.a71f	 d0 03		bne $a724		bne  m2
.a721	 a9 47		lda #$47		lda  #71	; probably double sided

>a723	 2c                       		.byte skip2

.a724	 a9 24		lda #$24	m2	lda  #36
.a726	 8d ac 02	sta $02ac		sta  maxtrk
.a729	 84 17		sty $17			sty  header+1	; restore original id's from side zero
.a72b	 86 16		stx $16			stx  header
.a72d	 a5 f9		lda $f9			lda  jobnum
.a72f	 0a		asl a			asl  a
.a730	 aa		tax			tax
.a731	 ad 85 fe	lda $fe85		lda  dirtrk
.a734	 95 06		sta $06,x		sta  hdrs,x	; put track in job queue, same sector
.a736	 68		pla		m1	pla		; get status
.a737	 60		rts			rts
.a738	 20 3a ef	jsr $ef3a	ptch25 	jsr  setbpt	; setup bit map pointer
.a73b	 ad 0f 18	lda $180f		lda  pota1
.a73e	 29 20		and #$20		and  #%00100000 ; 1/2 Mhz ?
.a740	 f0 0a		beq $a74c		beq  +
.a742	 a9 00		lda #$00		lda  #0
.a744	 a0 68		ldy #$68		ldy  #104	; clr BAM side one
.a746	 99 46 01	sta $0146,y	-	sta  ovrbuf+$46,y
.a749	 88		dey			dey
.a74a	 10 fa		bpl $a746		bpl  -
.a74c	 4c 08 f0	jmp $f008	+	jmp  rtch25	; return
=a74f					otcrgkqo = ptch26
.a74f					ptch26
.a74f	 48		pha			pha		; save .a
.a750	 ad 0f 18	lda $180f		lda  pota1
.a753	 29 20		and #$20		and  #%00100000 ; 1/2 Mhz ?
.a755	 f0 08		beq $a75f		beq  m1
.a757	 68		pla			pla
.a758	 c9 24		cmp #$24		cmp  #36	; > trk 35 ?
.a75a	 90 04		bcc $a760		bcc  m2
.a75c	 e9 23		sbc #$23		sbc  #35

>a75e	 24                       		.byte skip1

.a75f	 68		pla		m1	pla		; restore .a
.a760	 ae d6 fe	ldx $fed6	m2	ldx  nzones	; cont
.a763	 60		rts			rts
.a764	 20 05 f0	jsr $f005	ptch27  jsr  clrbam	; clear BAM area
.a767	 ad 0f 18	lda $180f		lda  pota1
.a76a	 29 20		and #$20		and  #%00100000
.a76c	 d0 03		bne $a771		bne  +		; 1/2 Mhz ?
.a76e	 a9 24		lda #$24		lda  #36

>a770	 2c                       		.byte skip2

.a771	 a9 47		lda #$47	+	lda  #71
.a773	 8d ac 02	sta $02ac		sta  maxtrk	; set maximum track full format
.a776	 4c 43 ee	jmp $ee43		jmp  rtch27	; return
.a779	 ad 0f 18	lda $180f	ptch28  lda  pota1
.a77c	 29 20		and #$20		and  #%00100000
.a77e	 d0 03		bne $a783		bne  +		; 1/2 Mhz ?
.a780	 4c c6 c8	jmp $c8c6		jmp  format	; 1541 mode
.a783	 4c 0d a4	jmp $a40d	+       jmp  jformat	; 1571 mode
.a786	 ad 01 18	lda $1801	ptch29  lda  pa1	; change to 1 mhz
.a789	 29 df		and #$df		and  #%11011111
.a78b	 8d 01 18	sta $1801		sta  pa1
.a78e	 20 83 a4	jsr $a483		jsr  jslowd	; wait for ...
.a791	 a9 7f		lda #$7f		lda  #$7f
.a793	 8d 0d 40	sta $400d		sta  icr	; clear all sources of irq's
.a796	 a9 08		lda #$08		lda  #8
.a798	 8d 0e 40	sta $400e		sta  cra	; turn off timers
.a79b	 8d 0f 40	sta $400f		sta  cra+1	; off him too...
.a79e	 a9 00		lda #$00		lda  #0		; msb nil
.a7a0	 8d 05 40	sta $4005		sta  tima_h
.a7a3	 a9 06		lda #$06		lda  #6		; msb nil
.a7a5	 8d 04 40	sta $4004		sta  tima_l	; 6 us bit cell time
.a7a8	 a9 01		lda #$01		lda  #1
.a7aa	 8d 0e 40	sta $400e		sta  cra	; start timer a
.a7ad	 20 b2 81	jsr $81b2		jsr  spinp	; finish up and enable irq's from '26
.a7b0	 4c 59 ea	jmp $ea59		jmp  tstatn	; chk for atn & goto xidle
.a7b3					ptch30
.a7b3	 20 62 aa	jsr $aa62		jsr  ptch57	; *** rom ds 08/05/85 ***, serial bus fix for a
.a7b6	 29 20		and #$20		and  #%00100000
.a7b8	 f0 03		beq $a7bd		beq  +		; 1/2 Mhz ?
.a7ba	 4c ce 80	jmp $80ce		jmp  jatnsrv	; 2 Mhz
.a7bd	 4c 5b e8	jmp $e85b	+	jmp  atnsrv	; 1 Mhz
.a7c0	 78		sei		ptch31	sei
.a7c1	 a2 45		ldx #$45		ldx  #topwrt	; set stack pointer
.a7c3	 9a		txs			txs
.a7c4	 4c 25 eb	jmp $eb25		jmp  rtch31
.a7c7	 ad 0f 18	lda $180f	ptch32  lda  pota1	; 1/2 Mhz ?
.a7ca	 29 20		and #$20		and  #$20
.a7cc					ptch32a
.a7cc	 d0 09		bne $a7d7		bne  m1
.a7ce	 a0 03		ldy #$03	m6	ldy  #3
.a7d0	 a9 00		lda #$00		lda  #0
.a7d2	 91 6d		sta ($6d),y		sta  (bmpnt),y	; set single sided bit in BAM side 0
.a7d4	 4c b7 ee	jmp $eeb7		jmp  newmap	; finish up 1541 mode
.a7d7	 ad ac 02	lda $02ac	m1	lda  maxtrk	; single/double sided?
.a7da	 c9 25		cmp #$25		cmp  #37
.a7dc	 90 f0		bcc $a7ce		bcc  m6
.a7de	 a0 01		ldy #$01		ldy  #1
.a7e0	 a2 00		ldx #$00		ldx  #0
.a7e2	 c0 12		cpy #$12	m2	cpy  #18
.a7e4	 f0 34		beq $a81a		beq  m4
.a7e6	 8a		txa			txa
.a7e7	 48		pha			pha		; save .x
.a7e8	 a9 00		lda #$00		lda  #0		; start temps at zero
.a7ea	 85 6f		sta $6f			sta  t0
.a7ec	 85 70		sta $70			sta  t1
.a7ee	 85 71		sta $71			sta  t2
.a7f0	 b9 2b 94	lda $942b,y		lda  num_sec-1,y
.a7f3	 aa		tax			tax		; number of sectors per track
.a7f4	 38		sec		-	sec
.a7f5	 26 6f		rol $6f			rol  t0
.a7f7	 26 70		rol $70			rol  t1
.a7f9	 26 71		rol $71			rol  t2
.a7fb	 ca		dex			dex
.a7fc	 d0 f6		bne $a7f4		bne  -
.a7fe	 68		pla			pla
.a7ff	 aa		tax			tax		; restore .x
.a800	 a5 6f		lda $6f			lda  t0		; write BAM side one
.a802	 9d 46 01	sta $0146,x		sta  ovrbuf+$46,x
.a805	 a5 70		lda $70			lda  t1
.a807	 9d 47 01	sta $0147,x		sta  ovrbuf+$46+1,x
.a80a	 a5 71		lda $71			lda  t2
.a80c	 9d 48 01	sta $0148,x		sta  ovrbuf+$46+2,x
.a80f	 e8		inx			inx
.a810	 e8		inx			inx
.a811	 e8		inx			inx
.a812	 e0 33		cpx #$33		cpx  #$33	; skip track 53
.a814	 d0 04		bne $a81a		bne  m4
.a816	 e8		inx			inx
.a817	 e8		inx			inx
.a818	 e8		inx			inx
.a819	 c8		iny			iny		; bypass and leave allocated
.a81a	 c8		iny		m4	iny
.a81b	 c0 24		cpy #$24		cpy  #36
.a81d	 90 c3		bcc $a7e2		bcc  m2
.a81f	 20 b7 ee	jsr $eeb7		jsr  newmap	; generate new BAM for side zero
.a822	 a0 03		ldy #$03		ldy  #3
.a824	 a9 80		lda #$80		lda  #$80
.a826	 91 6d		sta ($6d),y		sta  (bmpnt),y	; set double sided bit in BAM side 0
.a828	 a0 ff		ldy #$ff		ldy  #$ff
.a82a	 a2 22		ldx #$22		ldx  #34
.a82c	 bd 2c 94	lda $942c,x	-	lda  num_sec,x	; get # of free sectors
.a82f	 91 6d		sta ($6d),y		sta  (bmpnt),y	; save in top end of BAM zero
.a831	 88		dey			dey		; => $dd-$ff
.a832	 ca		dex			dex
.a833	 10 f7		bpl $a82c		bpl  -
.a835	 a0 ee		ldy #$ee		ldy  #$ee	; offset for track 53
.a837	 a9 00		lda #$00		lda  #0
.a839	 91 6d		sta ($6d),y		sta  (bmpnt),y	; allocate track 53
.a83b	 4c 75 d0	jmp $d075		jmp  nfcalc	; calculate BAM side 0/1
=a83e					oeunttn = ptch33
.a83e					ptch33
.a83e	 ad 0f 18	lda $180f		lda  pota1	; 1/2 Mhz ?
.a841	 29 20		and #$20		and  #$20
.a843	 d0 06		bne $a84b		bne  +
.a845	 20 cf ef	jsr $efcf	-	jsr  freuse	; track < 36 or 1541 mode
.a848	 4c 62 ef	jmp $ef62		jmp  frets2	; ret
.a84b	 a5 80		lda $80		+	lda  track	; is track greater than 35
.a84d	 c9 24		cmp #$24		cmp  #36
.a84f	 90 f4		bcc $a845		bcc  -
.a851	 20 a1 a4	jsr $a4a1		jsr  set_bm	; setup & update parms
.a854	 20 e7 a4	jsr $a4e7		jsr  bam_pt	; find position within table
.a857	 d0 19		bne $a872		bne  +
.a859	 1d e9 ef	ora $efe9,x		ora  bmask,x	; set it free
.a85c	 99 46 01	sta $0146,y		sta  ovrbuf+$46,y
.a85f	 20 88 ef	jsr $ef88		jsr  dtybam	; set dirty flag
.a862	 20 08 a5	jsr $a508		jsr  deall_b	; deallocate BAM
.a865	 a5 80		lda $80			lda  track
.a867	 c9 35		cmp #$35		cmp  #53	; skip BAM track side one
.a869	 f0 08		beq $a873		beq  m4
.a86b	 a5 7f		lda $7f			lda  drvnum	; get drv #
.a86d	 0a		asl a			asl  a
.a86e	 aa		tax			tax		; *2
.a86f	 4c 7f ef	jmp $ef7f		jmp  fre20	; ret
.a872	 38		sec		+	sec
.a873	 60		rts		m4	rts
.a874	 ad 0f 18	lda $180f	ptch34	lda  pota1	; 1/2 Mhz ?
.a877	 29 20		and #$20		and  #$20
.a879	 d0 06		bne $a881		bne  +
.a87b	 20 cf ef	jsr $efcf	-	jsr  freuse	; track < 36 or 1541 mode
.a87e	 4c 96 ef	jmp $ef96		jmp  rtch34
.a881	 a5 80		lda $80		+	lda  track	; check track
.a883	 c9 24		cmp #$24		cmp  #36
.a885	 90 f4		bcc $a87b		bcc  -
.a887	 20 a1 a4	jsr $a4a1		jsr  set_bm	; setup & update parms
.a88a	 20 e7 a4	jsr $a4e7		jsr  bam_pt	; find position within the BAM
.a88d	 f0 19		beq $a8a8		beq  +
.a88f	 5d e9 ef	eor $efe9,x		eor  bmask,x	; set it used
.a892	 99 46 01	sta $0146,y		sta  ovrbuf+$46,y
.a895	 20 88 ef	jsr $ef88		jsr  dtybam	; set dirty flag
.a898	 20 1e a5	jsr $a51e		jsr  alloc_b	; allocate BAM
.a89b	 a5 80		lda $80			lda  track
.a89d	 c9 35		cmp #$35		cmp  #53	; skip BAM track side one
.a89f	 f0 07		beq $a8a8		beq  +
.a8a1	 a5 7f		lda $7f			lda  drvnum	; get drv #
.a8a3	 0a		asl a			asl  a
.a8a4	 aa		tax			tax
.a8a5	 4c b2 ef	jmp $efb2		jmp  use30
.a8a8	 60		rts		+	rts
.a8a9					ptch35
.a8a9	 ad 0f 18	lda $180f		lda  pota1	; 1/2 Mhz ?
.a8ac	 29 20		and #$20		and  #$20
.a8ae	 d0 06		bne $a8b6		bne  +
.a8b0	 20 11 f0	jsr $f011	-	jsr  setbam	; track < 36 or 1541 mode
.a8b3	 4c fd f1	jmp $f1fd		jmp  rtch35
.a8b6	 a5 80		lda $80		+	lda  track	; check track
.a8b8	 c9 24		cmp #$24		cmp  #36
.a8ba	 90 f4		bcc $a8b0		bcc  -
.a8bc	 20 a1 a4	jsr $a4a1		jsr  set_bm	; setup & update parms
.a8bf	 20 45 a5	jsr $a545		jsr  chk_blk	; chk alloc w/ bits
.a8c2	 b9 2c 94	lda $942c,y		lda  num_sec,y  ; get number of sectors on this track
.a8c5	 8d 4e 02	sta $024e		sta  lstsec	; & save it
.a8c8	 a5 81		lda $81		-	lda  sector	; what sector are we looking at ?
.a8ca	 cd 4e 02	cmp $024e		cmp  lstsec
.a8cd	 b0 09		bcs $a8d8		bcs  +
.a8cf	 20 e7 a4	jsr $a4e7		jsr  bam_pt	; check availability
.a8d2	 d0 06		bne $a8da		bne  m6
.a8d4	 e6 81		inc $81			inc  sector	; we will find something I hope...
.a8d6	 d0 f0		bne $a8c8		bne  -
.a8d8	 a9 00		lda #$00	+	lda  #0
.a8da	 60		rts		m6	rts		; (z=1) used
.a8db	 ad 0f 18	lda $180f	ptch36  lda  pota1	; 1/2 Mhz ?
.a8de	 29 20		and #$20		and  #$20
.a8e0	 d0 06		bne $a8e8		bne  +
.a8e2	 a5 6f		lda $6f		-	lda  temp
.a8e4	 48		pha			pha
.a8e5	 4c 30 f1	jmp $f130		jmp  rtch36
.a8e8	 a5 80		lda $80		+	lda  track	; check track
.a8ea	 c9 24		cmp #$24		cmp  #36
.a8ec	 90 f4		bcc $a8e2		bcc  -
.a8ee	 c9 35		cmp #$35		cmp  #53
.a8f0	 f0 0e		beq $a900		beq  +
.a8f2	 a5 6f		lda $6f			lda  temp
.a8f4	 48		pha			pha		; save temp var
.a8f5	 20 a1 a4	jsr $a4a1		jsr  set_bm	; setup & update parms
.a8f8	 a8		tay			tay		; save .a
.a8f9	 68		pla			pla
.a8fa	 85 6f		sta $6f			sta  temp	; restore temp
.a8fc	 98		tya			tya		; return allocation status in .a
.a8fd	 4c 38 f1	jmp $f138		jmp  rtch36a
.a900	 a9 00		lda #$00	+	lda  #0		; z=1
.a902	 4c 38 f1	jmp $f138		jmp  rtch36a	; track 53 allocated
.a905	 ad 0f 18	lda $180f	ptch37  lda  pota1	; 1/2 Mhz ?
.a908	 29 20		and #$20		and  #$20
.a90a	 d0 06		bne $a912		bne  +
.a90c	 20 11 f0	jsr $f011	-	jsr  setbam	; setup the BAM pointer
.a90f	 4c c7 f1	jmp $f1c7		jmp  rtch37	; ret
.a912	 a5 80		lda $80		+	lda  track	; check track
.a914	 c9 24		cmp #$24		cmp  #36
.a916	 90 f4		bcc $a90c		bcc  -
.a918	 20 a1 a4	jsr $a4a1		jsr  set_bm	; setup & update parms
.a91b	 4c c9 f1	jmp $f1c9		jmp  rtch37a
.a91e	 ad 0f 18	lda $180f	ptch38  lda  pota1	; 1/2 Mhz ?
.a921	 29 20		and #$20		and  #$20
.a923	 d0 06		bne $a92b		bne  +
.a925	 20 11 f0	jsr $f011	-	jsr  setbam	; setup the BAM pointer
.a928	 4c e2 f1	jmp $f1e2		jmp  rtch38	; ret
.a92b	 a5 80		lda $80		+	lda  track	; check track
.a92d	 c9 24		cmp #$24		cmp  #36
.a92f	 90 f4		bcc $a925		bcc  -
.a931	 20 a1 a4	jsr $a4a1		jsr  set_bm	; setup & update parms
.a934	 4c e4 f1	jmp $f1e4		jmp  rtch38a
.a937	 ad 0f 18	lda $180f	ptch39	lda  pota1	; 1/2 Mhz ?
.a93a	 29 20		and #$20		and  #$20
.a93c	 d0 03		bne $a941		bne  +
.a93e	 4c 20 f2	jmp $f220	-	jmp  avck	; check block availability
.a941	 ad ac 02	lda $02ac	+	lda  maxtrk	; check maximum track
.a944	 c9 25		cmp #$25		cmp  #37
.a946	 90 f6		bcc $a93e		bcc  -
.a948	 a5 80		lda $80			lda  track	; check track do regular check
.a94a	 c9 24		cmp #$24		cmp  #36
.a94c	 90 f0		bcc $a93e		bcc  -
.a94e	 4c 45 a5	jmp $a545		jmp  chk_blk	; finish up
=a951					oteunho = ptch40
.a951					ptch40
.a951	 9d fa 02	sta $02fa,x		sta  ndbl,x	; save low order
.a954	 ad 0f 18	lda $180f		lda  pota1	; 1/2 Mhz ?
.a957	 29 20		and #$20		and  #$20
.a959	 f0 23		beq $a97e		beq  m1
.a95b	 ad ac 02	lda $02ac		lda  maxtrk	; check maximum track
.a95e	 c9 25		cmp #$25		cmp  #37
.a960	 90 1c		bcc $a97e		bcc  m1
.a962	 20 8b a4	jsr $a48b		jsr  sav_pnt	; save pointers
.a965	 20 34 a5	jsr $a534		jsr  where	; locate BAM
.a968	 a0 22		ldy #$22		ldy  #34	; count backwards and sleep........zzzzZZZZZZZZ
.a96a	 ad fa 02	lda $02fa		lda  ndbl
.a96d	 18		clc		-	clc
.a96e	 71 6d		adc ($6d),y		adc  (bmpnt),y	; count it up
.a970	 8d fa 02	sta $02fa		sta  ndbl	; keep track HAHA !!!
.a973	 90 03		bcc $a978		bcc  +
.a975	 ee fc 02	inc $02fc		inc  ndbh	; increment msb
.a978	 88		dey		+	dey
.a979	 10 f2		bpl $a96d		bpl  -
.a97b	 4c 96 a4	jmp $a496		jmp  res_pnt	; restore pointers
.a97e	 60		rts		m1	rts		; done
.a97f	 95 b5		sta $b5,x	ptch41  sta  nbkl,x
.a981	 95 bb		sta $bb,x		sta  nbkh,x
.a983	 a9 00		lda #$00		lda  #0
.a985	 9d 44 02	sta $0244,x		sta  lstchr,x
.a988	 60		rts			rts
.a989	 20 0d a4	jsr $a40d	ptch42  jsr  jformat	; format disk in GCR
.a98c	 a0 00		ldy #$00		ldy  #0
.a98e	 8c 98 02	sty $0298		sty  jobrtn
.a991	 60		rts			rts

.a99d	 a9 00		lda #$00	ptch43  lda  #0		; clr nodrv

>a99f	 9d ff 00                 		.byte $9d,$ff,$00

.a9a2	 4c b7 c1	jmp $c1b7		jmp  rtch43
.a9a5	 98		tya		ptch44  tya		; set/clr nodrv

>a9a6	 9d ff 00                 		.byte $9d,$ff,$00

.a9a9	 4c 64 c6	jmp $c664		jmp  rtch44
.a9ac	 ad 0f 18	lda $180f	ptch45  lda  pota1	; 1/2 Mhz ?
.a9af	 29 20		and #$20		and  #$20
.a9b1	 f0 03		beq $a9b6		beq  +
.a9b3	 4c 5a 81	jmp $815a		jmp  a2		; 1571 mode
.a9b6	 4c d7 e8	jmp $e8d7	+	jmp  atns20	; 1541 mode
.a9b9	 48		pha		ptch46	pha		; save error
.a9ba	 86 f9		stx $f9			stx  jobnum	; save job #
.a9bc	 ad 0f 18	lda $180f		lda  pota1	; 1/2 Mhz ?
.a9bf	 29 20		and #$20		and  #$20
.a9c1	 f0 0f		beq $a9d2		beq  +
.a9c3	 24 37		bit $37			bit  fastsr	; error recovery on ?
.a9c5	 10 0b		bpl $a9d2		bpl  +
.a9c7	 a5 37		lda $37			lda  fastsr
.a9c9	 29 7f		and #$7f		and  #$7f	; clr error recovery
.a9cb	 85 37		sta $37			sta  fastsr
.a9cd	 68		pla			pla		; get error
.a9ce	 aa		tax			tax
.a9cf	 4c 99 91	jmp $9199		jmp  ctr_err	; let it error out
.a9d2	 4c 0d e6	jmp $e60d	+	jmp  rtch46	; return
.a9d5	 48		pha		ptch47	pha		; save error
.a9d6	 ad 0f 18	lda $180f		lda  pota1	; 1/2 Mhz ?
.a9d9	 29 20		and #$20		and  #$20
.a9db	 f0 17		beq $a9f4		beq  +
.a9dd	 24 37		bit $37			bit  fastsr	; error recovery on ?
.a9df	 10 13		bpl $a9f4		bpl  +
.a9e1	 a5 37		lda $37			lda  fastsr
.a9e3	 29 7f		and #$7f		and  #$7f	; clr error recovery
.a9e5	 85 37		sta $37			sta  fastsr
.a9e7	 78		sei			sei
.a9e8	 a2 02		ldx #$02		ldx  #2
.a9ea	 20 28 92	jsr $9228		jsr  handsk	; send it
.a9ed	 a9 00		lda #$00		lda  #0
.a9ef	 85 83		sta $83			sta  sa
.a9f1	 20 c0 da	jsr $dac0		jsr  close	; close channel
.a9f4	 68		pla		+	pla		; get error #
.a9f5	 4c 45 e6	jmp $e645		jmp  cmder2
.a9f8	 a9 00		lda #$00	ptch48  lda  #0
.a9fa	 85 20		sta $20			sta  drvst	; clr drive status
.a9fc	 ad 0c 1c	lda $1c0c		lda  pcr2	; set edge and latch mode
.a9ff	 4c 66 f2	jmp $f266		jmp  rtch48
.aa02					ptch49
.aa02	 ad 00 02	lda $0200		lda  cmdbuf	; is there a 'U0n' cmd waiting in the wings
.aa05	 c9 55		cmp #$55		cmp  #'U'
.aa07	 d0 07		bne $aa10		bne  m1		; br, no 'U'
.aa09	 ad 01 02	lda $0201		lda  cmdbuf+1
.aa0c	 c9 30		cmp #$30		cmp  #'0'
.aa0e	 f0 04		beq $aa14		beq  m2		; br, we got it toyota
.aa10	 b9 00 02	lda $0200,y	m1	lda  cmdbuf,y	; get char

>aa13	 2c                       		.byte skip2

.aa14	 a9 00		lda #$00	m2	lda  #0		; null
.aa16	 60		rts			rts
.aa17	 a6 7f		ldx $7f		ptch50	ldx  drvnum	; get offset

>aa19	 bd ff 00                 		.byte $bd,$ff,$00

.aa1c	 60		rts			rts
.aa1d	 95 1c		sta $1c,x	ptch51	sta  wpsw,x	; clr wp switch

>aa1f	 9d ff 00                 		.byte $9d,$ff,$00

.aa22	 4c 75 d0	jmp $d075		jmp  rtch51
.aa25	 a6 7f		ldx $7f		ptch52	ldx  drvnum	; get offset

>aa27	 bd ff 00                 		.byte $bd,$ff,$00

.aa2a	 4c 1b f0	jmp $f01b		jmp  rtch52
.aa2d	 a5 75		lda $75		ptch53  lda  ip
.aa2f	 c9 67		cmp #$67		cmp  #<sysirq	; irq ?
.aa31	 d0 09		bne $aa3c		bne  +
.aa33	 a5 76		lda $76			lda  ip+1
.aa35	 c9 fe		cmp #$fe		cmp  #>sysirq	; irq ?
.aa37	 d0 03		bne $aa3c		bne  +
.aa39	 00		brk			brk		; do irq and return
.aa3a	 ea		nop			nop
.aa3b	 60		rts			rts
.aa3c	 6c 75 00	jmp ($0075)	+	jmp  (ip)
.aa3f	 c9 02		cmp #$02	ptch54  cmp  #2		; error ?
.aa41	 90 07		bcc $aa4a		bcc  +
.aa43	 c9 0f		cmp #$0f		cmp  #15	; no drv condition ?
.aa45	 f0 03		beq $aa4a		beq  +
.aa47	 4c 6b d3	jmp $d36b		jmp  rtch54	; bad, try another
.aa4a	 4c 73 d3	jmp $d373	+	jmp  stl50	; ok
.aa4d	 85 51		sta $51		ptch55  sta  ftnum	; clear flag
.aa4f	 20 7c 87	jsr $877c		jsr  led_on	; lights on
.aa52	 20 89 a9	jsr $a989		jsr  ptch42	; format it
.aa55	 48		pha			pha		; save error
.aa56	 20 88 87	jsr $8788		jsr  led_off	; turn off the lights
.aa59	 68		pla			pla
.aa5a	 60		rts			rts
.aa5b	 a5 e7		lda $e7		ptch56  lda  pattyp	; check file type
.aa5d	 29 07		and #$07		and  #typmsk	; remove other bits
.aa5f	 c9 02		cmp #$02		cmp  #2
.aa61	 60		rts			rts
.aa62	 ad 0f 18	lda $180f	ptch57  lda  pota1	; 1/2 Mhz ?
.aa65	 2c 01 18	bit $1801		bit  pa1	; clear h/w interrupt source
.aa68	 60		rts			rts
.aa69	 ad 0f 18	lda $180f	ptch58  lda  pota1	; 1/2 Mhz ?
.aa6c	 29 20		and #$20		and  #$20
.aa6e	 d0 03		bne $aa73		bne  +
.aa70	 4c b7 ee	jmp $eeb7		jmp  newmap	; finish up 1541 mode
.aa73	 4c cc a7	jmp $a7cc	+	jmp  ptch32a	; bra, go doit !!!
.aa76	 a9 02		lda #$02	ptch59  lda  #2
.aa78	 8d 05 18	sta $1805		sta  t1hc1	; wait 256 uS
.aa7b	 60		rts			rts
.aa7c	 ad b3 01	lda $01b3	ptch60  lda  vertog	; verify ?
.aa7f	 d0 03		bne $aa84		bne  +		; br, no verify
.aa81	 4c c6 8e	jmp $8ec6		jmp  cmdele	; doit
.aa84	 18		clc		+	clc		; say ok...
.aa85	 60		rts			rts
.aa86	 a8		tay		ptch61	tay
.aa87	 c9 56		cmp #$56		cmp  #'V'	; fast read ?
.aa89	 d0 1d		bne $aaa8		bne  devs
.aa8b	 78		sei			sei		; no irq's
.aa8c	 ad 0f 18	lda $180f		lda  pota1
.aa8f	 29 20		and #$20		and  #$20
.aa91	 d0 03		bne $aa96		bne  +
.aa93	 4c 21 90	jmp $9021	-	jmp  utlbad	; 1571 only
.aa96	 ad 04 02	lda $0204	+	lda  cmdbuf+4	; which ?
.aa99	 c9 31		cmp #$31		cmp  #'1'
.aa9b	 f0 04		beq $aaa1		beq  +
.aa9d	 c9 30		cmp #$30		cmp  #'0'
.aa9f	 d0 f2		bne $aa93		bne  -		; no switch specified
.aaa1	 29 cf		and #$cf	+	and  #$ff-$30
.aaa3	 8d b3 01	sta $01b3		sta  vertog	; save flag
.aaa6	 58		cli			cli
.aaa7	 60		rts			rts
.aaa8	 c0 04		cpy #$04	devs	cpy #4
.aaaa	 4c 06 90	jmp $9006		jmp  rtch61
.aaad	 ad b3 01	lda $01b3	ptch62	lda  vertog	; to verify or not to verify ?
.aab0	 d0 04		bne $aab6		bne  +
.aab2	 b9 00 00	lda $0000,y		lda  jobs,y	; get job

>aab5	 2c                       		.byte skip2

.aab6	 a9 30		lda #$30	+	lda  #$30	; verify is off
.aab8	 49 30		eor #$30		eor  #$30
.aaba	 99 00 00	sta $0000,y		sta  jobs,y
.aabd	 d0 03		bne $aac2		bne  +
.aabf	 4c b5 99	jmp $99b5		jmp  jerrr	; done
.aac2	 4c 4f 94	jmp $944f	+	jmp  jseak	; return
.aac5	 20 f9 85	jsr $85f9	ptch63	jsr  hskrd	; send interleave
.aac8	 a9 20		lda #$20		lda  #bit5
.aaca	 24 3b		bit $3b			bit  switch	; send sector table ?
.aacc	 f0 0f		beq $aadd		beq  +
.aace	 a0 00		ldy #$00		ldy  #0
.aad0	 b9 0b 02	lda $020b,y	-	lda  cmdbuf+11,y
.aad3	 85 46		sta $46			sta  ctl_dat	; get ready to send
.aad5	 20 f9 85	jsr $85f9		jsr  hskrd	; send it
.aad8	 c8		iny			iny
.aad9	 c4 97		cpy $97			cpy  cpmsek	; send whole thing
.aadb	 d0 f3		bne $aad0		bne  -
.aadd	 60		rts		+	rts		; done
.aade	 a6 f9		ldx $f9		ptch64	ldx  jobnum	; get job #
.aae0	 09 08		ora #$08		ora  #$08	; sector seek...
.aae2	 95 00		sta $00,x		sta  jobs,x
.aae4	 4c b6 9f	jmp $9fb6		jmp  stbctl	; this better work!!!
.aae7					ptch65
.aae7	 20 ed aa	jsr $aaed		jsr  burst_doit
.aaea	 4c 94 c1	jmp $c194		jmp  endcmd
.aaed					burst_doit
.aaed	 6c 75 00	jmp ($0075)		jmp  (ip)
.aaf0					ptch66
.aaf0	 c9 03		cmp #$03		cmp  #3
.aaf2	 b0 05		bcs $aaf9		bcs  +
.aaf4	 a9 72		lda #$72		lda  #dskful
.aaf6	 20 c7 e6	jsr $e6c7		jsr  errmsg
.aaf9	 a9 01		lda #$01	+	lda  #1
.aafb	 60		rts			rts
.aafc					ptch67
.aafc	 08		php			php
.aafd	 78		sei			sei
.aafe	 a9 00		lda #$00		lda  #0
.ab00	 f8		sed			sed
.ab01	 e0 00		cpx #$00	-	cpx  #0
.ab03	 f0 07		beq $ab0c	        beq  +
.ab05	 18		clc		        clc
.ab06	 69 01		adc #$01	        adc  #1
.ab08	 ca		dex		        dex
.ab09	 4c 01 ab	jmp $ab01	        jmp  -
.ab0c	 28		plp		+	plp
.ab0d	 4c aa e6	jmp $e6aa		jmp  hex5
.ab10					ptch68
.ab10	 08		php			php
.ab11	 78		sei			sei
.ab12	 8d 0c 40	sta $400c		sta  sdr	; send it
.ab15	 a5 37		lda $37		        lda  fastsr
.ab17	 49 04		eor #$04	        eor  #4         ; change state of clk
.ab19	 85 37		sta $37		        sta  fastsr
.ab1b	 a9 08		lda #$08	        lda  #8
.ab1d	 2c 0d 40	bit $400d	-	bit  icr	; wait transmission time
.ab20	 f0 fb		beq $ab1d	        beq  -
.ab22	 28		plp			plp
.ab23	 60		rts		        rts
.ab24					ptch69
.ab24	 ad ac 02	lda $02ac		lda  maxtrk	; double sided?
.ab27	 c9 25		cmp #$25		cmp  #37
.ab29	 90 44		bcc $ab6f		bcc  m5
.ab2b	 a5 6f		lda $6f			lda  temp
.ab2d	 48		pha			pha		; save temp
.ab2e	 a5 80		lda $80			lda  track
.ab30	 48		pha			pha
.ab31	 a0 00		ldy #$00		ldy  #0
.ab33	 84 80		sty $80			sty  track
.ab35	 a9 00		lda #$00	m1	lda  #0
.ab37	 85 6f		sta $6f			sta  temp	; start at zero
.ab39	 a9 01		lda #$01		lda  #>bam_one
.ab3b	 85 6e		sta $6e			sta  bmpnt+1	; msb
.ab3d	 b9 db a5	lda $a5db,y		lda  bmindx,y	; starts here
.ab40	 18		clc			clc
.ab41	 69 46		adc #$46		adc  #<bam_one	; add offset
.ab43	 85 6d		sta $6d			sta  bmpnt
.ab45	 a0 02		ldy #$02		ldy  #2
.ab47	 a2 07		ldx #$07	m2	ldx  #7		; verify bit map to count value
.ab49	 b1 6d		lda ($6d),y	-	lda  (bmpnt),y
.ab4b	 3d e9 ef	and $efe9,x		and  bmask,x
.ab4e	 f0 02		beq $ab52		beq  +
.ab50	 e6 6f		inc $6f			inc  temp	; on free increment
.ab52	 ca		dex		+	dex
.ab53	 10 f4		bpl $ab49		bpl  -
.ab55	 88		dey			dey
.ab56	 10 ef		bpl $ab47		bpl  m2
.ab58	 20 34 a5	jsr $a534		jsr  where	; where is the BAM
.ab5b	 a5 6f		lda $6f			lda  temp
.ab5d	 a4 80		ldy $80			ldy  track
.ab5f	 91 6d		sta ($6d),y		sta  (bmpnt),y
.ab61	 e6 80		inc $80			inc  track
.ab63	 a4 80		ldy $80			ldy  track
.ab65	 c0 23		cpy #$23		cpy  #35
.ab67	 90 cc		bcc $ab35		bcc  m1		; check side one
.ab69	 68		pla			pla
.ab6a	 85 80		sta $80			sta  track	; restore track,
.ab6c	 68		pla			pla
.ab6d	 85 6f		sta $6f			sta  temp	; temp,
.ab6f	 4c 96 a4	jmp $a496	m5	jmp  res_pnt	; and bam pointers
.ab72					ptch70
.ab72	 8d 98 02	sta $0298		sta  jobrtn
.ab75	 48		pha			pha
.ab76	 ad b4 01	lda $01b4		lda  swapfg	; read bam one?
.ab79	 f0 09		beq $ab84		beq  +
.ab7b	 a9 00		lda #$00		lda  #0
.ab7d	 8d b4 01	sta $01b4		sta  swapfg	; clr it
.ab80	 68		pla			pla
.ab81	 4c 8b a6	jmp $a68b		jmp  rtch70	; yes
.ab84	 a9 80		lda #$80	+	lda  #$80
.ab86	 8d af 01	sta $01af		sta  dside
.ab89	 68		pla			pla
.ab8a	 4c b1 a6	jmp $a6b1		jmp  rtch70a	; nope
.ab8d					ptch71
.ab8d	 20 8b a4	jsr $a48b		jsr  sav_pnt
.ab90	 20 24 ab	jsr $ab24		jsr  ptch69	; we can rebuild 'em, we have the technology!
.ab93	 4c 8b a4	jmp $a48b		jmp  sav_pnt
.ab96					ptch72
.ab96	 a9 01		lda #$01		lda  #1
.ab98	 85 1c		sta $1c			sta  wpsw
.ab9a	 8d b4 01	sta $01b4		sta  swapfg	; mark bam one out of memory
.ab9d	 60		rts			rts
.ab9e					ptch73
.ab9e	 a9 01		lda #$01		lda  #1		; BAM is out of mem
.aba0	 8d b4 01	sta $01b4		sta  swapfg
.aba3	 4c 67 a6	jmp $a667		jmp  ptch23	; continue on...
.aba6					ptch74
.aba6	 a9 01		lda #$01		lda  #1
.aba8	 85 1c		sta $1c			sta  wpsw
.abaa	 8d b4 01	sta $01b4		sta  swapfg
.abad	 4c 42 d0	jmp $d042		jmp  initdr

;******  Return to file "serlib.asm"

						.include "romsf.asm"

;******  Processing file "romsf.asm"

.c000					cchksm

>c001	 28 43 29 31 39 38 35 20 		.text '(C)1985 COMMODORE ELECTRONICS LTD., ALL RIGHTS RESERVED'
>c009	 43 4f 4d 4d 4f 44 4f 52 
>c011	 45 20 45 4c 45 43 54 52 
>c019	 4f 4e 49 43 53 20 4c 54 
>c021	 44 2e 2c 20 41 4c 4c 20 
>c029	 52 49 47 48 54 53 20 52 
>c031	 45 53 45 52 56 45 44 

.c038	 29 fc		and #$fc	ptch0a	and  #$ff-3
.c03a	 05 4b		ora $4b			ora  tmp
.c03c	 8d 00 1c	sta $1c00		sta  dskcnt
.c03f	 ad 0c 1c	lda $1c0c	ptch0b	lda  pcr2	; disable SO
.c042	 29 fd		and #$fd		and  #$ff-2
.c044	 8d 0c 1c	sta $1c0c		sta  pcr2
.c047	 60		rts			rts

>c048	 29 1f 19 12              	trackn  .byte 41,31,25,18

.c04c					worktable

>c04c	 60 60 60 60 60 60 60 60 		.byte $60,$60,$60,$60,$60,$60,$60,$60,$60,$60
>c054	 60 60 
>c056	 60 60 60 60 60 60 60     		.byte $60,$60,$60,$60,$60,$60,$60
>c05d	 40 40 40 40 40 40 40     		.byte $40,$40,$40,$40,$40,$40,$40
>c064	 20 20 20 20 20 20        		.byte $20,$20,$20,$20,$20,$20
>c06a	 00 00 00 00 00           		.byte $00,$00,$00,$00,$00
>c06f	 00 00 00 00 00 00        		.byte $00,$00,$00,$00,$00,$00

.c075	 8d 4d 02	sta $024d	ptch0c	sta cmd		; save off cmd for DOS
.c078	 48		pha			pha
.c079	 a9 01		lda #$01		lda #1		; trk one
.c07b	 95 06		sta $06,x		sta hdrs,x
.c07d	 68		pla			pla
.c07e	 60		rts			rts		; return
.c07f	 78		sei		ptch0d  sei		; no irq's
.c080	 ad 0c 1c	lda $1c0c		lda  pcr2
.c083	 09 0e		ora #$0e		ora  #$0e
.c085	 8d 0c 1c	sta $1c0c		sta  pcr2	; enable SO
.c088	 20 63 9d	jsr $9d63		jsr  jclear	; clear track (val in .x)
.c08b	 20 00 fe	jsr $fe00		jsr  kill	; disable write
.c08e	 ad 0c 1c	lda $1c0c		lda  pcr2
.c091	 29 f1		and #$f1		and  #$ff-$0e
.c093	 8d 0c 1c	sta $1c0c		sta  pcr2	; disable SO
.c096	 58		cli			cli
.c097	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "leds.asm"

;******  Processing file "leds.asm"


.c100	 78		sei		setlds  sei
.c101	 a9 f7		lda #$f7	        lda  #$ff-led1-led0
.c103	 2d 00 1c	and $1c00	        and  ledprt
.c106	 48		pha		        pha
.c107	 a5 7f		lda $7f		        lda  drvnum
.c109	 f0 05		beq $c110	        beq  leds0
.c10b	 68		pla		        pla
.c10c	 09 00		ora #$00	        ora  #led1
.c10e	 d0 03		bne $c113	        bne  leds1
.c110					leds0
.c110	 68		pla		        pla
.c111	 09 08		ora #$08	        ora  #led0
.c113					leds1
.c113	 8d 00 1c	sta $1c00	        sta  ledprt
.c116	 58		cli		        cli
.c117	 60		rts		        rts
.c118	 78		sei		ledson  sei
.c119	 a9 08		lda #$08	        lda  #led1+led0
.c11b	 0d 00 1c	ora $1c00	        ora  ledprt
.c11e	 8d 00 1c	sta $1c00	        sta  ledprt
.c121	 58		cli		        cli
.c122	 60		rts		        rts
.c123					erroff
.c123	 a9 00		lda #$00	        lda  #0
.c125	 8d 6c 02	sta $026c	        sta  erword
.c128	 8d 6d 02	sta $026d	        sta  erled
.c12b	 60		rts		        rts
.c12c	 78		sei		erron   sei
.c12d	 8a		txa		        txa
.c12e	 48		pha		        pha     	; save .x
.c12f	 a9 50		lda #$50	        lda  #80
.c131	 8d 6c 02	sta $026c	        sta  erword
.c134	 a2 00		ldx #$00	        ldx  #0
.c136	 bd ca fe	lda $feca,x	        lda  ledmsk,x
.c139	 8d 6d 02	sta $026d	        sta  erled
.c13c	 0d 00 1c	ora $1c00	        ora  ledprt     ; set led on
.c13f	 8d 00 1c	sta $1c00	        sta  ledprt
.c142	 68		pla		        pla
.c143	 aa		tax		        tax     	; restore .x
.c144	 58		cli		        cli
.c145	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "parsex.asm"

;******  Processing file "parsex.asm"

.c146					parsxq
.c146	 a9 00		lda #$00	        lda  #0
.c148	 8d f9 02	sta $02f9	        sta  wbam
.c14b	 ad 8e 02	lda $028e	        lda  lstdrv
.c14e	 85 7f		sta $7f		        sta  drvnum
.c150	 20 bc e6	jsr $e6bc	        jsr  okerr
.c153	 a5 84		lda $84		        lda  orgsa
.c155	 10 09		bpl $c160	        bpl  ps05
.c157	 29 0f		and #$0f	        and  #$f
.c159	 c9 0f		cmp #$0f	        cmp  #$f
.c15b	 f0 03		beq $c160	        beq  ps05
.c15d	 4c b4 d7	jmp $d7b4	        jmp  open
.c160	 20 b3 c2	jsr $c2b3	ps05    jsr  cmdset     ; set variables,regs
.c163	 b1 a3		lda ($a3),y	        lda  (cb),y
.c165	 8d 75 02	sta $0275	        sta  char
.c168	 a2 0b		ldx #$0b	        ldx  #ncmds-1   ; search cmd table
.c16a	 bd 89 fe	lda $fe89,x	ps10    lda  cmdtbl,x
.c16d	 cd 75 02	cmp $0275	        cmp  char
.c170	 f0 08		beq $c17a	        beq  ps20
.c172	 ca		dex		        dex
.c173	 10 f5		bpl $c16a	        bpl  ps10
.c175	 a9 31		lda #$31	        lda  #badcmd    ; no such cmd
.c177	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.c17a	 8e 2a 02	stx $022a	ps20    stx  cmdnum     ; x= cmd #
.c17d	 e0 09		cpx #$09	        cpx  #pcmd      ; cmds not parsed
.c17f	 90 03		bcc $c184	        bcc  ps30
.c181	 20 ee c1	jsr $c1ee	        jsr  tagcmd     ; set tables, pointers &patterns
.c184	 ae 2a 02	ldx $022a	ps30    ldx  cmdnum
.c187	 bd 95 fe	lda $fe95,x	        lda  cjumpl,x
.c18a	 85 6f		sta $6f		        sta  temp
.c18c	 bd a1 fe	lda $fea1,x	        lda  cjumph,x
.c18f	 85 70		sta $70		        sta  temp+1
.c191	 6c 6f 00	jmp ($006f)	        jmp  (temp)     ; command table jump
.c194					endcmd
.c194	 a9 00		lda #$00	        lda  #0
.c196	 8d f9 02	sta $02f9	        sta  wbam
.c199					endsav
.c199	 ad 6c 02	lda $026c	        lda  erword
.c19c	 d0 2a		bne $c1c8	        bne  cmderr
.c19e	 a0 00		ldy #$00	        ldy  #0
.c1a0	 98		tya		        tya
.c1a1	 84 80		sty $80		        sty  track
.c1a3	 84 81		sty $81		scrend  sty  sector     ; scratch entry
.c1a5	 84 a3		sty $a3		        sty  cb
.c1a7	 20 c7 e6	jsr $e6c7	        jsr  errmsg
.c1aa	 20 23 c1	jsr $c123	        jsr  erroff
.c1ad					scren1
.c1ad	 a5 7f		lda $7f		        lda  drvnum
.c1af	 8d 8e 02	sta $028e	        sta  lstdrv
.c1b2	 aa		tax		        tax
.c1b3	 4c 9d a9	jmp $a99d		jmp  ptch43	; *** rom ds 05/01/85 ***
.c1b6	 ea		nop			nop		; fill
.c1b7					rtch43
.c1b7	 20 bd c1	jsr $c1bd	        jsr  clrcb
.c1ba	 4c da d4	jmp $d4da	        jmp  freich     ; free internal channel
.c1bd					clrcb
.c1bd	 a0 28		ldy #$28	        ldy  #cmdlen-1
.c1bf	 a9 00		lda #$00	        lda  #0
.c1c1					clrb2
.c1c1	 99 00 02	sta $0200,y	        sta  cmdbuf,y
.c1c4	 88		dey		        dey
.c1c5	 10 fa		bpl $c1c1	        bpl  clrb2
.c1c7	 60		rts		        rts
.c1c8	 a0 00		ldy #$00	cmderr  ldy  #0
.c1ca	 84 80		sty $80		        sty  track
.c1cc	 84 81		sty $81		        sty  sector
.c1ce	 4c d5 a9	jmp $a9d5		jmp  ptch47	; *** rom ds 03/31/85 ***
.c1d1	 a2 00		ldx #$00	simprs  ldx  #0         ; simple parser
.c1d3	 8e 7a 02	stx $027a	        stx  filtbl
.c1d6	 a9 3a		lda #$3a	        lda  #':'
.c1d8	 20 68 c2	jsr $c268	        jsr  parse
.c1db	 f0 05		beq $c1e2	        beq  sp10
.c1dd	 88		dey		        dey
.c1de	 88		dey		        dey
.c1df	 8c 7a 02	sty $027a	        sty  filtbl
.c1e2	 4c 68 c3	jmp $c368	sp10    jmp  setany     ; set drive #
.c1e5					prscln
.c1e5	 a0 00		ldy #$00	        ldy  #0
.c1e7	 a2 00		ldx #$00	        ldx  #0
.c1e9	 a9 3a		lda #$3a	        lda  #':'
.c1eb	 4c 68 c2	jmp $c268	        jmp  parse      ; find pos'n of ":"
.c1ee					tagcmd
.c1ee	 20 e5 c1	jsr $c1e5	        jsr  prscln
.c1f1	 d0 05		bne $c1f8	        bne  tc30
.c1f3	 a9 34		lda #$34	tc25    lda  #nofile    ; none, no files
.c1f5	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.c1f8	 88		dey		tc30    dey
.c1f9	 88		dey		        dey
.c1fa	 8c 7a 02	sty $027a	        sty  filtbl     ; ":"-1 starts fs1
.c1fd	 8a		txa		        txa
.c1fe	 d0 f3		bne $c1f3	        bne  tc25       ; err: "," before ":"
.c200	 a9 3d		lda #$3d	tc35    lda  #'='       ; search: "="
.c202	 20 68 c2	jsr $c268	        jsr  parse
.c205	 8a		txa		        txa     	; ?file count= 1-1?
.c206	 f0 02		beq $c20a	        beq  tc40
.c208	 a9 40		lda #$40	        lda  #%01000000 ; g1-bit
.c20a	 09 21		ora #$21	tc40    ora  #%00100001 ; e1,^e2-bits
.c20c	 8d 8b 02	sta $028b	        sta  image      ; fs structure
.c20f	 e8		inx		        inx
.c210	 8e 77 02	stx $0277	        stx  f1cnt
.c213	 8e 78 02	stx $0278	        stx  f2cnt      ; init for no fs2
.c216	 ad 8a 02	lda $028a	        lda  patflg
.c219	 f0 0d		beq $c228	        beq  tc50
.c21b	 a9 80		lda #$80	        lda  #%10000000 ; p1-bit
.c21d	 0d 8b 02	ora $028b	        ora  image
.c220	 8d 8b 02	sta $028b	        sta  image
.c223	 a9 00		lda #$00	        lda  #0
.c225	 8d 8a 02	sta $028a	        sta  patflg     ; clear pattern flag
.c228	 98		tya		tc50    tya     	; ptr to fs2
.c229	 f0 29		beq $c254	        beq  tc75       ;  fs2 not here
.c22b	 9d 7a 02	sta $027a,x	        sta  filtbl,x
.c22e	 ad 77 02	lda $0277	        lda  f1cnt      ; fs2 is here now,...
.c231	 8d 79 02	sta $0279	        sta  f2ptr      ; ...now set f2 ptr
.c234	 a9 8d		lda #$8d	        lda  #$8d       ; find cr-shifted
.c236	 20 68 c2	jsr $c268	        jsr  parse      ; parse rest of cmd string
.c239	 e8		inx		        inx     	; advance filtbl ptr to end
.c23a	 8e 78 02	stx $0278	        stx  f2cnt      ; save it
.c23d	 ca		dex		        dex     	; restore for test
.c23e	 ad 8a 02	lda $028a	        lda  patflg     ; save last pattern
.c241	 f0 02		beq $c245	        beq  tc60       ; ?any patterns?
.c243	 a9 08		lda #$08	        lda  #%1000     ; yes, p2-bit
.c245	 ec 77 02	cpx $0277	tc60    cpx  f1cnt      ; ?f2cnt=f1cnt+1?
.c248	 f0 02		beq $c24c	        beq  tc70
.c24a	 09 04		ora #$04	        ora  #%0100     ; g2-bit
.c24c	 09 03		ora #$03	tc70    ora  #%0011     ; e2-bit,^e2-bit
.c24e	 4d 8b 02	eor $028b	        eor  image      ; eor clears ^e2-bit
.c251	 8d 8b 02	sta $028b	        sta  image
.c254					tc75
.c254	 ad 8b 02	lda $028b	        lda  image
.c257	 ae 2a 02	ldx $022a	        ldx  cmdnum
.c25a	 3d a5 fe	and $fea5,x	        and  struct,x   ; match cmd template
.c25d	 d0 01		bne $c260	        bne  tc80
.c25f	 60		rts		        rts
.c260	 8d 6c 02	sta $026c	tc80    sta  erword     ; **could be warning
.c263	 a9 30		lda #$30	        lda  #badsyn    ; err: bad syntax
.c265	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.c268	 8d 75 02	sta $0275	parse   sta  char       ; save var'bl char
.c26b	 cc 74 02	cpy $0274	pr10    cpy  cmdsiz     ; stay in string
.c26e	 b0 2e		bcs $c29e	        bcs  pr30
.c270	 b1 a3		lda ($a3),y	        lda  (cb),y     ; match char
.c272	 c8		iny		        iny
.c273	 cd 75 02	cmp $0275	        cmp  char
.c276	 f0 28		beq $c2a0	        beq  pr35       ; found char
.c278	 c9 2a		cmp #$2a	        cmp  #'*'       ; match pattern chars
.c27a	 f0 04		beq $c280	        beq  pr20
.c27c	 c9 3f		cmp #$3f	        cmp  #'?'
.c27e	 d0 03		bne $c283	        bne  pr25
.c280	 ee 8a 02	inc $028a	pr20    inc  patflg     ; set pattern flag
.c283	 c9 2c		cmp #$2c	pr25    cmp  #','       ; match file separator
.c285	 d0 e4		bne $c26b	        bne  pr10
.c287	 98		tya		        tya
.c288	 9d 7b 02	sta $027b,x	        sta  filtbl+1,x ; put ptrs in table
.c28b	 ad 8a 02	lda $028a	        lda  patflg     ; save pattern for ea file
.c28e	 29 7f		and #$7f	        and  #$7f
.c290	 f0 07		beq $c299	        beq  pr28
.c292	 a9 80		lda #$80	        lda  #$80       ; retain pattern presence...
.c294	 95 e7		sta $e7,x	        sta  pattyp,x
.c296	 8d 8a 02	sta $028a	        sta  patflg     ; ...but clear count
.c299	 e8		inx		pr28    inx
.c29a	 e0 04		cpx #$04	        cpx  #mxfils-1
.c29c	 90 cd		bcc $c26b	        bcc  pr10       ; no more than mxfils
.c29e	 a0 00		ldy #$00	pr30    ldy  #0         ; y=0 (z=1)
.c2a0	 ad 74 02	lda $0274	pr35    lda  cmdsiz
.c2a3	 9d 7b 02	sta $027b,x	        sta  filtbl+1,x
.c2a6	 ad 8a 02	lda $028a	        lda  patflg
.c2a9	 29 7f		and #$7f	        and  #$7f
.c2ab	 f0 04		beq $c2b1	        beq  pr40
.c2ad	 a9 80		lda #$80	        lda  #$80
.c2af	 95 e7		sta $e7,x	        sta  pattyp,x
.c2b1	 98		tya		pr40    tya     	; z is set
.c2b2	 60		rts		        rts
.c2b3	 a4 a3		ldy $a3		cmdset  ldy  buftab+cbptr
.c2b5	 f0 14		beq $c2cb	        beq  cs08
.c2b7	 88		dey		        dey
.c2b8	 f0 10		beq $c2ca	        beq  cs07
.c2ba	 20 02 aa	jsr $aa02		jsr  ptch49	; *** rom ds 04/14/85 ***
.c2bd	 c9 0d		cmp #$0d	        cmp  #cr
.c2bf	 f0 0a		beq $c2cb	        beq  cs08
.c2c1	 88		dey		        dey
.c2c2	 20 02 aa	jsr $aa02		jsr  ptch49	; *** rom ds 04/14/85 ***
.c2c5	 c9 0d		cmp #$0d	        cmp  #cr
.c2c7	 f0 02		beq $c2cb	        beq  cs08
.c2c9	 c8		iny		        iny
.c2ca	 c8		iny		cs07    iny
.c2cb	 8c 74 02	sty $0274	cs08    sty  cmdsiz     ; set cmd string size
.c2ce	 c0 2a		cpy #$2a	        cpy  #cmdlen+1
.c2d0	 a0 ff		ldy #$ff	        ldy  #$ff
.c2d2	 90 08		bcc $c2dc	        bcc  cmdrst
.c2d4	 8c 2a 02	sty $022a	        sty  cmdnum
.c2d7	 a9 32		lda #$32	        lda  #longln    ; long line error
.c2d9	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.c2dc					cmdrst
.c2dc	 a0 00		ldy #$00	        ldy  #0
.c2de	 98		tya		        tya
.c2df	 85 a3		sta $a3		        sta  buftab+cbptr
.c2e1	 8d 58 02	sta $0258	        sta  rec
.c2e4	 8d 4a 02	sta $024a	        sta  type
.c2e7	 8d 96 02	sta $0296	        sta  typflg
.c2ea	 85 d3		sta $d3		        sta  f1ptr
.c2ec	 8d 79 02	sta $0279	        sta  f2ptr
.c2ef	 8d 77 02	sta $0277	        sta  f1cnt
.c2f2	 8d 78 02	sta $0278	        sta  f2cnt
.c2f5	 8d 8a 02	sta $028a	        sta  patflg
.c2f8	 8d 6c 02	sta $026c	        sta  erword
.c2fb	 a2 05		ldx #$05	        ldx  #mxfils
.c2fd	 9d 79 02	sta $0279,x	cs10    sta  filtbl-1,x
.c300	 95 d7		sta $d7,x	        sta  entsec-1,x
.c302	 95 dc		sta $dc,x	        sta  entind-1,x
.c304	 95 e1		sta $e1,x	        sta  fildrv-1,x
.c306	 95 e6		sta $e6,x	        sta  pattyp-1,x
.c308	 9d 7f 02	sta $027f,x	        sta  filtrk-1,x
.c30b	 9d 84 02	sta $0284,x	        sta  filsec-1,x
.c30e	 ca		dex		        dex
.c30f	 d0 ec		bne $c2fd	        bne  cs10
.c311	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "setdrv.asm"

;******  Processing file "setdrv.asm"

.c312	 ad 78 02	lda $0278	onedrv  lda  f2cnt
.c315	 8d 77 02	sta $0277	        sta  f1cnt
.c318	 a9 01		lda #$01	        lda  #1
.c31a	 8d 78 02	sta $0278	        sta  f2cnt
.c31d	 8d 79 02	sta $0279	        sta  f2ptr
.c320	 ac 8e 02	ldy $028e	alldrs  ldy  lstdrv
.c323	 a2 00		ldx #$00	        ldx  #0         ; ...into file entry table...
.c325	 86 d3		stx $d3		ad10    stx  f1ptr      ; ...on sector ptr byte
.c327	 bd 7a 02	lda $027a,x	        lda  filtbl,x
.c32a	 20 3c c3	jsr $c33c	        jsr  setdrv
.c32d	 a6 d3		ldx $d3		        ldx  f1ptr
.c32f	 9d 7a 02	sta $027a,x	        sta  filtbl,x   ; incr ptr past ":"
.c332	 98		tya		        tya     	; bits rep drives
.c333	 95 e2		sta $e2,x	        sta  fildrv,x   ; bit7: default
.c335	 e8		inx		        inx     	; bit0: drive #
.c336	 ec 78 02	cpx $0278	        cpx  f2cnt
.c339	 90 ea		bcc $c325	        bcc  ad10
.c33b	 60		rts		        rts
.c33c	 aa		tax		setdrv  tax     	; x= cmdbuf index
.c33d	 a0 00		ldy #$00	        ldy  #0         ; set default drive to zero
.c33f	 a9 3a		lda #$3a	        lda  #':'
.c341	 dd 01 02	cmp $0201,x	        cmp  cmdbuf+1,x ; for xxx:file
.c344	 f0 0c		beq $c352	        beq  sd40       ;       ^
.c346	 dd 00 02	cmp $0200,x	        cmp  cmdbuf,x   ; for xxx:file
.c349	 d0 16		bne $c361	        bne  sd50       ;        ^
.c34b	 e8		inx		        inx     	; found ":", so...
.c34c	 98		tya		sd20    tya     	; drive= default
.c34d	 29 01		and #$01	sd22    and  #1         ; convert to numeric
.c34f	 a8		tay		sd24    tay     	; restore drive
.c350	 8a		txa		        txa     	; a=index & xxxxfile
.c351	 60		rts		        rts     	;               ^
.c352	 bd 00 02	lda $0200,x	sd40    lda  cmdbuf,x
.c355	 e8		inx		        inx     	;  xxx:file
.c356	 e8		inx		        inx     	;    --^
.c357	 c9 30		cmp #$30	        cmp  #'0'       ; for xx0:file
.c359	 f0 f2		beq $c34d	        beq  sd22       ;         ^
.c35b	 c9 31		cmp #$31		cmp  #'1'	; drive one?
.c35d	 f0 ee		beq $c34d		beq  sd22
.c35f	 d0 eb		bne $c34c		bne  sd20
.c361	 98		tya		sd50    tya     	; for xxx,file or xx=file
.c362	 09 80		ora #$80	        ora  #$80       ;         ^          ^
.c364	 29 81		and #$81	        and  #$81       ; drive= -default
.c366	 d0 e7		bne $c34f	        bne  sd24       ; finish testing
.c368	 a9 00		lda #$00	setany  lda  #0         ; set drv frm any config
.c36a	 8d 8b 02	sta $028b	        sta  image
.c36d	 ac 7a 02	ldy $027a	        ldy  filtbl
.c370	 b1 a3		lda ($a3),y	sa05    lda  (cb),y
.c372	 20 bd c3	jsr $c3bd	        jsr  tst0v1
.c375	 10 11		bpl $c388	        bpl  sa20
.c377	 c8		iny		        iny
.c378	 cc 74 02	cpy $0274	        cpy  cmdsiz
.c37b	 b0 06		bcs $c383	        bcs  sa10
.c37d	 ac 74 02	ldy $0274	        ldy  cmdsiz
.c380	 88		dey		        dey
.c381	 d0 ed		bne $c370	        bne  sa05
.c383	 ce 8b 02	dec $028b	sa10    dec  image
.c386	 a9 00		lda #$00	        lda  #0
.c388	 29 01		and #$01	sa20    and  #1
.c38a	 85 7f		sta $7f		        sta  drvnum
.c38c	 4c 00 c1	jmp $c100	        jmp  setlds
.c38f	 a5 7f		lda $7f		togdrv  lda  drvnum
.c391	 49 01		eor #$01	        eor  #1
.c393	 29 01		and #$01	        and  #1
.c395	 85 7f		sta $7f		        sta  drvnum
.c397	 60		rts		        rts
.c398	 a0 00		ldy #$00	fs1set  ldy  #0
.c39a	 ad 77 02	lda $0277	        lda  f1cnt
.c39d	 cd 78 02	cmp $0278	        cmp  f2cnt
.c3a0	 f0 16		beq $c3b8	        beq  fs15
.c3a2	 ce 78 02	dec $0278	        dec  f2cnt
.c3a5	 ac 78 02	ldy $0278	        ldy  f2cnt
.c3a8	 b9 7a 02	lda $027a,y	        lda  filtbl,y
.c3ab	 a8		tay		        tay
.c3ac	 b1 a3		lda ($a3),y	        lda  (cb),y
.c3ae	 a0 04		ldy #$04	        ldy  #ntypes-1
.c3b0	 d9 bb fe	cmp $febb,y	fs10    cmp  typlst,y
.c3b3	 f0 03		beq $c3b8	        beq  fs15
.c3b5	 88		dey		        dey
.c3b6	 d0 f8		bne $c3b0	        bne  fs10
.c3b8	 98		tya		fs15    tya
.c3b9	 8d 96 02	sta $0296	        sta  typflg
.c3bc	 60		rts		        rts
.c3bd	 c9 30		cmp #$30	tst0v1  cmp  #'0'
.c3bf	 f0 06		beq $c3c7	        beq  t0v1
.c3c1	 c9 31		cmp #$31	        cmp  #'1'
.c3c3	 f0 02		beq $c3c7	        beq  t0v1
.c3c5	 09 80		ora #$80	        ora  #$80
.c3c7	 29 81		and #$81	t0v1    and  #$81
.c3c9	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "lookup.asm"

;******  Processing file "lookup.asm"

.c3ca	 a9 00		lda #$00	optsch  lda  #0         ; determine optimal search
.c3cc	 85 6f		sta $6f		        sta  temp       ; init drive mask
.c3ce	 8d 8d 02	sta $028d	        sta  drvflg
.c3d1	 48		pha		        pha
.c3d2	 ae 78 02	ldx $0278	        ldx  f2cnt
.c3d5	 68		pla		os10    pla
.c3d6	 05 6f		ora $6f		        ora  temp
.c3d8	 48		pha		        pha
.c3d9	 a9 01		lda #$01	        lda  #1
.c3db	 85 6f		sta $6f		        sta  temp
.c3dd	 ca		dex		        dex
.c3de	 30 0f		bmi $c3ef	        bmi  os30
.c3e0	 b5 e2		lda $e2,x	        lda  fildrv,x
.c3e2	 10 04		bpl $c3e8	        bpl  os15
.c3e4	 06 6f		asl $6f		        asl  temp
.c3e6	 06 6f		asl $6f		        asl  temp
.c3e8	 4a		lsr a		os15    lsr  a
.c3e9	 90 ea		bcc $c3d5	        bcc  os10
.c3eb	 06 6f		asl $6f		        asl  temp
.c3ed	 d0 e6		bne $c3d5	        bne  os10       ; (branch)
.c3ef	 68		pla		os30    pla
.c3f0	 aa		tax		        tax
.c3f1	 bd 3f c4	lda $c43f,x	        lda  schtbl-1,x
.c3f4	 48		pha		        pha
.c3f5	 29 03		and #$03	        and  #3
.c3f7	 8d 8c 02	sta $028c	        sta  drvcnt
.c3fa	 68		pla		        pla
.c3fb	 0a		asl a		        asl  a
.c3fc	 10 3e		bpl $c43c	        bpl  os40
.c3fe	 a5 e2		lda $e2		        lda  fildrv
.c400	 29 01		and #$01	os35    and  #1
.c402	 85 7f		sta $7f		        sta  drvnum
.c404	 ad 8c 02	lda $028c	        lda  drvcnt
.c407	 f0 2b		beq $c434	        beq  os60       ; only one drive addressed
.c409	 20 3d c6	jsr $c63d	        jsr  autoi      ; check drive for autoinit
.c40c	 f0 12		beq $c420	        beq  os50       ; drive is active
.c40e	 20 8f c3	jsr $c38f	        jsr  togdrv
.c411	 a9 00		lda #$00	        lda  #0         ; set 1 drive addressed
.c413	 8d 8c 02	sta $028c	        sta  drvcnt
.c416	 20 3d c6	jsr $c63d	        jsr  autoi      ; check drive for autoinit
.c419	 f0 1e		beq $c439	        beq  os70       ; drive is active
.c41b					os45
.c41b	 a9 74		lda #$74	        lda  #nodriv
.c41d	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.c420					os50
.c420	 20 8f c3	jsr $c38f	        jsr  togdrv
.c423	 20 3d c6	jsr $c63d	        jsr  autoi      ; check drive for autoinit
.c426	 08		php		        php
.c427	 20 8f c3	jsr $c38f	        jsr  togdrv
.c42a	 28		plp		        plp
.c42b	 f0 0c		beq $c439	        beq  os70       ; drive is active
.c42d	 a9 00		lda #$00	        lda  #0         ; set 1 drive addressed
.c42f	 8d 8c 02	sta $028c	        sta  drvcnt
.c432	 f0 05		beq $c439	        beq  os70       ; bra
.c434					os60
.c434	 20 3d c6	jsr $c63d	        jsr  autoi      ; check drive for autoinit
.c437	 d0 e2		bne $c41b	        bne  os45       ; drive is not active
.c439					os70
.c439	 4c 00 c1	jmp $c100	        jmp  setlds
.c43c	 2a		rol a		os40    rol  a
.c43d	 4c 00 c4	jmp $c400	        jmp  os35

>c440	 00 80 41                 	schtbl  .byte    0,$80,$41
>c443	 01 01 01 01              		.byte    1,1,1,1
>c447	 81 81 81 81              		.byte    $81,$81,$81,$81
>c44b	 42 42 42 42              		.byte    $42,$42,$42,$42

.c44f	 20 ca c3	jsr $c3ca	lookup  jsr  optsch
.c452	 a9 00		lda #$00	lk05    lda  #0
.c454	 8d 92 02	sta $0292	        sta  delind
.c457	 20 ac c5	jsr $c5ac	        jsr  srchst     ; start search
.c45a	 d0 19		bne $c475	        bne  lk25
.c45c	 ce 8c 02	dec $028c	lk10    dec  drvcnt
.c45f	 10 01		bpl $c462	        bpl  lk15
.c461	 60		rts		        rts     	; no more drive searches
.c462	 a9 01		lda #$01	lk15    lda  #1         ; toggle drive #
.c464	 8d 8d 02	sta $028d	        sta  drvflg
.c467	 20 8f c3	jsr $c38f	        jsr  togdrv
.c46a	 20 00 c1	jsr $c100	        jsr  setlds     ;  turn on led
.c46d	 4c 52 c4	jmp $c452	        jmp  lk05
.c470	 20 17 c6	jsr $c617	lk20    jsr  search     ; find valid fn
.c473	 f0 10		beq $c485	        beq  lk30       ; end of search
.c475	 20 d8 c4	jsr $c4d8	lk25    jsr  compar     ; compare dir w/ table
.c478	 ad 8f 02	lda $028f	        lda  found      ; found flag
.c47b	 f0 01		beq $c47e	        beq  lk26       ; all fn's not found, yet
.c47d	 60		rts		        rts
.c47e	 ad 53 02	lda $0253	lk26    lda  entfnd
.c481	 30 ed		bmi $c470	        bmi  lk20
.c483	 10 f0		bpl $c475	        bpl  lk25
.c485	 ad 8f 02	lda $028f	lk30    lda  found
.c488	 f0 d2		beq $c45c	        beq  lk10
.c48a	 60		rts		        rts
.c48b	 20 04 c6	jsr $c604	ffre    jsr  srre       ; find file re-entry
.c48e	 f0 1a		beq $c4aa	        beq  ff10
.c490	 d0 28		bne $c4ba	        bne  ff25
.c492	 a9 01		lda #$01	ff15    lda  #1
.c494	 8d 8d 02	sta $028d	        sta  drvflg
.c497	 20 8f c3	jsr $c38f	        jsr  togdrv
.c49a	 20 00 c1	jsr $c100	        jsr  setlds
.c49d	 a9 00		lda #$00	ffst    lda  #0         ; find file start entry
.c49f	 8d 92 02	sta $0292	        sta  delind
.c4a2	 20 ac c5	jsr $c5ac	        jsr  srchst
.c4a5	 d0 13		bne $c4ba	        bne  ff25
.c4a7	 8d 8f 02	sta $028f	        sta  found
.c4aa	 ad 8f 02	lda $028f	ff10    lda  found
.c4ad	 d0 28		bne $c4d7	        bne  ff40
.c4af	 ce 8c 02	dec $028c	        dec  drvcnt
.c4b2	 10 de		bpl $c492	        bpl  ff15
.c4b4	 60		rts		        rts
.c4b5	 20 17 c6	jsr $c617	fndfil  jsr  search     ; find file continuous...
.c4b8	 f0 f0		beq $c4aa	        beq  ff10       ; ... re-entry, no channel activity
.c4ba	 20 d8 c4	jsr $c4d8	ff25    jsr  compar     ; compare file names
.c4bd	 ae 53 02	ldx $0253	        ldx  entfnd
.c4c0	 10 07		bpl $c4c9	        bpl  ff30
.c4c2	 ad 8f 02	lda $028f	        lda  found
.c4c5	 f0 ee		beq $c4b5	        beq  fndfil
.c4c7	 d0 0e		bne $c4d7	        bne  ff40
.c4c9	 ad 96 02	lda $0296	ff30    lda  typflg
.c4cc	 f0 09		beq $c4d7	        beq  ff40       ; no type restriction
.c4ce	 b5 e7		lda $e7,x	        lda  pattyp,x
.c4d0	 29 07		and #$07	        and  #typmsk
.c4d2	 cd 96 02	cmp $0296	        cmp  typflg
.c4d5	 d0 de		bne $c4b5	        bne  fndfil
.c4d7	 60		rts		ff40    rts
.c4d8	 a2 ff		ldx #$ff	compar  ldx  #$ff
.c4da	 8e 53 02	stx $0253	        stx  entfnd
.c4dd	 e8		inx		        inx
.c4de	 8e 8a 02	stx $028a	        stx  patflg
.c4e1	 20 89 c5	jsr $c589	        jsr  cmpchk
.c4e4	 f0 06		beq $c4ec	        beq  cp10
.c4e6	 60		rts		cp02    rts     	; all are found
.c4e7	 20 94 c5	jsr $c594	cp05    jsr  cc10
.c4ea	 d0 fa		bne $c4e6	        bne  cp02
.c4ec	 a5 7f		lda $7f		cp10    lda  drvnum
.c4ee	 55 e2		eor $e2,x	        eor  fildrv,x
.c4f0	 4a		lsr a		        lsr  a
.c4f1	 90 0b		bcc $c4fe	        bcc  cp20       ; right drive
.c4f3	 29 40		and #$40	        and  #$40
.c4f5	 f0 f0		beq $c4e7	        beq  cp05       ; no default
.c4f7	 a9 02		lda #$02	        lda  #2
.c4f9	 cd 8c 02	cmp $028c	        cmp  drvcnt
.c4fc	 f0 e9		beq $c4e7	        beq  cp05       ; don't use default
.c4fe	 bd 7a 02	lda $027a,x	cp20    lda  filtbl,x   ; good drive match
.c501	 aa		tax		        tax
.c502	 20 a6 c6	jsr $c6a6	        jsr  fndlmt
.c505	 a0 03		ldy #$03	        ldy  #3
.c507	 4c 1d c5	jmp $c51d	        jmp  cp33
.c50a					cp30
.c50a	 bd 00 02	lda $0200,x	        lda  cmdbuf,x
.c50d	 d1 94		cmp ($94),y	        cmp  (dirbuf),y
.c50f	 f0 0a		beq $c51b	        beq  cp32       ; chars are =
.c511	 c9 3f		cmp #$3f	        cmp  #'?'
.c513	 d0 d2		bne $c4e7	        bne  cp05       ; no single pattern
.c515	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c517	 c9 a0		cmp #$a0	        cmp  #$a0
.c519	 f0 cc		beq $c4e7	        beq  cp05       ; end of filename
.c51b					cp32
.c51b	 e8		inx		        inx
.c51c	 c8		iny		        iny
.c51d					cp33
.c51d	 ec 76 02	cpx $0276	        cpx  limit
.c520	 b0 09		bcs $c52b	        bcs  cp34       ; end of pattern
.c522	 bd 00 02	lda $0200,x	        lda  cmdbuf,x
.c525	 c9 2a		cmp #$2a	        cmp  #'*'
.c527	 f0 0c		beq $c535	        beq  cp40       ; star matches all
.c529	 d0 df		bne $c50a	        bne  cp30       ; keep checking
.c52b					cp34
.c52b	 c0 13		cpy #$13	        cpy  #19
.c52d	 b0 06		bcs $c535	        bcs  cp40       ; end of filename
.c52f	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c531	 c9 a0		cmp #$a0	        cmp  #$a0
.c533	 d0 b2		bne $c4e7	        bne  cp05
.c535	 ae 79 02	ldx $0279	cp40    ldx  f2ptr      ; filenames match
.c538	 8e 53 02	stx $0253	        stx  entfnd
.c53b	 b5 e7		lda $e7,x	        lda  pattyp,x   ; store info in tables
.c53d	 29 80		and #$80	        and  #$80
.c53f	 8d 8a 02	sta $028a	        sta  patflg
.c542	 ad 94 02	lda $0294	        lda  index
.c545	 95 dd		sta $dd,x	        sta  entind,x
.c547	 a5 81		lda $81		        lda  sector
.c549	 95 d8		sta $d8,x	        sta  entsec,x
.c54b	 a0 00		ldy #$00	        ldy  #0
.c54d	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c54f	 c8		iny		        iny
.c550	 48		pha		        pha
.c551	 29 40		and #$40	        and  #$40
.c553	 85 6f		sta $6f		        sta  temp
.c555	 68		pla		        pla
.c556	 29 df		and #$df	        and  #$ff-$20
.c558	 30 02		bmi $c55c	        bmi  cp42
.c55a	 09 20		ora #$20	        ora  #$20
.c55c					cp42
.c55c	 29 27		and #$27	        and  #$27
.c55e	 05 6f		ora $6f		        ora  temp
.c560	 85 6f		sta $6f		        sta  temp
.c562	 a9 80		lda #$80	        lda  #$80
.c564	 35 e7		and $e7,x	        and  pattyp,x
.c566	 05 6f		ora $6f		        ora  temp
.c568	 95 e7		sta $e7,x	        sta  pattyp,x
.c56a	 b5 e2		lda $e2,x	        lda  fildrv,x
.c56c	 29 80		and #$80	        and  #$80
.c56e	 05 7f		ora $7f		        ora  drvnum
.c570	 95 e2		sta $e2,x	        sta  fildrv,x
.c572	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c574	 9d 80 02	sta $0280,x	        sta  filtrk,x
.c577	 c8		iny		        iny
.c578	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c57a	 9d 85 02	sta $0285,x	        sta  filsec,x
.c57d	 ad 58 02	lda $0258	        lda  rec
.c580	 d0 07		bne $c589	        bne  cp50
.c582	 a0 15		ldy #$15	        ldy  #21
.c584	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c586	 8d 58 02	sta $0258	        sta  rec
.c589					cp50
.c589	 a9 ff		lda #$ff	cmpchk  lda  #$ff
.c58b	 8d 8f 02	sta $028f	        sta  found
.c58e	 ad 78 02	lda $0278	        lda  f2cnt
.c591	 8d 79 02	sta $0279	        sta  f2ptr
.c594	 ce 79 02	dec $0279	cc10    dec  f2ptr
.c597	 10 01		bpl $c59a	        bpl  cc15
.c599	 60		rts		        rts     	; table exhausted
.c59a	 ae 79 02	ldx $0279	cc15    ldx  f2ptr
.c59d	 b5 e7		lda $e7,x	        lda  pattyp,x
.c59f	 30 05		bmi $c5a6	        bmi  cc20
.c5a1	 bd 80 02	lda $0280,x	        lda  filtrk,x
.c5a4	 d0 ee		bne $c594	        bne  cc10
.c5a6	 a9 00		lda #$00	cc20    lda  #0
.c5a8	 8d 8f 02	sta $028f	        sta  found
.c5ab	 60		rts		        rts
.c5ac					srchst
.c5ac	 a0 00		ldy #$00	        ldy  #0         ; init deleted sector
.c5ae	 8c 91 02	sty $0291	        sty  delsec
.c5b1	 88		dey		        dey
.c5b2	 8c 53 02	sty $0253	        sty  entfnd
.c5b5	 ad 85 fe	lda $fe85	        lda  dirtrk     ; start search at beginning
.c5b8	 85 80		sta $80		        sta  track
.c5ba	 a9 01		lda #$01	        lda  #1
.c5bc	 85 81		sta $81		        sta  sector
.c5be	 8d 93 02	sta $0293	        sta  lstbuf
.c5c1	 20 75 d4	jsr $d475	        jsr  opnird     ; open internal read chnl
.c5c4	 ad 93 02	lda $0293	sr10    lda  lstbuf     ; last buffer if 0
.c5c7	 d0 01		bne $c5ca	        bne  sr15
.c5c9	 60		rts		        rts     	; (z=1)
.c5ca	 a9 07		lda #$07	sr15    lda  #7
.c5cc	 8d 95 02	sta $0295	        sta  filcnt
.c5cf	 a9 00		lda #$00	        lda  #0         ; read track #
.c5d1	 20 f6 d4	jsr $d4f6	        jsr  drdbyt
.c5d4	 8d 93 02	sta $0293	        sta  lstbuf     ; update end flag
.c5d7	 20 e8 d4	jsr $d4e8	sr20    jsr  getpnt
.c5da	 ce 95 02	dec $0295	        dec  filcnt
.c5dd	 a0 00		ldy #$00	        ldy  #0
.c5df	 b1 94		lda ($94),y	        lda  (dirbuf),y ; read file type
.c5e1	 d0 18		bne $c5fb	        bne  sr30
.c5e3	 ad 91 02	lda $0291	        lda  delsec     ; deleted entry found
.c5e6	 d0 2f		bne $c617	        bne  search     ; deleted entry already found
.c5e8	 20 3b de	jsr $de3b	        jsr  curblk     ; get current sector
.c5eb	 a5 81		lda $81		        lda  sector
.c5ed	 8d 91 02	sta $0291	        sta  delsec
.c5f0	 a5 94		lda $94		        lda  dirbuf     ; get current index
.c5f2	 ae 92 02	ldx $0292	        ldx  delind     ; bit1: want deleted entry
.c5f5	 8d 92 02	sta $0292	        sta  delind
.c5f8	 f0 1d		beq $c617	        beq  search     ; need valid entry
.c5fa	 60		rts		        rts     	; (z=0)
.c5fb	 a2 01		ldx #$01	sr30    ldx  #1
.c5fd	 ec 92 02	cpx $0292	        cpx  delind     ; ?looking for deleted?
.c600	 d0 2d		bne $c62f	        bne  sr50       ;  no!
.c602	 f0 13		beq $c617	        beq  search
.c604	 ad 85 fe	lda $fe85	srre    lda  dirtrk
.c607	 85 80		sta $80		        sta  track
.c609	 ad 90 02	lda $0290	        lda  dirsec
.c60c	 85 81		sta $81		        sta  sector
.c60e	 20 75 d4	jsr $d475	        jsr  opnird
.c611	 ad 94 02	lda $0294	        lda  index
.c614	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.c617	 a9 ff		lda #$ff	search  lda  #$ff
.c619	 8d 53 02	sta $0253	        sta  entfnd
.c61c	 ad 95 02	lda $0295	        lda  filcnt     ; adjust file count
.c61f	 30 08		bmi $c629	        bmi  sr40
.c621	 a9 20		lda #$20	        lda  #32        ; incr by 32
.c623	 20 c6 d1	jsr $d1c6	        jsr  incptr
.c626	 4c d7 c5	jmp $c5d7	        jmp  sr20
.c629	 20 4d d4	jsr $d44d	sr40    jsr  nxtbuf     ; new buffer
.c62c	 4c c4 c5	jmp $c5c4	        jmp  sr10       ; (branch)
.c62f	 a5 94		lda $94		sr50    lda  dirbuf     ; found valid entry
.c631	 8d 94 02	sta $0294	        sta  index      ; save index
.c634	 20 3b de	jsr $de3b	        jsr  curblk     ; get sector
.c637	 a5 81		lda $81		        lda  sector
.c639	 8d 90 02	sta $0290	        sta  dirsec
.c63c	 60		rts		        rts     	; (z=0)
.c63d					autoi
.c63d	 a5 68		lda $68		        lda  autofg
.c63f	 d0 28		bne $c669	        bne  auto2      ; auto-init is disabled
.c641	 a6 7f		ldx $7f		        ldx  drvnum
.c643	 56 1c		lsr $1c,x	        lsr  wpsw,x     ; test & clear wpsw
.c645	 90 22		bcc $c669	        bcc  auto2      ; no change in diskette
.c647	 a9 ff		lda #$ff	        lda  #$ff
.c649	 8d 98 02	sta $0298	        sta  jobrtn     ; set error return code
.c64c	 20 0e d0	jsr $d00e	        jsr  itrial     ; init-seek test
.c64f	 a0 ff		ldy #$ff	        ldy  #$ff       ;  .y= true
.c651	 c9 02		cmp #$02	        cmp  #2
.c653	 f0 0a		beq $c65f	        beq  auto1      ; no sync= no diskette
.c655	 c9 03		cmp #$03	        cmp  #3
.c657	 f0 06		beq $c65f	        beq  auto1      ; no header= no directory
.c659	 c9 0f		cmp #$0f	        cmp  #$f
.c65b	 f0 02		beq $c65f	        beq  auto1      ; no drive!!!!
.c65d	 a0 00		ldy #$00	        ldy  #0         ; set .y false
.c65f					auto1
.c65f	 a6 7f		ldx $7f		        ldx  drvnum
.c661	 4c a5 a9	jmp $a9a5		jmp  ptch44	; *** rom ds 05/01/85 ***
.c664					rtch44
.c664	 d0 03		bne $c669	        bne  auto2      ; no need to init crud!
.c666	 20 42 d0	jsr $d042	        jsr  initdr     ; init that drive
.c669					auto2
.c669	 a6 7f		ldx $7f		        ldx  drvnum
.c66b	 4c 17 aa	jmp $aa17		jmp  ptch50	; *** rom ds 05/01/85 ***

;******  Return to file "serlib.asm"

						.include "trnsfr.asm"

;******  Processing file "trnsfr.asm"

.c66e	 48		pha		trname  pha     	; trnsfr fname fr cmd to buf
.c66f	 20 a6 c6	jsr $c6a6	        jsr  fndlmt     ;  a: string size
.c672	 20 88 c6	jsr $c688	        jsr  trcmbf     ;  x: starting index in cmdbuf
.c675	 68		pla		        pla     	;  y: buffer #
.c676	 38		sec		        sec
.c677	 ed 4b 02	sbc $024b	        sbc  strsiz
.c67a	 aa		tax		        tax
.c67b	 f0 0a		beq $c687	        beq  tn20
.c67d	 90 08		bcc $c687	        bcc  tn20
.c67f	 a9 a0		lda #$a0	        lda  #$a0
.c681	 91 94		sta ($94),y	tn10    sta  (dirbuf),y
.c683	 c8		iny		        iny
.c684	 ca		dex		        dex
.c685	 d0 fa		bne $c681	        bne  tn10
.c687	 60		rts		tn20    rts
.c688	 98		tya		trcmbf  tya     	; trnsfr cmd buf to other buf
.c689	 0a		asl a		        asl  a          ; uses current buffer ptr
.c68a	 a8		tay		        tay     	; limit:ending index+1 in cmd buf
.c68b	 b9 99 00	lda $0099,y	        lda  buftab,y   ;  x: starting index in cmd buf
.c68e	 85 94		sta $94		        sta  dirbuf     ;  y: buffer #
.c690	 b9 9a 00	lda $009a,y	        lda  buftab+1,y
.c693	 85 95		sta $95		        sta  dirbuf+1
.c695	 a0 00		ldy #$00	        ldy  #0
.c697	 bd 00 02	lda $0200,x	tr10    lda  cmdbuf,x
.c69a	 91 94		sta ($94),y	        sta  (dirbuf),y
.c69c	 c8		iny		        iny
.c69d	 f0 06		beq $c6a5	        beq  tr20
.c69f	 e8		inx		        inx
.c6a0	 ec 76 02	cpx $0276	        cpx  limit
.c6a3	 90 f2		bcc $c697	        bcc  tr10
.c6a5	 60		rts		tr20    rts
.c6a6	 a9 00		lda #$00	fndlmt  lda  #0         ; find string limit in cmdbuf
.c6a8	 8d 4b 02	sta $024b	        sta  strsiz     ; pointed to by x
.c6ab	 8a		txa		        txa
.c6ac	 48		pha		        pha
.c6ad	 bd 00 02	lda $0200,x	fl05    lda  cmdbuf,x
.c6b0	 c9 2c		cmp #$2c	        cmp  #','
.c6b2	 f0 14		beq $c6c8	        beq  fl10
.c6b4	 c9 3d		cmp #$3d	        cmp  #'='
.c6b6	 f0 10		beq $c6c8	        beq  fl10
.c6b8	 ee 4b 02	inc $024b	        inc  strsiz
.c6bb	 e8		inx		        inx
.c6bc	 a9 0f		lda #$0f	        lda  #15
.c6be	 cd 4b 02	cmp $024b	        cmp  strsiz
.c6c1	 90 05		bcc $c6c8	        bcc  fl10
.c6c3	 ec 74 02	cpx $0274	        cpx  cmdsiz
.c6c6	 90 e5		bcc $c6ad	        bcc  fl05
.c6c8	 8e 76 02	stx $0276	fl10    stx  limit
.c6cb	 68		pla		        pla
.c6cc	 aa		tax		        tax
.c6cd	 60		rts		        rts
.c6ce	 a5 83		lda $83		getnam  lda  sa         ; save variables
.c6d0	 48		pha		        pha
.c6d1	 a5 82		lda $82		        lda  lindx
.c6d3	 48		pha		        pha
.c6d4	 20 de c6	jsr $c6de	        jsr  gnsub
.c6d7	 68		pla		        pla     	; restore variables
.c6d8	 85 82		sta $82		        sta  lindx
.c6da	 68		pla		        pla
.c6db	 85 83		sta $83		        sta  sa
.c6dd	 60		rts		        rts
.c6de	 a9 11		lda #$11	gnsub   lda  #irsa
.c6e0	 85 83		sta $83		        sta  sa
.c6e2	 20 eb d0	jsr $d0eb	        jsr  fndrch
.c6e5	 20 e8 d4	jsr $d4e8	        jsr  getpnt
.c6e8	 ad 53 02	lda $0253	        lda  entfnd
.c6eb	 10 0a		bpl $c6f7	        bpl  gn05       ; more files
.c6ed	 ad 8d 02	lda $028d	        lda  drvflg
.c6f0	 d0 0a		bne $c6fc	        bne  gn050
.c6f2	 20 06 c8	jsr $c806	        jsr  msgfre     ; send blocks free
.c6f5	 18		clc		        clc     	; (c=0): end
.c6f6	 60		rts		        rts     	; terminate
.c6f7	 ad 8d 02	lda $028d	gn05    lda  drvflg     ; (drvflg=0):
.c6fa	 f0 1f		beq $c71b	        beq  gn10       ;  send file name
.c6fc	 ce 8d 02	dec $028d	gn050   dec  drvflg     ; (drvflg=-1):new dir
.c6ff	 d0 0d		bne $c70e	        bne  gn051
.c701	 ce 8d 02	dec $028d	        dec  drvflg
.c704	 20 8f c3	jsr $c38f	        jsr  togdrv
.c707	 20 06 c8	jsr $c806	        jsr  msgfre
.c70a	 38		sec		        sec
.c70b	 4c 8f c3	jmp $c38f	        jmp  togdrv     ; no drv 1
.c70e	 a9 00		lda #$00	gn051   lda  #0
.c710	 8d 73 02	sta $0273	        sta  nbtemp+1
.c713	 8d 8d 02	sta $028d	        sta  drvflg     ; reset flag
.c716	 20 b7 c7	jsr $c7b7	        jsr  newdir
.c719	 38		sec		        sec
.c71a	 60		rts		        rts
.c71b	 a2 18		ldx #$18	gn10    ldx  #dirlen    ; set number blocks
.c71d	 a0 1d		ldy #$1d	        ldy  #29        ;  & adjust spacing
.c71f	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c721	 8d 73 02	sta $0273	        sta  nbtemp+1
.c724	 f0 02		beq $c728	        beq  gn12
.c726	 a2 16		ldx #$16	        ldx  #dirlen-2
.c728	 88		dey		gn12    dey
.c729	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c72b	 8d 72 02	sta $0272	        sta  nbtemp
.c72e	 e0 16		cpx #$16	        cpx  #dirlen-2
.c730	 f0 0a		beq $c73c	        beq  gn14
.c732	 c9 0a		cmp #$0a	        cmp  #10
.c734	 90 06		bcc $c73c	        bcc  gn14
.c736	 ca		dex		        dex
.c737	 c9 64		cmp #$64	        cmp  #100
.c739	 90 01		bcc $c73c	        bcc  gn14
.c73b	 ca		dex		        dex
.c73c	 20 ac c7	jsr $c7ac	gn14    jsr  blknb      ; clear name buffer
.c73f	 b1 94		lda ($94),y	        lda  (dirbuf),y ; set type chars
.c741	 48		pha		        pha
.c742	 0a		asl a		        asl  a          ; (used in bcs)
.c743	 10 05		bpl $c74a	        bpl  gn15
.c745	 a9 3c		lda #$3c	        lda  #'<'
.c747	 9d b2 02	sta $02b2,x	        sta  nambuf+1,x
.c74a	 68		pla		gn15    pla
.c74b	 29 0f		and #$0f	        and  #$f
.c74d	 a8		tay		        tay
.c74e	 b9 c5 fe	lda $fec5,y	        lda  tp2lst,y
.c751	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c754	 ca		dex		        dex
.c755	 b9 c0 fe	lda $fec0,y	        lda  tp1lst,y
.c758	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c75b	 ca		dex		        dex
.c75c	 b9 bb fe	lda $febb,y	        lda  typlst,y
.c75f	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c762	 ca		dex		        dex
.c763	 ca		dex		        dex
.c764	 b0 05		bcs $c76b	        bcs  gn20       ; (from asl)
.c766	 a9 2a		lda #$2a	        lda  #'*'       ; file not closed
.c768	 9d b2 02	sta $02b2,x	        sta  nambuf+1,x
.c76b	 a9 a0		lda #$a0	gn20    lda  #$a0
.c76d	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c770	 ca		dex		        dex
.c771	 a0 12		ldy #$12	        ldy  #18
.c773	 b1 94		lda ($94),y	gn22    lda  (dirbuf),y
.c775	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c778	 ca		dex		        dex
.c779	 88		dey		        dey
.c77a	 c0 03		cpy #$03	        cpy  #3
.c77c	 b0 f5		bcs $c773	        bcs  gn22
.c77e	 a9 22		lda #$22	        lda  #'"'       ; send name in quotes
.c780	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c783	 e8		inx		gn30    inx
.c784	 e0 20		cpx #$20	        cpx  #$20
.c786	 b0 0b		bcs $c793	        bcs  gn35
.c788	 bd b1 02	lda $02b1,x	        lda  nambuf,x
.c78b	 c9 22		cmp #$22	        cmp  #'"'
.c78d	 f0 04		beq $c793	        beq  gn35
.c78f	 c9 a0		cmp #$a0	        cmp  #$a0
.c791	 d0 f0		bne $c783	        bne  gn30
.c793	 a9 22		lda #$22	gn35    lda  #'"'
.c795	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c798	 e8		inx		gn37    inx
.c799	 e0 20		cpx #$20	        cpx  #$20
.c79b	 b0 0a		bcs $c7a7	        bcs  gn40
.c79d	 a9 7f		lda #$7f	        lda  #$7f
.c79f	 3d b1 02	and $02b1,x	        and  nambuf,x
.c7a2	 9d b1 02	sta $02b1,x	        sta  nambuf,x
.c7a5	 10 f1		bpl $c798	        bpl  gn37
.c7a7	 20 b5 c4	jsr $c4b5	gn40    jsr  fndfil
.c7aa	 38		sec		        sec
.c7ab	 60		rts		        rts
.c7ac	 a0 1b		ldy #$1b	blknb   ldy  #nbsiz     ; blank nambuf
.c7ae	 a9 20		lda #$20	        lda  #$20
.c7b0	 99 b0 02	sta $02b0,y	blknb1  sta  nambuf-1,y
.c7b3	 88		dey		        dey
.c7b4	 d0 fa		bne $c7b0	        bne  blknb1
.c7b6	 60		rts		        rts
.c7b7	 20 19 f1	jsr $f119	newdir  jsr  bam2x      ; new dir in listing
.c7ba	 20 df f0	jsr $f0df	        jsr  redbam     ; rd in dir
.c7bd	 20 ac c7	jsr $c7ac	        jsr  blknb
.c7c0	 a9 ff		lda #$ff	        lda  #$ff
.c7c2	 85 6f		sta $6f		        sta  temp
.c7c4	 a6 7f		ldx $7f		        ldx  drvnum
.c7c6	 8e 72 02	stx $0272	        stx  nbtemp
.c7c9	 a9 00		lda #$00	        lda  #0
.c7cb	 8d 73 02	sta $0273	        sta  nbtemp+1
.c7ce	 a6 f9		ldx $f9		        ldx  jobnum
.c7d0	 bd e0 fe	lda $fee0,x	        lda  bufind,x
.c7d3	 85 95		sta $95		        sta  dirbuf+1
.c7d5	 ad 88 fe	lda $fe88	        lda  dsknam
.c7d8	 85 94		sta $94		        sta  dirbuf
.c7da	 a0 16		ldy #$16	        ldy  #22
.c7dc	 b1 94		lda ($94),y	        lda  (dirbuf),y
.c7de	 c9 a0		cmp #$a0	        cmp  #$a0
.c7e0	 d0 0b		bne $c7ed	        bne  nd20
.c7e2	 a9 31		lda #$31	        lda  #$31

>c7e4	 2c                       	        .byte skip2

.c7e5	 b1 94		lda ($94),y	nd15    lda  (dirbuf),y
.c7e7	 c9 a0		cmp #$a0	        cmp  #$a0
.c7e9	 d0 02		bne $c7ed	        bne  nd20
.c7eb	 a9 20		lda #$20	        lda  #$20
.c7ed	 99 b3 02	sta $02b3,y	nd20    sta  nambuf+2,y
.c7f0	 88		dey		        dey
.c7f1	 10 f2		bpl $c7e5	        bpl  nd15
.c7f3	 a9 12		lda #$12	        lda  #$12
.c7f5	 8d b1 02	sta $02b1	        sta  nambuf
.c7f8	 a9 22		lda #$22	        lda  #'"'
.c7fa	 8d b2 02	sta $02b2	        sta  nambuf+1
.c7fd	 8d c3 02	sta $02c3	        sta  nambuf+18
.c800	 a9 20		lda #$20	        lda  #$20
.c802	 8d c4 02	sta $02c4	        sta  nambuf+19
.c805	 60		rts		        rts
.c806	 20 ac c7	jsr $c7ac	msgfre  jsr  blknb
.c809	 a0 0b		ldy #$0b	        ldy  #msglen-1
.c80b	 b9 17 c8	lda $c817,y	msg1    lda  fremsg,y
.c80e	 99 b1 02	sta $02b1,y	        sta  nambuf,y
.c811	 88		dey		        dey
.c812	 10 f7		bpl $c80b	        bpl  msg1
.c814	 4c 4d ef	jmp $ef4d	        jmp  numfre

>c817	 42 4c 4f 43 4b 53 20 46 	fremsg   .text  'BLOCKS FREE.'
>c81f	 52 45 45 2e 
=000c					msglen   =*-fremsg

;******  Return to file "serlib.asm"

						.include "scrtch.asm"

;******  Processing file "scrtch.asm"


.c823	 20 98 c3	jsr $c398	scrtch  jsr  fs1set     ; set up for 1 stream
.c826	 20 20 c3	jsr $c320		jsr  alldrs
.c829	 20 ca c3	jsr $c3ca		jsr  optsch
.c82c	 a9 00		lda #$00		lda  #0
.c82e	 85 86		sta $86			sta  r0         ; used as file count
.c830	 20 9d c4	jsr $c49d		jsr  ffst
.c833	 30 3d		bmi $c872		bmi  sc30
.c835	 20 b7 dd	jsr $ddb7	sc15    jsr  tstchn     ; is it active ?
.c838	 90 33		bcc $c86d		bcc  sc25       ; yes - don't scratch
.c83a	 a0 00		ldy #$00		ldy  #0
.c83c	 b1 94		lda ($94),y		lda  (dirbuf),y
.c83e	 29 40		and #$40		and  #$40       ; lock bit
.c840	 d0 2b		bne $c86d		bne  sc25       ; it's locked
.c842	 20 b6 c8	jsr $c8b6		jsr  deldir     ; delete directory
.c845	 a0 13		ldy #$13	        ldy  #19        ; is this a relative ?
.c847	 b1 94		lda ($94),y		lda  (dirbuf),y ; has a ss ?
.c849	 f0 0a		beq $c855		beq  sc17       ; no
.c84b	 85 80		sta $80			sta  track      ; yes - save track
.c84d	 c8		iny			iny
.c84e	 b1 94		lda ($94),y		lda  (dirbuf),y ; get sector
.c850	 85 81		sta $81			sta  sector
.c852	 20 7d c8	jsr $c87d		jsr  delfil     ; delete by links
.c855	 ae 53 02	ldx $0253	sc17    ldx  entfnd
.c858	 a9 20		lda #$20		lda  #$20
.c85a	 35 e7		and $e7,x		and  pattyp,x
.c85c	 d0 0d		bne $c86b		bne  sc20       ; created, not closed
.c85e	 bd 80 02	lda $0280,x		lda  filtrk,x   ; delete by links
.c861	 85 80		sta $80			sta  track
.c863	 bd 85 02	lda $0285,x		lda  filsec,x
.c866	 85 81		sta $81			sta  sector
.c868	 20 7d c8	jsr $c87d		jsr  delfil
.c86b	 e6 86		inc $86		sc20    inc  r0
.c86d	 20 8b c4	jsr $c48b	sc25    jsr  ffre
.c870	 10 c3		bpl $c835		bpl  sc15
.c872	 a5 86		lda $86		sc30    lda  r0         ; finished, set
.c874	 85 80		sta $80			sta  track      ; file count
.c876	 a9 01		lda #$01		lda  #1
.c878	 a0 00		ldy #$00		ldy  #0
.c87a	 4c a3 c1	jmp $c1a3		jmp  scrend     ; end of scratch
.c87d	 20 5f ef	jsr $ef5f	delfil  jsr  frets      ; delete file by links
.c880	 20 75 d4	jsr $d475		jsr  opnird     ; update bam
.c883	 20 19 f1	jsr $f119		jsr  bam2x
.c886	 b5 a7		lda $a7,x		lda  buf0,x
.c888	 c9 ff		cmp #$ff		cmp  #$ff
.c88a	 f0 08		beq $c894		beq  del1
.c88c	 ad f9 02	lda $02f9		lda  wbam
.c88f	 09 40		ora #$40		ora  #$40
.c891	 8d f9 02	sta $02f9		sta  wbam
.c894	 a9 00		lda #$00	del1    lda  #0
.c896	 20 c8 d4	jsr $d4c8		jsr  setpnt
.c899	 20 56 d1	jsr $d156		jsr  rdbyt
.c89c	 85 80		sta $80			sta  track
.c89e	 20 56 d1	jsr $d156		jsr  rdbyt
.c8a1	 85 81		sta $81			sta  sector
.c8a3	 a5 80		lda $80			lda  track
.c8a5	 d0 06		bne $c8ad		bne  del2
.c8a7	 20 f4 ee	jsr $eef4		jsr  mapout
.c8aa	 4c 27 d2	jmp $d227		jmp  frechn
.c8ad	 20 5f ef	jsr $ef5f	del2    jsr  frets
.c8b0	 20 4d d4	jsr $d44d		jsr  nxtbuf
.c8b3	 4c 94 c8	jmp $c894		jmp  del1
.c8b6	 a0 00		ldy #$00	deldir  ldy  #0         ; delete dir entry
.c8b8	 98		tya			tya
.c8b9	 91 94		sta ($94),y		sta  (dirbuf),y
.c8bb	 20 5e de	jsr $de5e		jsr  wrtout
.c8be	 4c 99 d5	jmp $d599		jmp  watjob

;******  Return to file "serlib.asm"

						.include "duplct.asm"

;******  Processing file "duplct.asm"

.c8c1					duplct
.c8c1	 a9 31		lda #$31	        lda  #badcmd
.c8c3	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.c8c6					format
.c8c6	 a9 4c		lda #$4c	        lda  #$4c
.c8c8	 8d 00 06	sta $0600	        sta  bufs+$300
.c8cb	 a9 c7		lda #$c7	        lda  #<formt
.c8cd	 8d 01 06	sta $0601	        sta  bufs+$301
.c8d0	 a9 fa		lda #$fa	        lda  #>formt
.c8d2	 8d 02 06	sta $0602	        sta  bufs+$302
.c8d5	 a9 03		lda #$03	        lda  #3
.c8d7	 20 d3 d6	jsr $d6d3	        jsr  seth
.c8da	 a5 7f		lda $7f		        lda  drvnum
.c8dc	 09 e0		ora #$e0	        ora  #exec
.c8de	 85 03		sta $03		        sta  jobs+3
.c8e0	 a5 03		lda $03		fmt105  lda  jobs+3
.c8e2	 30 fc		bmi $c8e0	        bmi  fmt105
.c8e4	 c9 02		cmp #$02	        cmp  #2
.c8e6	 90 07		bcc $c8ef	        bcc  fmt110
.c8e8	 a9 03		lda #$03	        lda  #3
.c8ea	 a2 00		ldx #$00	        ldx  #0
.c8ec	 4c 0a e6	jmp $e60a	        jmp  error
.c8ef	 60		rts		fmt110  rts

;******  Return to file "serlib.asm"

						.include "copset.asm"

;******  Processing file "copset.asm"

.c8f0					dskcpy
.c8f0	 a9 e0		lda #$e0	        lda  #$e0       ; kill bam buffer
.c8f2	 8d 4f 02	sta $024f	        sta  bufuse
.c8f5	 20 d1 f0	jsr $f0d1	        jsr  clnbam     ; clr tbam
.c8f8	 20 19 f1	jsr $f119	        jsr  bam2x      ; get bam lindx in .x
.c8fb	 a9 ff		lda #$ff	        lda  #$ff
.c8fd	 95 a7		sta $a7,x	        sta  buf0,x     ; mark bam out-of-memory
.c8ff	 a9 0f		lda #$0f	        lda  #$0f
.c901	 8d 56 02	sta $0256	        sta  linuse     ; free all lindxs
.c904	 20 e5 c1	jsr $c1e5	        jsr  prscln     ; find ":"
.c907	 d0 03		bne $c90c	        bne  dx0000
.c909	 4c c1 c8	jmp $c8c1	        jmp  duplct     ; bad command error, cx=x not allowed
.c90c	 20 f8 c1	jsr $c1f8	dx0000  jsr  tc30       ; normal parse
.c90f	 20 20 c3	jsr $c320	dx0005  jsr  alldrs     ; put drv's in filtbl
.c912	 ad 8b 02	lda $028b	        lda  image      ; get parse image
.c915	 29 55		and #$55	        and  #%01010101 ; val for patt copy
.c917	 d0 0f		bne $c928	        bne  dx0020     ; must be concat or normal
.c919	 ae 7a 02	ldx $027a	        ldx  filtbl     ; chk for *
.c91c	 bd 00 02	lda $0200,x	        lda  cmdbuf,x
.c91f	 c9 2a		cmp #$2a	        cmp  #'*'
.c921	 d0 05		bne $c928	        bne  dx0020
.c923	 a9 30		lda #$30	dx0010  lda  #badsyn    ; syntax error
.c925	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.c928	 ad 8b 02	lda $028b	dx0020  lda  image      ; chk for normal
.c92b	 29 d9		and #$d9	        and  #%11011001
.c92d	 d0 f4		bne $c923	        bne  dx0010
.c92f	 4c 52 c9	jmp $c952	        jmp  copy

;******  Return to file "serlib.asm"

					        .include "copall.asm"

;******  Processing file "copall.asm"

.c932	 a9 00		lda #$00	pups1   lda  #0
.c934	 8d 58 02	sta $0258	        sta  rec
.c937	 8d 8c 02	sta $028c	        sta  drvcnt
.c93a	 8d 80 02	sta $0280	        sta  filtrk
.c93d	 8d 81 02	sta $0281	        sta  filtrk+1
.c940	 a5 e3		lda $e3		        lda  fildrv+1   ; get drive number
.c942	 29 01		and #$01	        and  #1         ; only
.c944	 85 7f		sta $7f		        sta  drvnum
.c946	 09 01		ora #$01	        ora  #1
.c948	 8d 91 02	sta $0291	        sta  delsec     ; nonzero
.c94b	 ad 7b 02	lda $027b	        lda  filtbl+1   ; fn1=fn2
.c94e	 8d 7a 02	sta $027a	        sta  filtbl
.c951	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "copy.asm"

;******  Processing file "copy.asm"

.c952	 20 4f c4	jsr $c44f	copy    jsr  lookup     ; look ip all files
.c955	 ad 78 02	lda $0278	        lda  f2cnt
.c958	 c9 03		cmp #$03	        cmp  #3
.c95a	 90 45		bcc $c9a1	        bcc  cop10
.c95c	 a5 e2		lda $e2		        lda  fildrv
.c95e	 c5 e3		cmp $e3		        cmp  fildrv+1
.c960	 d0 3f		bne $c9a1	        bne  cop10
.c962	 a5 dd		lda $dd		        lda  entind
.c964	 c5 de		cmp $de		        cmp  entind+1
.c966	 d0 39		bne $c9a1	        bne  cop10
.c968	 a5 d8		lda $d8		        lda  entsec
.c96a	 c5 d9		cmp $d9		        cmp  entsec+1
.c96c	 d0 33		bne $c9a1	        bne  cop10
.c96e	 20 cc ca	jsr $cacc	        jsr  chkin      ; concat
.c971	 a9 01		lda #$01	        lda  #1
.c973	 8d 79 02	sta $0279	        sta  f2ptr
.c976	 20 fa c9	jsr $c9fa	        jsr  opirfl
.c979	 20 25 d1	jsr $d125	        jsr  typfil
.c97c	 f0 04		beq $c982	        beq  cop01    	; greater than or equal to relative...
.c97e	 c9 02		cmp #$02	        cmp  #prgtyp
.c980	 d0 05		bne $c987	        bne  cop05
.c982	 a9 64		lda #$64	cop01   lda  #mistyp
.c984	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.c987	 a9 12		lda #$12	cop05   lda  #iwsa
.c989	 85 83		sta $83		        sta  sa
.c98b	 ad 3c 02	lda $023c	        lda  lintab+irsa
.c98e	 8d 3d 02	sta $023d	        sta  lintab+iwsa
.c991	 a9 ff		lda #$ff	        lda  #$ff
.c993	 8d 3c 02	sta $023c	        sta  lintab+irsa
.c996	 20 2a da	jsr $da2a	        jsr  append
.c999	 a2 02		ldx #$02	        ldx  #2
.c99b	 20 b9 c9	jsr $c9b9	        jsr  cy10
.c99e	 4c 94 c1	jmp $c194	        jmp  endcmd
.c9a1	 20 a7 c9	jsr $c9a7	cop10   jsr  cy
.c9a4	 4c 94 c1	jmp $c194	        jmp  endcmd
.c9a7	 20 e7 ca	jsr $cae7	cy      jsr  chkio      ; ck fil for existence
.c9aa	 a5 e2		lda $e2		        lda  fildrv
.c9ac	 29 01		and #$01	        and  #1
.c9ae	 85 7f		sta $7f		        sta  drvnum
.c9b0	 20 86 d4	jsr $d486	        jsr  opniwr     ; open internal write chnl
.c9b3	 20 e4 d6	jsr $d6e4	        jsr  addfil     ; add to directory
.c9b6	 ae 77 02	ldx $0277	        ldx  f1cnt
.c9b9	 8e 79 02	stx $0279	cy10    stx  f2ptr      ; set up read file
.c9bc	 20 fa c9	jsr $c9fa	        jsr  opirfl
.c9bf	 a9 11		lda #$11	        lda  #irsa      ; add for rel copy
.c9c1	 85 83		sta $83		        sta  sa
.c9c3	 20 eb d0	jsr $d0eb	        jsr  fndrch
.c9c6	 20 25 d1	jsr $d125	        jsr  typfil
.c9c9	 d0 03		bne $c9ce	        bne  cy10a      ; not rel
.c9cb	 20 53 ca	jsr $ca53	        jsr  cyext
.c9ce	 a9 08		lda #$08	cy10a   lda  #eoisnd
.c9d0	 85 f8		sta $f8		        sta  eoiflg
.c9d2	 4c d8 c9	jmp $c9d8	        jmp  cy20
.c9d5	 20 9b cf	jsr $cf9b	cy15    jsr  pibyte
.c9d8	 20 35 ca	jsr $ca35	cy20    jsr  gibyte
.c9db	 a9 80		lda #$80	        lda  #lrf
.c9dd	 20 a6 dd	jsr $dda6	        jsr  tstflg
.c9e0	 f0 f3		beq $c9d5	        beq  cy15
.c9e2	 20 25 d1	jsr $d125	        jsr  typfil
.c9e5	 f0 03		beq $c9ea	        beq  cy30
.c9e7	 20 9b cf	jsr $cf9b	        jsr  pibyte
.c9ea	 ae 79 02	ldx $0279	cy30    ldx  f2ptr
.c9ed	 e8		inx		        inx
.c9ee	 ec 78 02	cpx $0278	        cpx  f2cnt
.c9f1	 90 c6		bcc $c9b9	        bcc  cy10       ; more files to copy
.c9f3	 a9 12		lda #$12	        lda  #iwsa
.c9f5	 85 83		sta $83		        sta  sa
.c9f7	 4c 02 db	jmp $db02	        jmp  clschn     ; close copy chnl, file
.c9fa	 ae 79 02	ldx $0279	opirfl  ldx  f2ptr
.c9fd	 b5 e2		lda $e2,x	        lda  fildrv,x
.c9ff	 29 01		and #$01	        and  #1
.ca01	 85 7f		sta $7f		        sta  drvnum
.ca03	 ad 85 fe	lda $fe85	        lda  dirtrk
.ca06	 85 80		sta $80		        sta  track
.ca08	 b5 d8		lda $d8,x	        lda  entsec,x
.ca0a	 85 81		sta $81		        sta  sector
.ca0c	 20 75 d4	jsr $d475	        jsr  opnird
.ca0f	 ae 79 02	ldx $0279	        ldx  f2ptr
.ca12	 b5 dd		lda $dd,x	        lda  entind,x
.ca14	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.ca17	 ae 79 02	ldx $0279	        ldx  f2ptr
.ca1a	 b5 e7		lda $e7,x	        lda  pattyp,x
.ca1c	 29 07		and #$07	        and  #typmsk
.ca1e	 8d 4a 02	sta $024a	        sta  type
.ca21	 a9 00		lda #$00	        lda  #0
.ca23	 8d 58 02	sta $0258	        sta  rec
.ca26	 20 a0 d9	jsr $d9a0	        jsr  opread
.ca29	 a0 01		ldy #$01	        ldy  #1
.ca2b	 20 25 d1	jsr $d125	        jsr  typfil
.ca2e	 f0 01		beq $ca31	        beq  opir10
.ca30	 c8		iny		        iny
.ca31	 98		tya		opir10  tya
.ca32	 4c c8 d4	jmp $d4c8	        jmp  setpnt
.ca35	 a9 11		lda #$11	gibyte  lda  #irsa
.ca37	 85 83		sta $83		        sta  sa
.ca39	 20 9b d3	jsr $d39b	gcbyte  jsr  gbyte
.ca3c	 85 85		sta $85		        sta  data
.ca3e	 a6 82		ldx $82		        ldx  lindx
.ca40	 b5 f2		lda $f2,x	        lda  chnrdy,x
.ca42	 29 08		and #$08	        and  #eoisnd
.ca44	 85 f8		sta $f8		        sta  eoiflg
.ca46	 d0 0a		bne $ca52	        bne  gib20
.ca48	 20 25 d1	jsr $d125	        jsr  typfil
.ca4b	 f0 05		beq $ca52	        beq  gib20
.ca4d	 a9 80		lda #$80	        lda  #lrf
.ca4f	 20 97 dd	jsr $dd97	        jsr  setflg
.ca52	 60		rts		gib20   rts
.ca53	 20 d3 d1	jsr $d1d3	cyext   jsr  setdrn
.ca56	 20 cb e1	jsr $e1cb		jsr  ssend      ; copy rel rec's
.ca59	 a5 d6		lda $d6		        lda  ssind
.ca5b	 48		pha		        pha
.ca5c	 a5 d5		lda $d5		        lda  ssnum
.ca5e	 48		pha		        pha
.ca5f	 a9 12		lda #$12	        lda  #iwsa
.ca61	 85 83		sta $83		        sta  sa
.ca63	 20 07 d1	jsr $d107	        jsr  fndwch
.ca66	 20 d3 d1	jsr $d1d3	        jsr  setdrn
.ca69	 20 cb e1	jsr $e1cb	        jsr  ssend
.ca6c	 20 9c e2	jsr $e29c	        jsr  posbuf
.ca6f	 a5 d6		lda $d6		        lda  ssind
.ca71	 85 87		sta $87		        sta  r1
.ca73	 a5 d5		lda $d5		        lda  ssnum
.ca75	 85 86		sta $86		        sta  r0
.ca77	 a9 00		lda #$00	        lda  #0
.ca79	 85 88		sta $88		        sta  r2
.ca7b	 85 d4		sta $d4		        sta  recptr
.ca7d	 85 d7		sta $d7			sta  relptr
.ca7f	 68		pla			pla
.ca80	 85 d5		sta $d5		        sta  ssnum
.ca82	 68		pla			pla
.ca83	 85 d6		sta $d6			sta  ssind
.ca85	 4c 3b e3	jmp $e33b		jmp  addr1

;******  Return to file "serlib.asm"

					        .include "rename.asm"

;******  Processing file "rename.asm"

.ca88	 20 20 c3	jsr $c320	rename  jsr  alldrs     ; set both drive #'s
.ca8b	 a5 e3		lda $e3		        lda  fildrv+1
.ca8d	 29 01		and #$01	        and  #1
.ca8f	 85 e3		sta $e3		        sta  fildrv+1
.ca91	 c5 e2		cmp $e2		        cmp  fildrv
.ca93	 f0 02		beq $ca97	        beq  rn10       ; same drive #'s
.ca95	 09 80		ora #$80	        ora  #$80       ; check both drives for name
.ca97	 85 e2		sta $e2		rn10    sta  fildrv
.ca99	 20 4f c4	jsr $c44f	        jsr  lookup     ; look up both names
.ca9c	 20 e7 ca	jsr $cae7	        jsr  chkio      ; check for existence
.ca9f	 a5 e3		lda $e3		        lda  fildrv+1
.caa1	 29 01		and #$01	        and  #1
.caa3	 85 7f		sta $7f		        sta  drvnum
.caa5	 a5 d9		lda $d9		        lda  entsec+1
.caa7	 85 81		sta $81		        sta  sector
.caa9	 20 57 de	jsr $de57	        jsr  rdab       ; read directory sector
.caac	 20 99 d5	jsr $d599	        jsr  watjob
.caaf	 a5 de		lda $de		        lda  entind+1
.cab1	 18		clc		        clc     	; set sector index
.cab2	 69 03		adc #$03	        adc  #3         ; ...+3
.cab4	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.cab7	 20 93 df	jsr $df93	        jsr  getact
.caba	 a8		tay		        tay
.cabb	 ae 7a 02	ldx $027a	        ldx  filtbl
.cabe	 a9 10		lda #$10	        lda  #16
.cac0	 20 6e c6	jsr $c66e	        jsr  trname     ; transfer name
.cac3	 20 5e de	jsr $de5e	        jsr  wrtout     ; write sector out
.cac6	 20 99 d5	jsr $d599	        jsr  watjob
.cac9	 4c 94 c1	jmp $c194	        jmp  endcmd
.cacc	 a5 e8		lda $e8		chkin   lda  pattyp+1   ; 1st file bears type
.cace	 29 07		and #$07	        and  #typmsk
.cad0	 8d 4a 02	sta $024a	        sta  type
.cad3	 ae 78 02	ldx $0278	        ldx  f2cnt
.cad6	 ca		dex		ck10    dex
.cad7	 ec 77 02	cpx $0277	        cpx  f1cnt
.cada	 90 0a		bcc $cae6	        bcc  ck20
.cadc	 bd 80 02	lda $0280,x	        lda  filtrk,x
.cadf	 d0 f5		bne $cad6	        bne  ck10
.cae1	 a9 62		lda #$62	        lda  #flntfd    ; input file not found
.cae3	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.cae6	 60		rts		ck20    rts
.cae7	 20 cc ca	jsr $cacc	chkio   jsr  chkin
.caea	 bd 80 02	lda $0280,x	ck25    lda  filtrk,x
.caed	 f0 05		beq $caf4	        beq  ck30
.caef	 a9 63		lda #$63	        lda  #flexst
.caf1	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.caf4	 ca		dex		ck30    dex
.caf5	 10 f3		bpl $caea	        bpl  ck25
.caf7	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "memrw.asm"

;******  Processing file "memrw.asm"

.caf8	 ad 01 02	lda $0201	mem     lda  cmdbuf+1
.cafb	 c9 2d		cmp #$2d	        cmp  #'-'
.cafd	 d0 4c		bne $cb4b	        bne  memerr
.caff	 ad 03 02	lda $0203	        lda  cmdbuf+3   ; set address in temp
.cb02	 85 6f		sta $6f		        sta  temp
.cb04	 ad 04 02	lda $0204	        lda  cmdbuf+4
.cb07	 85 70		sta $70		        sta  temp+1
.cb09	 a0 00		ldy #$00	        ldy  #0
.cb0b	 ad 02 02	lda $0202	        lda  cmdbuf+2
.cb0e	 c9 52		cmp #$52	        cmp  #'R'
.cb10	 f0 0e		beq $cb20	        beq  memrd      ; read
.cb12	 20 58 f2	jsr $f258	        jsr  killp      ; kill protect
.cb15	 c9 57		cmp #$57	        cmp  #'W'
.cb17	 f0 37		beq $cb50	        beq  memwrt     ; write
.cb19	 c9 45		cmp #$45	        cmp  #'E'
.cb1b	 d0 2e		bne $cb4b	        bne  memerr     ; error
.cb1d	 6c 6f 00	jmp ($006f)	memex   jmp  (temp)
.cb20					memrd
.cb20	 b1 6f		lda ($6f),y	        lda  (temp),y
.cb22	 85 85		sta $85		        sta  data
.cb24	 ad 74 02	lda $0274	        lda  cmdsiz
.cb27	 c9 06		cmp #$06	        cmp  #6
.cb29	 90 1a		bcc $cb45	        bcc  m30
.cb2b	 ae 05 02	ldx $0205	        ldx  cmdbuf+5
.cb2e	 ca		dex		        dex
.cb2f	 f0 14		beq $cb45	        beq  m30
.cb31	 8a		txa		        txa
.cb32	 18		clc		        clc
.cb33	 65 6f		adc $6f		        adc  temp
.cb35	 e6 6f		inc $6f		        inc  temp
.cb37	 8d 49 02	sta $0249	        sta  lstchr+errchn
.cb3a	 a5 6f		lda $6f		        lda  temp
.cb3c	 85 a5		sta $a5		        sta  cb+2
.cb3e	 a5 70		lda $70		        lda  temp+1
.cb40	 85 a6		sta $a6		        sta  cb+3
.cb42	 4c 43 d4	jmp $d443	        jmp  ge20
.cb45					m30
.cb45	 20 eb d0	jsr $d0eb	        jsr  fndrch
.cb48	 4c 3a d4	jmp $d43a	        jmp  ge15
.cb4b	 a9 31		lda #$31	memerr  lda  #badcmd    ; bad command
.cb4d	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.cb50					memwrt
.cb50	 b9 06 02	lda $0206,y	m10     lda  cmdbuf+6,y
.cb53	 91 6f		sta ($6f),y	        sta  (temp),y   ; transfer from cmdbuf
.cb55	 c8		iny		        iny
.cb56	 cc 05 02	cpy $0205	        cpy  cmdbuf+5   ; # of bytes to write
.cb59	 90 f5		bcc $cb50	        bcc  m10
.cb5b	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "block.asm"

;******  Processing file "block.asm"

.cb5c	 ac 01 02	ldy $0201	user    ldy  cmdbuf+1
.cb5f	 c0 30		cpy #$30	        cpy  #'0'
.cb61	 d0 09		bne $cb6c	        bne  us10       ; 0 resets pntr
.cb63	 4c 30 80	jmp $8030	usrint  jmp  burst_routines
.cb66	 ea		nop			nop		; fill
.cb67	 ea		nop			nop		; fill
.cb68	 ea		nop			nop		; fill
.cb69	 ea		nop			nop		; fill
.cb6a	 ea		nop			nop		; fill
.cb6b	 ea		nop			nop		; fill
.cb6c	 20 72 cb	jsr $cb72	us10    jsr  usrexc     ; execute code by table
.cb6f	 4c 94 c1	jmp $c194	        jmp  endcmd
.cb72	 88		dey		usrexc  dey     	; entry is(((index-1)and$f)*2)
.cb73	 98		tya		        tya
.cb74	 29 0f		and #$0f	        and  #$f
.cb76	 0a		asl a		        asl  a
.cb77	 a8		tay		        tay
.cb78	 b1 6b		lda ($6b),y		lda  (usrjmp),y
.cb7a	 85 75		sta $75		        sta  ip
.cb7c	 c8		iny		        iny
.cb7d	 b1 6b		lda ($6b),y	        lda  (usrjmp),y
.cb7f	 85 76		sta $76		        sta  ip+1
.cb81	 4c 2d aa	jmp $aa2d		jmp  ptch53	; *** rom ds 05/21/85 ***
.cb84	 ad 8e 02	lda $028e	opnblk  lda  lstdrv
.cb87	 85 7f		sta $7f		        sta  drvnum
.cb89	 a5 83		lda $83		        lda  sa         ; sa is destroyed by this patch
.cb8b	 48		pha		        pha
.cb8c	 20 3d c6	jsr $c63d	        jsr  autoi      ; init disk for proper channel assignment
.cb8f	 68		pla		        pla     	; restore sa
.cb90	 85 83		sta $83		        sta  sa
.cb92	 ae 74 02	ldx $0274	        ldx  cmdsiz
.cb95	 ca		dex		        dex
.cb96	 d0 0d		bne $cba5	        bne  ob10
.cb98	 a9 01		lda #$01	        lda  #1         ; get any buffer
.cb9a	 20 e2 d1	jsr $d1e2	        jsr  getrch
.cb9d	 4c f1 cb	jmp $cbf1	        jmp  ob30
.cba0	 a9 70		lda #$70	ob05    lda  #nochnl
.cba2	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.cba5	 a0 01		ldy #$01	ob10    ldy  #1         ; buffer # is requested
.cba7	 20 7c cc	jsr $cc7c	        jsr  bp05
.cbaa	 ae 85 02	ldx $0285	        ldx  filsec
.cbad	 e0 05		cpx #$05	        cpx  #bfcnt     ; must be less than 6.
.cbaf	 b0 ef		bcs $cba0	        bcs  ob05
.cbb1	 a9 00		lda #$00	        lda  #0
.cbb3	 85 6f		sta $6f		        sta  temp
.cbb5	 85 70		sta $70		        sta  temp+1
.cbb7	 38		sec		        sec
.cbb8					ob15
.cbb8	 26 6f		rol $6f		        rol  temp
.cbba	 26 70		rol $70		        rol  temp+1
.cbbc	 ca		dex		        dex
.cbbd	 10 f9		bpl $cbb8	        bpl  ob15
.cbbf	 a5 6f		lda $6f		        lda  temp
.cbc1	 2d 4f 02	and $024f	        and  bufuse
.cbc4	 d0 da		bne $cba0	        bne  ob05       ; buffer is used
.cbc6	 a5 70		lda $70		        lda  temp+1
.cbc8	 2d 50 02	and $0250	        and  bufuse+1
.cbcb	 d0 d3		bne $cba0	        bne  ob05       ; buf is used
.cbcd	 a5 6f		lda $6f		        lda  temp
.cbcf	 0d 4f 02	ora $024f	        ora  bufuse     ; set buffer as used
.cbd2	 8d 4f 02	sta $024f	        sta  bufuse
.cbd5	 a5 70		lda $70		        lda  temp+1
.cbd7	 0d 50 02	ora $0250	        ora  bufuse+1
.cbda	 8d 50 02	sta $0250	        sta  bufuse+1
.cbdd	 a9 00		lda #$00	        lda  #0         ; set up channel
.cbdf	 20 e2 d1	jsr $d1e2	        jsr  getrch
.cbe2	 a6 82		ldx $82		        ldx  lindx
.cbe4	 ad 85 02	lda $0285	        lda  filsec
.cbe7	 95 a7		sta $a7,x	        sta  buf0,x
.cbe9	 aa		tax		        tax
.cbea	 a5 7f		lda $7f		        lda  drvnum
.cbec	 95 00		sta $00,x	        sta  jobs,x
.cbee	 9d 5b 02	sta $025b,x	        sta  lstjob,x
.cbf1	 a6 83		ldx $83		ob30    ldx  sa
.cbf3	 bd 2b 02	lda $022b,x	        lda  lintab,x   ; set lindx table
.cbf6	 09 40		ora #$40	        ora  #$40
.cbf8	 9d 2b 02	sta $022b,x	        sta  lintab,x
.cbfb	 a4 82		ldy $82		        ldy  lindx
.cbfd	 a9 ff		lda #$ff	        lda  #$ff
.cbff	 99 44 02	sta $0244,y	        sta  lstchr,y
.cc02	 a9 89		lda #$89	        lda  #rndrdy
.cc04	 99 f2 00	sta $00f2,y	        sta  chnrdy,y   ; set channel ready
.cc07	 b9 a7 00	lda $00a7,y	        lda  buf0,y
.cc0a	 99 3e 02	sta $023e,y	        sta  chndat,y   ; buffer # as 1st char
.cc0d	 0a		asl a		        asl  a
.cc0e	 aa		tax		        tax
.cc0f	 a9 01		lda #$01	        lda  #1
.cc11	 95 99		sta $99,x	        sta  buftab,x
.cc13	 a9 0e		lda #$0e	        lda  #dirtyp+dirtyp
.cc15	 99 ec 00	sta $00ec,y	        sta  filtyp,y   ; set direct file type
.cc18	 4c 94 c1	jmp $c194	        jmp  endcmd
.cc1b	 a0 00		ldy #$00	block   ldy  #0
.cc1d	 a2 00		ldx #$00	        ldx  #0
.cc1f	 a9 2d		lda #$2d	        lda  #'-'       ; "-" separates cmd from subcmd
.cc21	 20 68 c2	jsr $c268	        jsr  parse      ; locate sub-cmd
.cc24	 d0 0a		bne $cc30	        bne  blk40
.cc26	 a9 31		lda #$31	blk10   lda  #badcmd
.cc28	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.cc2b	 a9 30		lda #$30	blk30   lda  #badsyn
.cc2d	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.cc30	 8a		txa		blk40   txa
.cc31	 d0 f8		bne $cc2b	        bne  blk30
.cc33	 a2 05		ldx #$05	        ldx  #nbcmds-1	; find command
.cc35	 b9 00 02	lda $0200,y	        lda  cmdbuf,y
.cc38	 dd 5d cc	cmp $cc5d,x	blk50   cmp  bctab,x
.cc3b	 f0 05		beq $cc42	        beq  blk60
.cc3d	 ca		dex		        dex
.cc3e	 10 f8		bpl $cc38	        bpl  blk50
.cc40	 30 e4		bmi $cc26	        bmi  blk10
.cc42					blk60
.cc42	 8a		txa		        txa
.cc43	 09 80		ora #$80	        ora  #$80
.cc45	 8d 2a 02	sta $022a	        sta  cmdnum
.cc48	 20 6f cc	jsr $cc6f	        jsr  blkpar     ; parse parms
.cc4b	 ad 2a 02	lda $022a	        lda  cmdnum
.cc4e	 0a		asl a		        asl  a
.cc4f	 aa		tax		        tax
.cc50	 bd 64 cc	lda $cc64,x	        lda  bcjmp+1,x
.cc53	 85 70		sta $70		        sta  temp+1
.cc55	 bd 63 cc	lda $cc63,x	        lda  bcjmp,x
.cc58	 85 6f		sta $6f		        sta  temp
.cc5a	 6c 6f 00	jmp ($006f)	        jmp  (temp)     ; goto command

>cc5d	 41 46 52 57 45 50        	bctab    .text  'AFRWEP'
=0006					nbcmds   =*-bctab
>cc63	 03 cd                    	bcjmp    .word blkalc   ; block-allocate
>cc65	 f5 cc                    		 .word blkfre	; block-free
>cc67	 56 cd                    		 .word blkrd    ; block-read
>cc69	 73 cd                    		 .word blkwt    ; block-write
>cc6b	 a3 cd                    		 .word blkexc   ; block-execute
>cc6d	 bd cd                    		 .word blkptr   ; block-pointer

.cc6f	 a0 00		ldy #$00	blkpar  ldy  #0         ; parse block parms
.cc71	 a2 00		ldx #$00	        ldx  #0
.cc73	 a9 3a		lda #$3a	        lda  #':'
.cc75	 20 68 c2	jsr $c268	        jsr  parse
.cc78	 d0 02		bne $cc7c	        bne  bp05       ; found ":"
.cc7a	 a0 03		ldy #$03	        ldy  #3         ; else char #3 is beginning
.cc7c	 b9 00 02	lda $0200,y	bp05    lda  cmdbuf,y
.cc7f	 c9 20		cmp #$20	        cmp  #' '
.cc81	 f0 08		beq $cc8b	        beq  bp10
.cc83	 c9 1d		cmp #$1d	        cmp  #29        ; skip character
.cc85	 f0 04		beq $cc8b	        beq  bp10
.cc87	 c9 2c		cmp #$2c	        cmp  #','
.cc89	 d0 07		bne $cc92	        bne  bp20
.cc8b	 c8		iny		bp10    iny
.cc8c	 cc 74 02	cpy $0274	        cpy  cmdsiz
.cc8f	 90 eb		bcc $cc7c	        bcc  bp05
.cc91	 60		rts		        rts     	; that's all
.cc92	 20 a1 cc	jsr $cca1	bp20    jsr  aschex
.cc95	 ee 77 02	inc $0277	        inc  f1cnt
.cc98	 ac 79 02	ldy $0279	        ldy  f2ptr
.cc9b	 e0 04		cpx #$04	        cpx  #mxfils-1
.cc9d	 90 ec		bcc $cc8b	        bcc  bp10
.cc9f	 b0 8a		bcs $cc2b	        bcs  blk30      ; bad syntax
.cca1	 a9 00		lda #$00	aschex  lda  #0
.cca3	 85 6f		sta $6f		        sta  temp
.cca5	 85 70		sta $70		        sta  temp+1
.cca7	 85 72		sta $72		        sta  temp+3
.cca9	 a2 ff		ldx #$ff	        ldx  #$ff
.ccab	 b9 00 02	lda $0200,y	ah10    lda  cmdbuf,y   ; test for dec #
.ccae	 c9 40		cmp #$40	        cmp  #$40
.ccb0	 b0 18		bcs $ccca	        bcs  ah20       ; non-numeric terminates
.ccb2	 c9 30		cmp #$30	        cmp  #$30
.ccb4	 90 14		bcc $ccca	        bcc  ah20       ; non-numeric
.ccb6	 29 0f		and #$0f	        and  #$f
.ccb8	 48		pha		        pha
.ccb9	 a5 70		lda $70		        lda  temp+1     ; shift digits (*10)
.ccbb	 85 71		sta $71		        sta  temp+2
.ccbd	 a5 6f		lda $6f		        lda  temp
.ccbf	 85 70		sta $70		        sta  temp+1
.ccc1	 68		pla		        pla
.ccc2	 85 6f		sta $6f		        sta  temp
.ccc4	 c8		iny		        iny
.ccc5	 cc 74 02	cpy $0274	        cpy  cmdsiz
.ccc8	 90 e1		bcc $ccab	        bcc  ah10       ; still in string
.ccca	 8c 79 02	sty $0279	ah20    sty  f2ptr      ; convert digits to...
.cccd	 18		clc		        clc     	; ...binary by dec table
.ccce	 a9 00		lda #$00	        lda  #0
.ccd0	 e8		inx		ah30    inx
.ccd1	 e0 03		cpx #$03	        cpx  #3
.ccd3	 b0 0f		bcs $cce4	        bcs  ah40
.ccd5	 b4 6f		ldy $6f,x	        ldy  temp,x
.ccd7	 88		dey		ah35    dey
.ccd8	 30 f6		bmi $ccd0	        bmi  ah30
.ccda	 7d f2 cc	adc $ccf2,x	        adc  dectab,x
.ccdd	 90 f8		bcc $ccd7	        bcc  ah35
.ccdf	 18		clc		        clc
.cce0	 e6 72		inc $72		        inc  temp+3
.cce2	 d0 f3		bne $ccd7	        bne  ah35
.cce4	 48		pha		ah40    pha
.cce5	 ae 77 02	ldx $0277	        ldx  f1cnt
.cce8	 a5 72		lda $72		        lda  temp+3
.ccea	 9d 80 02	sta $0280,x	        sta  filtrk,x   ; store result in table
.cced	 68		pla		        pla
.ccee	 9d 85 02	sta $0285,x	        sta  filsec,x
.ccf1	 60		rts		        rts

>ccf2	 01 0a 64                 	dectab   .byte 1,10,100 ; decimal table

.ccf5	 20 f5 cd	jsr $cdf5	blkfre  jsr  blktst
.ccf8	 20 5f ef	jsr $ef5f	        jsr  frets
.ccfb	 4c 94 c1	jmp $c194	        jmp  endcmd
.ccfe	 a9 01		lda #$01	        lda  #1
.cd00	 8d f9 02	sta $02f9	        sta  wbam
.cd03					blkalc
.cd03	 20 f5 cd	jsr $cdf5	        jsr  blktst
.cd06					ba10
.cd06	 a5 81		lda $81		        lda  sector
.cd08	 48		pha		        pha
.cd09	 20 fa f1	jsr $f1fa	        jsr  getsec
.cd0c	 f0 0b		beq $cd19	        beq  ba15       ; none greater on this track
.cd0e	 68		pla		        pla
.cd0f	 c5 81		cmp $81		        cmp  sector
.cd11	 d0 19		bne $cd2c	        bne  ba30       ; requested sector not avail
.cd13	 20 90 ef	jsr $ef90	        jsr  wused
.cd16	 4c 94 c1	jmp $c194	        jmp  endcmd
.cd19					ba15
.cd19	 68		pla		        pla     	; pop stack
.cd1a					ba20
.cd1a	 a9 00		lda #$00	        lda  #0
.cd1c	 85 81		sta $81		        sta  sector
.cd1e	 e6 80		inc $80		        inc  track
.cd20	 a5 80		lda $80		        lda  track
.cd22	 cd ac 02	cmp $02ac	        cmp  maxtrk
.cd25	 b0 0a		bcs $cd31	        bcs  ba40       ; gone all the way
.cd27	 20 fa f1	jsr $f1fa	        jsr  getsec
.cd2a	 f0 ee		beq $cd1a	        beq  ba20
.cd2c					ba30
.cd2c	 a9 65		lda #$65	        lda  #noblk
.cd2e	 20 45 e6	jsr $e645	        jsr  cmder2
.cd31					ba40
.cd31	 a9 65		lda #$65	        lda  #noblk
.cd33	 20 c8 c1	jsr $c1c8	        jsr  cmderr     ; t=0,s=0 :none left
.cd36	 20 f2 cd	jsr $cdf2	blkrd2  jsr  bkotst     ; test parms
.cd39	 4c 60 d4	jmp $d460	        jmp  drtrd
.cd3c	 20 2f d1	jsr $d12f	getsim  jsr  getpre     ; get byte w/o inc
.cd3f	 a1 99		lda ($99,x)	        lda  (buftab,x)
.cd41	 60		rts		        rts
.cd42	 20 36 cd	jsr $cd36	blkrd3  jsr  blkrd2
.cd45	 a9 00		lda #$00	        lda  #0
.cd47	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.cd4a	 20 3c cd	jsr $cd3c	        jsr  getsim     ; y=lindx
.cd4d	 99 44 02	sta $0244,y	        sta  lstchr,y
.cd50	 a9 89		lda #$89	        lda  #rndrdy
.cd52	 99 f2 00	sta $00f2,y	        sta  chnrdy,y
.cd55	 60		rts		        rts
.cd56					blkrd
.cd56	 20 42 cd	jsr $cd42	        jsr  blkrd3
.cd59	 20 ec d3	jsr $d3ec	        jsr  rnget1
.cd5c	 4c 94 c1	jmp $c194	        jmp  endcmd
.cd5f					ublkrd
.cd5f	 20 6f cc	jsr $cc6f	        jsr  blkpar
.cd62	 20 42 cd	jsr $cd42	        jsr  blkrd3
.cd65	 b9 44 02	lda $0244,y	        lda  lstchr,y
.cd68	 99 3e 02	sta $023e,y	        sta  chndat,y
.cd6b	 a9 ff		lda #$ff	        lda  #$ff
.cd6d	 99 44 02	sta $0244,y	        sta  lstchr,y
.cd70	 4c 94 c1	jmp $c194	        jmp  endcmd     ; (rts)
.cd73	 20 f2 cd	jsr $cdf2	blkwt   jsr  bkotst
.cd76	 20 e8 d4	jsr $d4e8	        jsr  getpnt
.cd79	 a8		tay		        tay
.cd7a	 88		dey		        dey
.cd7b	 c9 02		cmp #$02	        cmp  #2
.cd7d	 b0 02		bcs $cd81	        bcs  bw10
.cd7f	 a0 01		ldy #$01	        ldy  #1
.cd81	 a9 00		lda #$00	bw10    lda  #0         ; set record size
.cd83	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.cd86	 98		tya		        tya
.cd87	 20 f1 cf	jsr $cff1	        jsr  putbyt
.cd8a	 8a		txa		        txa
.cd8b	 48		pha		        pha
.cd8c	 20 64 d4	jsr $d464	bw20    jsr  drtwrt     ; write block
.cd8f	 68		pla		        pla
.cd90	 aa		tax		        tax
.cd91	 20 ae ff	jsr $ffae		jsr  ptch15	; fix for block read *rom ds 01/22/85*
.cd94	 4c 94 c1	jmp $c194	        jmp  endcmd
.cd97	 20 6f cc	jsr $cc6f	ublkwt  jsr  blkpar
.cd9a	 20 f2 cd	jsr $cdf2	        jsr  bkotst
.cd9d	 20 64 d4	jsr $d464	        jsr  drtwrt
.cda0	 4c 94 c1	jmp $c194	        jmp  endcmd
.cda3					blkexc
.cda3	 20 58 f2	jsr $f258	        jsr  killp      ; kill protect
.cda6	 20 36 cd	jsr $cd36	        jsr  blkrd2     ; read block & execute
.cda9	 a9 00		lda #$00	        lda  #0
.cdab	 85 6f		sta $6f		be05    sta  temp
.cdad	 a6 f9		ldx $f9		        ldx  jobnum
.cdaf	 bd e0 fe	lda $fee0,x	        lda  bufind,x
.cdb2	 85 70		sta $70		        sta  temp+1
.cdb4	 20 ba cd	jsr $cdba	        jsr  be10       ; indirect jsr
.cdb7	 4c 94 c1	jmp $c194	        jmp  endcmd
.cdba	 6c 6f 00	jmp ($006f)	be10    jmp  (temp)
.cdbd	 20 d2 cd	jsr $cdd2	blkptr  jsr  buftst
.cdc0	 a5 f9		lda $f9		        lda  jobnum
.cdc2	 0a		asl a		        asl  a
.cdc3	 aa		tax		        tax
.cdc4	 ad 86 02	lda $0286	        lda  filsec+1
.cdc7	 95 99		sta $99,x	        sta  buftab,x
.cdc9	 20 2f d1	jsr $d12f	        jsr  getpre
.cdcc	 20 ee d3	jsr $d3ee	        jsr  rnget2     ; set up get
.cdcf	 4c 94 c1	jmp $c194	        jmp  endcmd
.cdd2	 a6 d3		ldx $d3		buftst  ldx  f1ptr
.cdd4	 e6 d3		inc $d3		        inc  f1ptr
.cdd6	 bd 85 02	lda $0285,x	        lda  filsec,x
.cdd9	 a8		tay		        tay
.cdda	 88		dey		        dey
.cddb	 88		dey		        dey
.cddc	 c0 0c		cpy #$0c	        cpy  #$c        ;  set limit to # of sas
.cdde	 90 05		bcc $cde5	        bcc  bt20
.cde0	 a9 70		lda #$70	bt15    lda  #nochnl
.cde2	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.cde5	 85 83		sta $83		bt20    sta  sa
.cde7	 20 eb d0	jsr $d0eb	        jsr  fndrch
.cdea	 b0 f4		bcs $cde0	        bcs  bt15
.cdec	 20 93 df	jsr $df93	        jsr  getact
.cdef	 85 f9		sta $f9		        sta  jobnum
.cdf1	 60		rts		        rts
.cdf2	 20 d2 cd	jsr $cdd2	bkotst  jsr  buftst
.cdf5	 a6 d3		ldx $d3		blktst  ldx  f1ptr
.cdf7	 bd 85 02	lda $0285,x	        lda  filsec,x
.cdfa	 29 01		and #$01	        and  #1
.cdfc	 85 7f		sta $7f		        sta  drvnum
.cdfe	 bd 87 02	lda $0287,x	        lda  filsec+2,x
.ce01	 85 81		sta $81		        sta  sector
.ce03	 bd 86 02	lda $0286,x	        lda  filsec+1,x
.ce06	 85 80		sta $80		        sta  track
.ce08					bt05
.ce08	 20 5f d5	jsr $d55f	        jsr  tschk
.ce0b	 4c 00 c1	jmp $c100	        jmp  setlds     ; (rts)

;******  Return to file "serlib.asm"

						.include "fndrel.asm"

;******  Processing file "fndrel.asm"

.ce0e	 20 2c ce	jsr $ce2c	fndrel  jsr  mulply     ; result=rn*rs+rp
.ce11	 20 6e ce	jsr $ce6e	        jsr  div254     ; divide by 254
.ce14	 a5 90		lda $90		        lda  accum+1    ; save remainder
.ce16	 85 d7		sta $d7		        sta  relptr
.ce18	 20 71 ce	jsr $ce71	        jsr  div120     ; divide by 120
.ce1b	 e6 d7		inc $d7		        inc  relptr
.ce1d	 e6 d7		inc $d7		        inc  relptr
.ce1f	 a5 8b		lda $8b		        lda  result     ; save quotient
.ce21	 85 d5		sta $d5		        sta  ssnum
.ce23	 a5 90		lda $90		        lda  accum+1    ; save remainder
.ce25	 0a		asl a		        asl  a          ; calc index into ss
.ce26	 18		clc		        clc
.ce27	 69 10		adc #$10	        adc  #16        ; skip link table
.ce29	 85 d6		sta $d6		        sta  ssind
.ce2b	 60		rts		        rts
.ce2c	 20 d9 ce	jsr $ced9	mulply  jsr  zerres     ; result=0
.ce2f	 85 92		sta $92		        sta  accum+3    ; a=0
.ce31	 a6 82		ldx $82		        ldx  lindx      ; get index
.ce33	 b5 b5		lda $b5,x	        lda  recl,x
.ce35	 85 90		sta $90		        sta  accum+1
.ce37	 b5 bb		lda $bb,x	        lda  rech,x
.ce39	 85 91		sta $91		        sta  accum+2
.ce3b	 d0 04		bne $ce41	        bne  mul25      ; adjust for rec #1 &...
.ce3d	 a5 90		lda $90		        lda  accum+1    ; ...#0 = 1st rec
.ce3f	 f0 0b		beq $ce4c	        beq  mul50
.ce41	 a5 90		lda $90		mul25   lda  accum+1
.ce43	 38		sec		        sec
.ce44	 e9 01		sbc #$01	        sbc  #1
.ce46	 85 90		sta $90		        sta  accum+1
.ce48	 b0 02		bcs $ce4c	        bcs  mul50
.ce4a	 c6 91		dec $91		        dec  accum+2
.ce4c					mul50
.ce4c	 b5 c7		lda $c7,x	        lda  rs,x       ; copy recsiz
.ce4e	 85 6f		sta $6f		        sta  temp
.ce50	 46 6f		lsr $6f		mul100  lsr  temp       ; do an add ?
.ce52	 90 03		bcc $ce57	        bcc  mul200     ; no
.ce54	 20 ed ce	jsr $ceed	        jsr  addres     ; result=result+accum+1,2,3
.ce57	 20 e5 ce	jsr $cee5	mul200  jsr  accx2      ; 2*(accum+1,2,3)
.ce5a	 a5 6f		lda $6f		        lda  temp       ; done ?
.ce5c	 d0 f2		bne $ce50	        bne  mul100     ; no
.ce5e	 a5 d4		lda $d4		        lda  recptr     ; add in last bit
.ce60	 18		clc		        clc
.ce61	 65 8b		adc $8b		        adc  result
.ce63	 85 8b		sta $8b		        sta  result
.ce65	 90 06		bcc $ce6d	        bcc  mul400     ; skip no carry
.ce67	 e6 8c		inc $8c		        inc  result+1
.ce69	 d0 02		bne $ce6d	        bne  mul400
.ce6b	 e6 8d		inc $8d		        inc  result+2
.ce6d	 60		rts		mul400  rts
.ce6e	 a9 fe		lda #$fe	div254  lda  #254       ; divide by 254

>ce70	 2c                       		.byte  skip2	; skip two bytes

.ce71	 a9 78		lda #$78	div120  lda  #120       ; divide by 120
.ce73	 85 6f		sta $6f		        sta  temp       ; save divisor
.ce75	 a2 03		ldx #$03	        ldx  #3         ; swap accum+1,2,3 with
.ce77	 b5 8f		lda $8f,x	div100  lda  accum,x    ; result,1,2
.ce79	 48		pha		        pha
.ce7a	 b5 8a		lda $8a,x	        lda  result-1,x
.ce7c	 95 8f		sta $8f,x	        sta  accum,x
.ce7e	 68		pla		        pla
.ce7f	 95 8a		sta $8a,x	        sta  result-1,x
.ce81	 ca		dex		        dex
.ce82	 d0 f3		bne $ce77	        bne  div100
.ce84	 20 d9 ce	jsr $ced9	        jsr  zerres     ; result=0
.ce87	 a2 00		ldx #$00	div150  ldx  #0
.ce89	 b5 90		lda $90,x	div200  lda  accum+1,x  ; divide by 256
.ce8b	 95 8f		sta $8f,x	        sta  accum,x
.ce8d	 e8		inx		        inx
.ce8e	 e0 04		cpx #$04	        cpx  #4         ; done ?
.ce90	 90 f7		bcc $ce89	        bcc  div200     ; no
.ce92	 a9 00		lda #$00	        lda  #0         ; zero hi byte
.ce94	 85 92		sta $92		        sta  accum+3
.ce96	 24 6f		bit $6f		        bit  temp       ; a div120 ?
.ce98	 30 09		bmi $cea3	        bmi  div300     ; no
.ce9a	 06 8f		asl $8f		        asl  accum      ; only divide by 128
.ce9c	 08		php		        php     	; save carry
.ce9d	 46 8f		lsr $8f		        lsr  accum      ; normalize
.ce9f	 28		plp		        plp     	; restore carry
.cea0	 20 e6 ce	jsr $cee6	        jsr  acc200     ; 2*(x/256)=x/128
.cea3	 20 ed ce	jsr $ceed	div300  jsr  addres     ; total a quotient
.cea6	 20 e5 ce	jsr $cee5	        jsr  accx2      ; a=2*a
.cea9	 24 6f		bit $6f		        bit  temp       ; a div120 ?
.ceab	 30 03		bmi $ceb0	        bmi  div400     ; no
.cead	 20 e2 ce	jsr $cee2	        jsr  accx4      ; a=4*(2*a)=8*a
.ceb0	 a5 8f		lda $8f		div400  lda  accum      ; add in remainder
.ceb2	 18		clc		        clc
.ceb3	 65 90		adc $90		        adc  accum+1
.ceb5	 85 90		sta $90		        sta  accum+1
.ceb7	 90 06		bcc $cebf	        bcc  div500
.ceb9	 e6 91		inc $91		        inc  accum+2
.cebb	 d0 02		bne $cebf	        bne  div500
.cebd	 e6 92		inc $92		        inc  accum+3
.cebf	 a5 92		lda $92		div500  lda  accum+3    ; test < 256
.cec1	 05 91		ora $91		        ora  accum+2
.cec3	 d0 c2		bne $ce87	        bne  div150     ; crunch some more
.cec5	 a5 90		lda $90		        lda  accum+1    ; is remainder < divisor
.cec7	 38		sec		        sec
.cec8	 e5 6f		sbc $6f		        sbc  temp
.ceca	 90 0c		bcc $ced8	        bcc  div700     ; yes
.cecc	 e6 8b		inc $8b		        inc  result     ; no - fix result
.cece	 d0 06		bne $ced6	        bne  div600
.ced0	 e6 8c		inc $8c		        inc  result+1
.ced2	 d0 02		bne $ced6	        bne  div600
.ced4	 e6 8d		inc $8d		        inc  result+2
.ced6	 85 90		sta $90		div600  sta  accum+1    ; new remainder
.ced8	 60		rts		div700  rts
.ced9	 a9 00		lda #$00	zerres  lda  #0
.cedb	 85 8b		sta $8b		        sta  result
.cedd	 85 8c		sta $8c		        sta  result+1
.cedf	 85 8d		sta $8d		        sta  result+2
.cee1	 60		rts		        rts
.cee2	 20 e5 ce	jsr $cee5	accx4   jsr  accx2
.cee5	 18		clc		accx2   clc
.cee6	 26 90		rol $90		acc200  rol  accum+1
.cee8	 26 91		rol $91		        rol  accum+2
.ceea	 26 92		rol $92		        rol  accum+3
.ceec	 60		rts		        rts
.ceed	 18		clc		addres  clc
.ceee	 a2 fd		ldx #$fd	        ldx  #$fd
.cef0	 b5 8e		lda $8e,x	add100  lda  result+3,x
.cef2	 75 93		adc $93,x	        adc  accum+4,x
.cef4	 95 8e		sta $8e,x	        sta  result+3,x
.cef6	 e8		inx		        inx
.cef7	 d0 f7		bne $cef0	        bne  add100
.cef9	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "tst2.asm"

;******  Processing file "tst2.asm"

.cefa	 a2 00		ldx #$00	lruint  ldx  #0         ; init lru table
.cefc	 8a		txa		lruilp  txa
.cefd	 95 fa		sta $fa,x	        sta  lrutbl,x
.ceff	 e8		inx		        inx
.cf00	 e0 04		cpx #$04	        cpx  #cmdchn
.cf02	 d0 f8		bne $cefc	        bne  lruilp
.cf04	 a9 06		lda #$06		lda  #cmdchn+2
.cf06	 95 fa		sta $fa,x	        sta  lrutbl,x
.cf08	 60		rts		        rts
.cf09	 a0 04		ldy #$04	lruupd  ldy  #cmdchn
.cf0b	 a6 82		ldx $82		        ldx  lindx
.cf0d	 b9 fa 00	lda $00fa,y	lrulp1  lda  lrutbl,y
.cf10	 96 fa		stx $fa,y	        stx  lrutbl,y
.cf12	 c5 82		cmp $82		        cmp  lindx
.cf14	 f0 07		beq $cf1d	        beq  lruext
.cf16	 88		dey		        dey
.cf17	 30 e1		bmi $cefa	        bmi  lruint
.cf19	 aa		tax		        tax
.cf1a	 4c 0d cf	jmp $cf0d	        jmp  lrulp1
.cf1d	 60		rts		lruext  rts
.cf1e					dblbuf
.cf1e	 20 09 cf	jsr $cf09	        jsr  lruupd
.cf21	 20 b7 df	jsr $dfb7	        jsr  getina
.cf24	 d0 46		bne $cf6c	        bne  dbl15
.cf26	 20 d3 d1	jsr $d1d3	        jsr  setdrn
.cf29	 20 8e d2	jsr $d28e	        jsr  getbuf
.cf2c	 30 48		bmi $cf76	        bmi  dbl30
.cf2e	 20 c2 df	jsr $dfc2	        jsr  putina
.cf31	 a5 80		lda $80		        lda  track
.cf33	 48		pha		        pha
.cf34	 a5 81		lda $81		        lda  sector
.cf36	 48		pha		        pha
.cf37	 a9 01		lda #$01	        lda  #1
.cf39	 20 f6 d4	jsr $d4f6	        jsr  drdbyt
.cf3c	 85 81		sta $81		        sta  sector
.cf3e	 a9 00		lda #$00	        lda  #0
.cf40	 20 f6 d4	jsr $d4f6	        jsr  drdbyt
.cf43	 85 80		sta $80		        sta  track
.cf45	 f0 1f		beq $cf66	        beq  dbl10
.cf47	 20 25 d1	jsr $d125	        jsr  typfil
.cf4a	 f0 0b		beq $cf57	        beq  dbl05      ; it's rel
.cf4c	 20 ab dd	jsr $ddab	        jsr  tstwrt
.cf4f	 d0 06		bne $cf57	        bne  dbl05      ; read ahead
.cf51	 20 8c cf	jsr $cf8c	        jsr  tglbuf     ; just switch on write
.cf54	 4c 5d cf	jmp $cf5d	        jmp  dbl08
.cf57	 20 8c cf	jsr $cf8c	dbl05	jsr  tglbuf
.cf5a	 20 57 de	jsr $de57		jsr  rdab
.cf5d					dbl08
.cf5d	 68		pla		        pla
.cf5e	 85 81		sta $81		        sta  sector
.cf60	 68		pla		        pla
.cf61	 85 80		sta $80		        sta  track
.cf63	 4c 6f cf	jmp $cf6f	        jmp  dbl20
.cf66					dbl10
.cf66	 68		pla		        pla
.cf67	 85 81		sta $81		        sta  sector
.cf69	 68		pla		        pla
.cf6a	 85 80		sta $80		        sta  track
.cf6c	 20 8c cf	jsr $cf8c	dbl15   jsr  tglbuf
.cf6f	 20 93 df	jsr $df93	dbl20   jsr  getact
.cf72	 aa		tax		        tax
.cf73	 4c 99 d5	jmp $d599	        jmp  watjob
.cf76					dbl30
.cf76	 a9 70		lda #$70	        lda  #nochnl
.cf78	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.cf7b					dbset
.cf7b	 20 09 cf	jsr $cf09	        jsr  lruupd
.cf7e	 20 b7 df	jsr $dfb7	        jsr  getina
.cf81	 d0 08		bne $cf8b	        bne  dbs10
.cf83	 20 8e d2	jsr $d28e	        jsr  getbuf
.cf86	 30 ee		bmi $cf76	        bmi  dbl30      ; no buffers
.cf88	 20 c2 df	jsr $dfc2	        jsr  putina     ; store inactive buff #
.cf8b					dbs10
.cf8b	 60		rts		        rts
.cf8c	 a6 82		ldx $82		tglbuf  ldx  lindx
.cf8e	 b5 a7		lda $a7,x	        lda  buf0,x
.cf90	 49 80		eor #$80	        eor  #$80
.cf92	 95 a7		sta $a7,x	        sta  buf0,x
.cf94	 b5 ae		lda $ae,x	        lda  buf1,x
.cf96	 49 80		eor #$80	        eor  #$80
.cf98	 95 ae		sta $ae,x	        sta  buf1,x
.cf9a	 60		rts		        rts
.cf9b	 a2 12		ldx #$12	pibyte  ldx  #iwsa
.cf9d	 86 83		stx $83		        stx  sa
.cf9f	 20 07 d1	jsr $d107	        jsr  fndwch
.cfa2	 20 00 c1	jsr $c100	        jsr  setlds
.cfa5	 20 25 d1	jsr $d125	        jsr  typfil
.cfa8	 90 05		bcc $cfaf	        bcc  pbyte
.cfaa	 a9 20		lda #$20	        lda  #ovrflo
.cfac	 20 9d dd	jsr $dd9d	        jsr  clrflg
.cfaf	 a5 83		lda $83		pbyte   lda  sa
.cfb1	 c9 0f		cmp #$0f	        cmp  #15
.cfb3	 f0 23		beq $cfd8	        beq  l42
.cfb5	 d0 08		bne $cfbf	        bne  l40
.cfb7	 a5 84		lda $84		put     lda  orgsa      ; is chanl cmd or dat
.cfb9	 29 8f		and #$8f	        and  #$8f
.cfbb	 c9 0f		cmp #$0f	        cmp  #15        ; <15
.cfbd	 b0 19		bcs $cfd8	        bcs  l42
.cfbf	 20 25 d1	jsr $d125	l40     jsr  typfil     ; data byte to store
.cfc2	 b0 05		bcs $cfc9	        bcs  l41        ; branch if rnd
.cfc4	 a5 85		lda $85		        lda  data       ; seq file
.cfc6	 4c 9d d1	jmp $d19d	        jmp  wrtbyt     ; write byte to chanl
.cfc9	 d0 03		bne $cfce	l41     bne  l46
.cfcb	 4c ab e0	jmp $e0ab	        jmp  wrtrel
.cfce	 a5 85		lda $85		l46     lda  data       ; rnd file write
.cfd0	 20 f1 cf	jsr $cff1	        jsr  putbyt     ; write to chanl
.cfd3	 a4 82		ldy $82		        ldy  lindx      ; prepare nxt byte
.cfd5	 4c ee d3	jmp $d3ee	        jmp  rnget2
.cfd8	 a9 04		lda #$04	l42     lda  #cmdchn    ; write to cmd chanl
.cfda	 85 82		sta $82		        sta  lindx
.cfdc	 20 e8 d4	jsr $d4e8	        jsr  getpnt     ; test if comm and buffer full
.cfdf	 c9 2a		cmp #$2a	        cmp  #<cmdbuf+cmdlen+1
.cfe1	 f0 05		beq $cfe8	        beq  l50        ; it is full (>cmdlen)
.cfe3	 a5 85		lda $85		        lda  data       ; not full yet
.cfe5	 20 f1 cf	jsr $cff1	        jsr  putbyt     ; store the byte
.cfe8	 a5 f8		lda $f8		l50     lda  eoiflg     ; tst if lst byte of msg
.cfea	 f0 01		beq $cfed	        beq  l45        ; it is
.cfec	 60		rts		        rts     	; not yet , return
.cfed	 ee 55 02	inc $0255	l45     inc  cmdwat     ; set cmd waiting flag
.cff0	 60		rts		        rts
.cff1	 48		pha		putbyt  pha     	;  save .a
.cff2	 20 93 df	jsr $df93	        jsr  getact     ; get active buf#
.cff5	 10 06		bpl $cffd	        bpl  putb1      ; brach if there is one
.cff7	 68		pla		        pla     	; no buffer error
.cff8	 a9 61		lda #$61	        lda  #filnop
.cffa	 4c c8 c1	jmp $c1c8	        jmp  cmderr     ;  jmp to error routine
.cffd	 0a		asl a		putb1   asl  a          ; save the byte in buffer
.cffe	 aa		tax		        tax
.cfff	 68		pla		        pla
.d000	 81 99		sta ($99,x)	        sta  (buftab,x)
.d002	 f6 99		inc $99,x	        inc  buftab,x   ; inc the buffer pointer
.d004	 60		rts		        rts     	; last slot in buf, acm=1
.d005	 20 d1 c1	jsr $c1d1	intdrv  jsr  simprs     ; init drvs (command)
.d008	 20 a6 ab	jsr $aba6		jsr  ptch74	; set def parms
.d00b	 4c 94 c1	jmp $c194	        jmp  endcmd
.d00e					itrial
.d00e	 20 0f f1	jsr $f10f		jsr  bam2a
.d011	 a8		tay			tay
.d012	 b6 a7		ldx $a7,y		ldx  buf0,y
.d014	 e0 ff		cpx #$ff		cpx  #$ff
.d016	 d0 14		bne $d02c		bne  nk
.d018	 48		pha			pha
.d019	 20 8e d2	jsr $d28e		jsr  getbuf
.d01c	 aa		tax			tax
.d01d	 10 05		bpl $d024		bpl  +
.d01f	 a9 70		lda #$70		lda  #nochnl
.d021	 20 45 e6	jsr $e645		jsr  cmder2
.d024	 68		pla		+	pla
.d025	 a8		tay			tay
.d026	 8a		txa			txa
.d027	 09 80		ora #$80		ora  #$80
.d029	 99 a7 00	sta $00a7,y		sta  buf0,y
.d02c	 8a		txa		nk	txa
.d02d	 29 0f		and #$0f		and  #15
.d02f	 85 f9		sta $f9			sta  jobnum
.d031	 a2 00		ldx #$00		ldx  #$00
.d033	 86 81		stx $81			stx  sector
.d035	 ae 85 fe	ldx $fe85		ldx  dirtrk
.d038	 86 80		stx $80			stx  track
.d03a	 20 d3 d6	jsr $d6d3		jsr  seth
.d03d	 a9 b0		lda #$b0		lda  #seek
.d03f	 4c e5 a6	jmp $a6e5		jmp  ptch24
.d042	 20 d1 f0	jsr $f0d1	initdr  jsr  clnbam
.d045	 20 13 d3	jsr $d313		jsr  cldchn
.d048	 20 0e d0	jsr $d00e	        jsr  itrial
.d04b	 a6 7f		ldx $7f			ldx  drvnum
.d04d	 a9 00		lda #$00		lda  #0
.d04f	 9d 51 02	sta $0251,x		sta  mdirty,x
.d052	 8a		txa			txa
.d053	 0a		asl a			asl  a
.d054	 aa		tax			tax
.d055	 a5 16		lda $16			lda  header
.d057	 95 12		sta $12,x		sta  dskid,x
.d059	 a5 17		lda $17			lda  header+1
.d05b	 95 13		sta $13,x		sta  dskid+1,x
.d05d	 20 9e ab	jsr $ab9e		jsr  ptch73
.d060	 a5 f9		lda $f9			lda  jobnum
.d062	 0a		asl a		        asl  a
.d063	 aa		tax		        tax
.d064	 a9 02		lda #$02	        lda  #2         ; skip link bytes
.d066	 95 99		sta $99,x	        sta  buftab,x
.d068	 a1 99		lda ($99,x)	        lda  (buftab,x)
.d06a	 a6 7f		ldx $7f		        ldx  drvnum
.d06c	 9d 01 01	sta $0101,x	        sta  dskver,x   ; set up disk version #
.d06f	 a9 00		lda #$00		lda  #0
.d071	 4c 1d aa	jmp $aa1d		jmp  ptch51
.d074	 ea		nop			nop
.d075					rtch51
.d075	 20 3a ef	jsr $ef3a	nfcalc  jsr  setbpt
.d078	 a0 04		ldy #$04		ldy  #4
.d07a	 a9 00		lda #$00		lda  #0
.d07c	 aa		tax			tax
.d07d	 18		clc		-	clc
.d07e	 71 6d		adc ($6d),y		adc  (bmpnt),y
.d080	 90 01		bcc $d083		bcc +
.d082	 e8		inx			inx
.d083					+
.d083	 c8		iny		-	iny
.d084	 c8		iny			iny
.d085	 c8		iny			iny
.d086	 c8		iny			iny
.d087	 c0 48		cpy #$48		cpy  #$48
.d089	 f0 f8		beq $d083		beq -
.d08b	 c0 90		cpy #$90		cpy #$90
.d08d	 d0 ee		bne $d07d		bne --
.d08f	 48		pha			pha
.d090	 8a		txa			txa
.d091	 a6 7f		ldx $7f			ldx  drvnum
.d093	 9d fc 02	sta $02fc,x		sta  ndbh,x
.d096	 68		pla			pla
.d097	 4c 51 a9	jmp $a951		jmp  ptch40
.d09a	 60		rts			rts
.d09b	 20 d0 d6	jsr $d6d0	strrd   jsr  sethdr     ; start dbl buf, use
.d09e	 20 c3 d0	jsr $d0c3	        jsr  rdbuf      ; trk, sec as start block
.d0a1	 20 99 d5	jsr $d599	        jsr  watjob
.d0a4	 20 37 d1	jsr $d137	        jsr  getbyt
.d0a7	 85 80		sta $80		        sta  track
.d0a9	 20 37 d1	jsr $d137	        jsr  getbyt
.d0ac	 85 81		sta $81		        sta  sector
.d0ae	 60		rts		        rts
.d0af	 20 9b d0	jsr $d09b	strdbl  jsr  strrd
.d0b2	 a5 80		lda $80		        lda  track
.d0b4	 d0 01		bne $d0b7	        bne  str1
.d0b6	 60		rts		        rts
.d0b7	 20 1e cf	jsr $cf1e	str1    jsr  dblbuf
.d0ba	 20 d0 d6	jsr $d6d0	        jsr  sethdr
.d0bd	 20 c3 d0	jsr $d0c3	        jsr  rdbuf
.d0c0	 4c 1e cf	jmp $cf1e	        jmp  dblbuf
.d0c3	 a9 80		lda #$80	rdbuf   lda  #read	; rd job on trk, sec
.d0c5	 d0 02		bne $d0c9	        bne  strtit
.d0c7	 a9 90		lda #$90	wrtbuf  lda  #write	; wr job on trk, sec
.d0c9	 8d 4d 02	sta $024d	strtit  sta  cmd
.d0cc	 20 93 df	jsr $df93	        jsr  getact
.d0cf	 aa		tax		        tax
.d0d0	 20 06 d5	jsr $d506	        jsr  setljb
.d0d3	 8a		txa		        txa
.d0d4	 48		pha		        pha
.d0d5	 0a		asl a		        asl  a
.d0d6	 aa		tax		        tax
.d0d7	 a9 00		lda #$00	        lda  #0
.d0d9	 95 99		sta $99,x	        sta  buftab,x
.d0db	 20 25 d1	jsr $d125	        jsr  typfil
.d0de	 c9 04		cmp #$04	        cmp  #4
.d0e0	 b0 06		bcs $d0e8	        bcs  wrtc1      ; not sequential type
.d0e2	 f6 b5		inc $b5,x	        inc  nbkl,x
.d0e4	 d0 02		bne $d0e8	        bne  wrtc1
.d0e6	 f6 bb		inc $bb,x	        inc  nbkh,x
.d0e8	 68		pla		wrtc1   pla
.d0e9	 aa		tax		        tax
.d0ea	 60		rts		        rts
.d0eb	 a5 83		lda $83		fndrch  lda  sa
.d0ed	 c9 13		cmp #$13	        cmp  #maxsa+1
.d0ef	 90 02		bcc $d0f3	        bcc  fndc20
.d0f1	 29 0f		and #$0f	        and  #$f
.d0f3	 c9 0f		cmp #$0f	fndc20  cmp  #cmdsa
.d0f5	 d0 02		bne $d0f9	        bne  fndc25
.d0f7	 a9 10		lda #$10	        lda  #errsa
.d0f9	 aa		tax		fndc25  tax
.d0fa	 38		sec		        sec
.d0fb	 bd 2b 02	lda $022b,x	        lda  lintab,x
.d0fe	 30 06		bmi $d106	        bmi  fndc30
.d100	 29 0f		and #$0f	        and  #$f
.d102	 85 82		sta $82		        sta  lindx
.d104	 aa		tax		        tax
.d105	 18		clc		        clc
.d106	 60		rts		fndc30  rts
.d107	 a5 83		lda $83		fndwch  lda  sa
.d109	 c9 13		cmp #$13	        cmp  #maxsa+1
.d10b	 90 02		bcc $d10f	        bcc  fndw13
.d10d	 29 0f		and #$0f	        and  #$f
.d10f	 aa		tax		fndw13  tax
.d110	 bd 2b 02	lda $022b,x	        lda  lintab,x
.d113	 a8		tay		        tay
.d114	 0a		asl a		        asl  a
.d115	 90 0a		bcc $d121	        bcc  fndw15
.d117	 30 0a		bmi $d123	        bmi  fndw20
.d119	 98		tya		fndw10  tya
.d11a	 29 0f		and #$0f	        and  #$0f
.d11c	 85 82		sta $82		        sta  lindx
.d11e	 aa		tax		        tax
.d11f	 18		clc		        clc
.d120	 60		rts		        rts
.d121	 30 f6		bmi $d119	fndw15  bmi  fndw10
.d123	 38		sec		fndw20  sec
.d124	 60		rts		        rts
.d125					typfil
.d125	 a6 82		ldx $82		        ldx  lindx
.d127	 b5 ec		lda $ec,x	        lda  filtyp,x
.d129	 4a		lsr a		        lsr  a
.d12a	 29 07		and #$07	        and  #7
.d12c	 c9 04		cmp #$04	        cmp  #reltyp
.d12e	 60		rts		        rts
.d12f	 20 93 df	jsr $df93	getpre  jsr  getact
.d132	 0a		asl a		        asl  a
.d133	 aa		tax		        tax
.d134	 a4 82		ldy $82		        ldy  lindx
.d136	 60		rts		        rts
.d137	 20 2f d1	jsr $d12f	getbyt	jsr  getpre
.d13a	 b9 44 02	lda $0244,y	        lda  lstchr,y
.d13d	 f0 12		beq $d151	        beq  getb1
.d13f	 a1 99		lda ($99,x)	        lda  (buftab,x)
.d141	 48		pha		        pha
.d142	 b5 99		lda $99,x	        lda  buftab,x
.d144	 d9 44 02	cmp $0244,y	        cmp  lstchr,y
.d147	 d0 04		bne $d14d	        bne  getb2
.d149	 a9 ff		lda #$ff	        lda  #$ff
.d14b	 95 99		sta $99,x	        sta  buftab,x
.d14d	 68		pla		getb2   pla
.d14e	 f6 99		inc $99,x	        inc  buftab,x
.d150	 60		rts		        rts
.d151	 a1 99		lda ($99,x)	getb1   lda  (buftab,x)
.d153	 f6 99		inc $99,x	        inc  buftab,x
.d155	 60		rts		        rts
.d156	 20 37 d1	jsr $d137	rdbyt   jsr  getbyt
.d159	 d0 36		bne $d191	        bne  rd3
.d15b	 85 85		sta $85		        sta  data
.d15d	 b9 44 02	lda $0244,y	rd0     lda  lstchr,y
.d160	 f0 08		beq $d16a	        beq  rd1
.d162	 a9 80		lda #$80	        lda  #eoiout
.d164	 99 f2 00	sta $00f2,y	rd01    sta  chnrdy,y
.d167	 a5 85		lda $85		        lda  data
.d169	 60		rts		        rts
.d16a	 20 1e cf	jsr $cf1e	rd1     jsr  dblbuf
.d16d	 a9 00		lda #$00	        lda  #0
.d16f	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.d172	 20 37 d1	jsr $d137	        jsr  getbyt
.d175	 c9 00		cmp #$00	        cmp  #0
.d177	 f0 19		beq $d192	        beq  rd4
.d179	 85 80		sta $80		        sta  track
.d17b	 20 37 d1	jsr $d137	        jsr  getbyt
.d17e	 85 81		sta $81		        sta  sector
.d180	 20 1e cf	jsr $cf1e	        jsr  dblbuf
.d183	 20 d3 d1	jsr $d1d3	        jsr  setdrn
.d186	 20 d0 d6	jsr $d6d0	        jsr  sethdr
.d189	 20 c3 d0	jsr $d0c3	        jsr  rdbuf
.d18c	 20 1e cf	jsr $cf1e	        jsr  dblbuf
.d18f	 a5 85		lda $85		        lda  data
.d191	 60		rts		rd3     rts
.d192	 20 37 d1	jsr $d137	rd4     jsr  getbyt
.d195	 a4 82		ldy $82		        ldy  lindx
.d197	 99 44 02	sta $0244,y	        sta  lstchr,y
.d19a	 a5 85		lda $85		        lda  data
.d19c	 60		rts		        rts
.d19d	 20 f1 cf	jsr $cff1	wrtbyt  jsr  putbyt
.d1a0	 f0 01		beq $d1a3	        beq  wrt0
.d1a2	 60		rts		        rts
.d1a3	 20 d3 d1	jsr $d1d3	wrt0    jsr  setdrn
.d1a6	 20 1e f1	jsr $f11e		jsr  nxtts
.d1a9	 a9 00		lda #$00	        lda  #0
.d1ab	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.d1ae	 a5 80		lda $80		        lda  track
.d1b0	 20 f1 cf	jsr $cff1	        jsr  putbyt
.d1b3	 a5 81		lda $81		        lda  sector
.d1b5	 20 f1 cf	jsr $cff1	        jsr  putbyt
.d1b8	 20 c7 d0	jsr $d0c7	        jsr  wrtbuf
.d1bb	 20 1e cf	jsr $cf1e	        jsr  dblbuf
.d1be	 20 d0 d6	jsr $d6d0	        jsr  sethdr
.d1c1	 a9 02		lda #$02	        lda  #2
.d1c3	 4c c8 d4	jmp $d4c8	        jmp  setpnt
.d1c6					incptr
.d1c6	 85 6f		sta $6f		        sta  temp
.d1c8	 20 e8 d4	jsr $d4e8	        jsr  getpnt
.d1cb	 18		clc		        clc
.d1cc	 65 6f		adc $6f		        adc  temp
.d1ce	 95 99		sta $99,x	        sta  buftab,x
.d1d0	 85 94		sta $94		        sta  dirbuf
.d1d2	 60		rts		        rts
.d1d3	 20 93 df	jsr $df93	setdrn  jsr  getact
.d1d6	 aa		tax		        tax
.d1d7	 bd 5b 02	lda $025b,x	        lda  lstjob,x
.d1da	 29 01		and #$01	        and  #1
.d1dc	 85 7f		sta $7f		        sta  drvnum
.d1de	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "tst3.asm"

;******  Processing file "tst3.asm"

.d1df	 38		sec		getwch  sec     	; set .c=1 indicate write
.d1e0	 b0 01		bcs $d1e3	        bcs  getr2
.d1e2	 18		clc		getrch  clc     	; set .c=0 indicate read
.d1e3	 08		php		getr2   php     	; save r/w flag (.c)
.d1e4	 85 6f		sta $6f		        sta  temp       ; save #bufs needed
.d1e6	 20 27 d2	jsr $d227	        jsr  frechn     ; free any channels
.d1e9	 20 7f d3	jsr $d37f	        jsr  fndlnx     ; get next lindx open
.d1ec	 85 82		sta $82		        sta  lindx
.d1ee	 a6 83		ldx $83		        ldx  sa
.d1f0	 28		plp		        plp
.d1f1	 90 02		bcc $d1f5	        bcc  getr55
.d1f3	 09 80		ora #$80	        ora  #$80
.d1f5	 9d 2b 02	sta $022b,x	getr55  sta  lintab,x   ; save lindx in lintab
.d1f8	 29 3f		and #$3f	        and  #$3f
.d1fa	 a8		tay		        tay     	; now get the buffers
.d1fb	 a9 ff		lda #$ff	        lda  #$ff
.d1fd	 99 a7 00	sta $00a7,y	        sta  buf0,y
.d200	 99 ae 00	sta $00ae,y	        sta  buf1,y
.d203	 99 cd 00	sta $00cd,y	        sta  ss,y
.d206	 c6 6f		dec $6f		        dec  temp
.d208	 30 1c		bmi $d226	        bmi  getr4
.d20a	 20 8e d2	jsr $d28e	        jsr  getbuf
.d20d	 10 08		bpl $d217	        bpl  getr5
.d20f	 20 5a d2	jsr $d25a	gberr   jsr  relbuf     ;  error ,rel bufs
.d212	 a9 70		lda #$70	        lda  #nochnl
.d214	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.d217	 99 a7 00	sta $00a7,y	getr5   sta  buf0,y
.d21a	 c6 6f		dec $6f		        dec  temp
.d21c	 30 08		bmi $d226	        bmi  getr4
.d21e	 20 8e d2	jsr $d28e	        jsr  getbuf
.d221	 30 ec		bmi $d20f	        bmi  gberr
.d223	 99 ae 00	sta $00ae,y	        sta  buf1,y
.d226	 60		rts		getr4   rts
.d227	 a5 83		lda $83		frechn  lda  sa         ; free chnl assoc w/sa
.d229	 c9 0f		cmp #$0f	        cmp  #$f        ; free rd/wrt chnls
.d22b	 d0 01		bne $d22e	        bne  freeit     ; but don't free ch15
.d22d	 60		rts		        rts
.d22e	 a6 83		ldx $83		freeit  ldx  sa
.d230	 bd 2b 02	lda $022b,x	        lda  lintab,x
.d233	 c9 ff		cmp #$ff	        cmp  #$ff
.d235	 f0 22		beq $d259	        beq  fre25
.d237	 29 3f		and #$3f	        and  #$3f
.d239	 85 82		sta $82		        sta  lindx
.d23b	 a9 ff		lda #$ff	        lda  #$ff
.d23d	 9d 2b 02	sta $022b,x	        sta  lintab,x
.d240	 a6 82		ldx $82		        ldx  lindx
.d242	 a9 00		lda #$00	        lda  #0
.d244	 95 f2		sta $f2,x	        sta  chnrdy,x
.d246	 20 5a d2	jsr $d25a	        jsr  relbuf
.d249	 a6 82		ldx $82		        ldx  lindx      ; release lindx
.d24b	 a9 01		lda #$01	        lda  #1
.d24d	 ca		dex		rel15   dex
.d24e	 30 03		bmi $d253	        bmi  rel10
.d250	 0a		asl a		        asl  a
.d251	 d0 fa		bne $d24d	        bne  rel15
.d253	 0d 56 02	ora $0256	rel10   ora  linuse     ; 1=free 0=used
.d256	 8d 56 02	sta $0256	        sta  linuse
.d259	 60		rts		fre25   rts
.d25a	 a6 82		ldx $82		relbuf  ldx  lindx      ; given sa, free read chnl
.d25c	 b5 a7		lda $a7,x	        lda  buf0,x     ; release buffers (lindx)
.d25e	 c9 ff		cmp #$ff	        cmp  #$ff
.d260	 f0 09		beq $d26b	        beq  rel1
.d262	 48		pha		        pha
.d263	 a9 ff		lda #$ff	        lda  #$ff
.d265	 95 a7		sta $a7,x	        sta  buf0,x
.d267	 68		pla		        pla
.d268	 20 f3 d2	jsr $d2f3	        jsr  frebuf
.d26b	 a6 82		ldx $82		rel1    ldx  lindx
.d26d	 b5 ae		lda $ae,x	        lda  buf1,x
.d26f	 c9 ff		cmp #$ff	        cmp  #$ff
.d271	 f0 09		beq $d27c	        beq  rel2
.d273	 48		pha		        pha
.d274	 a9 ff		lda #$ff	        lda  #$ff
.d276	 95 ae		sta $ae,x	        sta  buf1,x
.d278	 68		pla		        pla
.d279	 20 f3 d2	jsr $d2f3	        jsr  frebuf
.d27c	 a6 82		ldx $82		rel2    ldx  lindx
.d27e	 b5 cd		lda $cd,x	        lda  ss,x
.d280	 c9 ff		cmp #$ff	        cmp  #$ff
.d282	 f0 09		beq $d28d	        beq  rel3
.d284	 48		pha		        pha
.d285	 a9 ff		lda #$ff	        lda  #$ff
.d287	 95 cd		sta $cd,x	        sta  ss,x
.d289	 68		pla		        pla
.d28a	 20 f3 d2	jsr $d2f3	        jsr  frebuf
.d28d	 60		rts		rel3    rts
.d28e	 98		tya		getbuf  tya     	; save .y
.d28f	 48		pha		        pha
.d290	 a0 01		ldy #$01	        ldy  #1
.d292	 20 ba d2	jsr $d2ba	        jsr  fndbuf
.d295	 10 0c		bpl $d2a3	        bpl  gbf1       ; found one
.d297	 88		dey		        dey
.d298	 20 ba d2	jsr $d2ba	        jsr  fndbuf
.d29b	 10 06		bpl $d2a3	        bpl  gbf1       ; found one
.d29d	 20 39 d3	jsr $d339	        jsr  stlbuf     ; steal one
.d2a0	 aa		tax		        tax     	; test it
.d2a1	 30 13		bmi $d2b6	        bmi  gbf2       ; didn't find one
.d2a3	 b5 00		lda $00,x	gbf1    lda  jobs,x
.d2a5	 30 fc		bmi $d2a3	        bmi  gbf1       ; wait for job free
.d2a7	 a5 7f		lda $7f		        lda  drvnum
.d2a9	 95 00		sta $00,x	        sta  jobs,x     ; clear job queue
.d2ab	 9d 5b 02	sta $025b,x	        sta  lstjob,x
.d2ae	 8a		txa		        txa
.d2af	 0a		asl a		        asl  a
.d2b0	 a8		tay		        tay
.d2b1	 a9 02		lda #$02	        lda  #2
.d2b3	 99 99 00	sta $0099,y	        sta  buftab,y
.d2b6	 68		pla		gbf2    pla
.d2b7	 a8		tay		        tay     	; restore .y
.d2b8	 8a		txa		        txa     	; exit with buf # in .a & cc set
.d2b9	 60		rts		        rts
.d2ba	 a2 07		ldx #$07	fndbuf  ldx  #7
.d2bc	 b9 4f 02	lda $024f,y	fb1     lda  bufuse,y   ; search bufuse
.d2bf	 3d e9 ef	and $efe9,x	        and  bmask,x
.d2c2	 f0 04		beq $d2c8	        beq  fb2        ; found a free one
.d2c4	 ca		dex		        dex
.d2c5	 10 f5		bpl $d2bc	        bpl  fb1        ; until all bits are tested
.d2c7	 60		rts		        rts
.d2c8					fb2
.d2c8	 b9 4f 02	lda $024f,y	        lda  bufuse,y
.d2cb	 5d e9 ef	eor $efe9,x	        eor  bmask,x    ; set bit
.d2ce	 99 4f 02	sta $024f,y	        sta  bufuse,y
.d2d1	 8a		txa		        txa
.d2d2	 88		dey		        dey
.d2d3	 30 03		bmi $d2d8	        bmi  +
.d2d5	 18		clc		        clc
.d2d6	 69 08		adc #$08	        adc  #8
.d2d8	 aa		tax		+	tax
.d2d9	 60		rts		freb3   rts
.d2da					freiac
.d2da	 a6 82		ldx $82		        ldx  lindx
.d2dc	 b5 a7		lda $a7,x	        lda  buf0,x
.d2de	 30 09		bmi $d2e9	        bmi  fri10
.d2e0	 8a		txa		        txa
.d2e1	 18		clc		        clc
.d2e2	 69 07		adc #$07	        adc #7
.d2e4	 aa		tax		        tax
.d2e5	 b5 a7		lda $a7,x	        lda  buf0,x
.d2e7	 10 f0		bpl $d2d9	        bpl  freb3
.d2e9	 c9 ff		cmp #$ff	fri10   cmp  #$ff
.d2eb	 f0 ec		beq $d2d9	        beq  freb3
.d2ed	 48		pha		        pha
.d2ee	 a9 ff		lda #$ff	        lda  #$ff
.d2f0	 95 a7		sta $a7,x	        sta  buf0,x
.d2f2	 68		pla		        pla
.d2f3	 29 0f		and #$0f	frebuf  and  #$f
.d2f5	 a8		tay		        tay
.d2f6	 c8		iny		        iny
.d2f7	 a2 10		ldx #$10	        ldx  #16
.d2f9	 6e 50 02	ror $0250	freb1   ror  bufuse+1
.d2fc	 6e 4f 02	ror $024f		ror  bufuse
.d2ff	 88		dey		        dey
.d300	 d0 01		bne $d303	        bne  freb2
.d302	 18		clc		        clc
.d303	 ca		dex		freb2   dex
.d304	 10 f3		bpl $d2f9	        bpl  freb1
.d306	 60		rts		        rts
.d307	 a9 0e		lda #$0e	clrchn  lda  #14
.d309	 85 83		sta $83		        sta  sa
.d30b	 20 27 d2	jsr $d227	clrc1   jsr  frechn
.d30e	 c6 83		dec $83		        dec  sa
.d310	 d0 f9		bne $d30b	        bne  clrc1
.d312	 60		rts		        rts
.d313	 a9 0e		lda #$0e	cldchn  lda  #14
.d315	 85 83		sta $83		        sta  sa
.d317	 a6 83		ldx $83		clsd    ldx  sa
.d319	 bd 2b 02	lda $022b,x	        lda  lintab,x
.d31c	 c9 ff		cmp #$ff	        cmp  #$ff
.d31e	 f0 14		beq $d334	        beq  cld2
.d320	 29 3f		and #$3f	        and  #$3f
.d322	 85 82		sta $82		        sta  lindx
.d324	 20 93 df	jsr $df93	        jsr  getact
.d327	 aa		tax		        tax
.d328	 bd 5b 02	lda $025b,x	        lda  lstjob,x
.d32b	 29 01		and #$01	        and  #1
.d32d	 c5 7f		cmp $7f		        cmp  drvnum
.d32f	 d0 03		bne $d334	        bne  cld2
.d331	 20 27 d2	jsr $d227	        jsr  frechn
.d334	 c6 83		dec $83		cld2    dec  sa
.d336	 10 df		bpl $d317	        bpl  clsd
.d338	 60		rts		        rts
.d339	 a5 6f		lda $6f		stlbuf  lda  t0         ; search chnl's for least recently
.d33b	 48		pha		        pha     	; used buf & steals first inact buf.
.d33c	 a0 00		ldy #$00	        ldy  #0         ; input: lrutbl-least recently
.d33e	 b6 fa		ldx $fa,y	stl05   ldx  lrutbl,y   ; output: a=buf#
.d340	 b5 a7		lda $a7,x	        lda  buf0,x     ;         x=chnl index
.d342	 10 04		bpl $d348	        bpl  stl10      ;         y=lrutbl index
.d344	 c9 ff		cmp #$ff	        cmp  #$ff
.d346	 d0 16		bne $d35e	        bne  stl30      ; it's inactive
.d348	 8a		txa		stl10   txa
.d349	 18		clc		        clc
.d34a	 69 07		adc #$07	        adc  #mxchns+1	; <<<<<<<<<<<<<<
.d34c	 aa		tax		        tax
.d34d	 b5 a7		lda $a7,x	        lda  buf0,x
.d34f	 10 04		bpl $d355	        bpl  stl20
.d351	 c9 ff		cmp #$ff	        cmp  #$ff
.d353	 d0 09		bne $d35e	        bne  stl30
.d355	 c8		iny		stl20   iny
.d356	 c0 05		cpy #$05	        cpy  #mxchns-1
.d358	 90 e4		bcc $d33e	        bcc  stl05
.d35a	 a2 ff		ldx #$ff	        ldx  #$ff       ; set failure
.d35c	 d0 1c		bne $d37a	        bne  stl60      ; bra
.d35e	 86 6f		stx $6f		stl30   stx  t0         ; steal buf if no error
.d360	 29 3f		and #$3f	        and  #$3f
.d362	 aa		tax		        tax
.d363	 b5 00		lda $00,x	stl40   lda  jobs,x
.d365	 30 fc		bmi $d363	        bmi  stl40      ; wait till done
.d367	 4c 3f aa	jmp $aa3f	        jmp  ptch54
.d36a	 ea		nop		        nop
.d36b					rtch54
.d36b	 a6 6f		ldx $6f		        ldx  t0
.d36d	 e0 07		cpx #$07	        cpx  #mxchns+1	; <<<<<<<<<<<<<<
.d36f	 90 d7		bcc $d348	        bcc  stl10      ; check opposite slot
.d371	 b0 e2		bcs $d355	        bcs  stl20      ; check another channel
.d373	 a4 6f		ldy $6f		stl50   ldy  t0         ; found one !, so lets
.d375	 a9 ff		lda #$ff	        lda  #$ff       ; steal it
.d377	 99 a7 00	sta $00a7,y	        sta  buf0,y     ; clear slot
.d37a	 68		pla		stl60   pla
.d37b	 85 6f		sta $6f		        sta  t0
.d37d	 8a		txa		        txa     	; buf # in .a & set cc's
.d37e	 60		rts		        rts
.d37f	 a0 00		ldy #$00	fndlnx  ldy  #0         ; find free lindx to use
.d381	 a9 01		lda #$01	        lda  #1         ; mark used in linuse
.d383	 2c 56 02	bit $0256	fnd10   bit  linuse     ; 1=free 0=used
.d386	 d0 09		bne $d391	        bne  fnd30
.d388	 c8		iny		        iny
.d389	 0a		asl a		        asl  a
.d38a	 d0 f7		bne $d383	        bne  fnd10
.d38c	 a9 70		lda #$70	        lda  #nochnl    ; no free lindx available
.d38e	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.d391	 49 ff		eor #$ff	fnd30   eor  #$ff       ; toggle bit mask
.d393	 2d 56 02	and $0256	        and  linuse     ; mark bit used
.d396	 8d 56 02	sta $0256	        sta  linuse
.d399	 98		tya		        tya     	; return lindx in .a
.d39a	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "tst4.asm"

;******  Processing file "tst4.asm"

.d39b					gbyte
.d39b	 20 eb d0	jsr $d0eb	        jsr  fndrch
.d39e	 20 00 c1	jsr $c100	        jsr  setlds
.d3a1	 20 aa d3	jsr $d3aa	        jsr  get
.d3a4	 a6 82		ldx $82		        ldx  lindx
.d3a6	 bd 3e 02	lda $023e,x	        lda  chndat,x
.d3a9	 60		rts		        rts
.d3aa	 a6 82		ldx $82		get     ldx  lindx
.d3ac	 20 25 d1	jsr $d125	        jsr  typfil     ; get file type
.d3af	 d0 03		bne $d3b4	        bne  get00
.d3b1	 4c 20 e1	jmp $e120	        jmp  rdrel
.d3b4	 a5 83		lda $83		get00   lda  sa
.d3b6	 c9 0f		cmp #$0f	        cmp  #$f
.d3b8	 f0 5a		beq $d414	        beq  geterc
.d3ba	 b5 f2		lda $f2,x	        lda  chnrdy,x   ; was last char just sent
.d3bc	 29 08		and #$08	        and  #eoisnd    ; just sent eoi
.d3be	 d0 13		bne $d3d3	        bne  get1       ; nope not this time
.d3c0	 20 25 d1	jsr $d125	        jsr  typfil
.d3c3	 c9 07		cmp #$07	        cmp  #dirtyp
.d3c5	 d0 07		bne $d3ce	        bne  get0       ; not direct type
.d3c7	 a9 89		lda #$89	        lda  #rndrdy    ; direct file remains active
.d3c9	 95 f2		sta $f2,x	        sta  chnrdy,x   ; talker listener noeoi
.d3cb	 4c de d3	jmp $d3de	        jmp  rndget     ; prepare the next char
.d3ce	 a9 00		lda #$00	get0    lda  #notrdy    ; lst char sent,not ready
.d3d0	 95 f2		sta $f2,x	        sta  chnrdy,x
.d3d2	 60		rts		        rts
.d3d3	 a5 83		lda $83		get1    lda  sa         ; test if a load
.d3d5	 f0 32		beq $d409	        beq  get6       ; its a load sa of 0
.d3d7	 20 25 d1	jsr $d125	        jsr  typfil     ;  tst for rnd file
.d3da	 c9 04		cmp #$04	        cmp  #4
.d3dc	 90 22		bcc $d400	        bcc  seqget     ; seq file char get
.d3de	 20 2f d1	jsr $d12f	rndget  jsr  getpre     ; direct file get
.d3e1	 b5 99		lda $99,x	        lda  buftab,x
.d3e3	 d9 44 02	cmp $0244,y	        cmp  lstchr,y   ; up to lst char yet
.d3e6	 d0 04		bne $d3ec	        bne  rnget1     ; not yet
.d3e8	 a9 00		lda #$00	        lda  #0         ; read the whole thing
.d3ea	 95 99		sta $99,x	        sta  buftab,x   ; wrap pntr to 0
.d3ec	 f6 99		inc $99,x	rnget1  inc  buftab,x   ; get the next char
.d3ee	 a1 99		lda ($99,x)	rnget2  lda  (buftab,x)
.d3f0	 99 3e 02	sta $023e,y	        sta  chndat,y   ; save char in
.d3f3	 b5 99		lda $99,x	        lda  buftab,x
.d3f5	 d9 44 02	cmp $0244,y	        cmp  lstchr,y
.d3f8	 d0 05		bne $d3ff	        bne  rnget3
.d3fa	 a9 81		lda #$81	        lda  #rndeoi
.d3fc	 99 f2 00	sta $00f2,y	        sta  chnrdy,y   ; this is last char
.d3ff	 60		rts		rnget3  rts     	; send eoi with it
.d400	 20 56 d1	jsr $d156	seqget  jsr  rdbyt      ; read the next byte
.d403	 a6 82		ldx $82		get3    ldx  lindx
.d405	 9d 3e 02	sta $023e,x	        sta  chndat,x   ; store in chndat
.d408	 60		rts		        rts
.d409	 ad 54 02	lda $0254	get6    lda  dirlst     ; test if dir lsting
.d40c	 f0 f2		beq $d400	        beq  seqget     ; no, its not
.d40e	 20 67 ed	jsr $ed67	        jsr  getdir     ; yes it is,get dir char
.d411	 4c 03 d4	jmp $d403	        jmp  get3
.d414	 20 e8 d4	jsr $d4e8	geterc  jsr  getpnt
.d417	 c9 d4		cmp #$d4	        cmp  #<errbuf-1
.d419	 d0 18		bne $d433	        bne  ge10
.d41b	 a5 95		lda $95		        lda  dirbuf+1
.d41d	 c9 02		cmp #$02	        cmp  #>errbuf
.d41f	 d0 12		bne $d433	        bne  ge10
.d421	 a9 0d		lda #$0d	        lda  #cr
.d423	 85 85		sta $85		        sta  data
.d425	 20 23 c1	jsr $c123	        jsr  erroff
.d428	 a9 00		lda #$00	        lda  #0
.d42a	 20 c1 e6	jsr $e6c1	        jsr  errts0
.d42d	 c6 a5		dec $a5		        dec  cb+2
.d42f	 a9 80		lda #$80	        lda  #eoiout
.d431	 d0 12		bne $d445	        bne  ge30       ; (jump)
.d433	 20 37 d1	jsr $d137	ge10    jsr  getbyt
.d436	 85 85		sta $85		        sta  data
.d438	 d0 09		bne $d443	        bne  ge20
.d43a	 a9 d4		lda #$d4	ge15    lda  #<errbuf-1
.d43c	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.d43f	 a9 02		lda #$02	        lda  #>errbuf
.d441	 95 9a		sta $9a,x	        sta  buftab+1,x
.d443	 a9 88		lda #$88	ge20    lda  #rdytlk
.d445	 85 f7		sta $f7		ge30    sta  chnrdy+errchn
.d447	 a5 85		lda $85		        lda  data
.d449	 8d 43 02	sta $0243	        sta  chndat+errchn
.d44c	 60		rts		        rts
.d44d	 20 93 df	jsr $df93	nxtbuf  jsr  getact     ; read next buffer of a
.d450	 0a		asl a		        asl  a          ; file, follow links in the first
.d451	 aa		tax		        tax     	; two bytes. end of file if 1st char
.d452	 a9 00		lda #$00	        lda  #0         ; byte=0. 2nd char =length
.d454	 95 99		sta $99,x	        sta  buftab,x
.d456	 a1 99		lda ($99,x)	        lda  (buftab,x)
.d458	 f0 05		beq $d45f	        beq  nxtb1
.d45a	 d6 99		dec $99,x	        dec  buftab,x
.d45c	 4c 56 d1	jmp $d156	        jmp  rdbyt
.d45f	 60		rts		nxtb1   rts
.d460	 a9 80		lda #$80	drtrd   lda  #read	; direct block read
.d462	 d0 02		bne $d466	        bne  drt
.d464	 a9 90		lda #$90	drtwrt  lda  #write	; direct block write
.d466	 05 7f		ora $7f		drt     ora  drvnum
.d468	 8d 4d 02	sta $024d		sta  cmd
.d46b	 a5 f9		lda $f9		        lda  jobnum
.d46d	 20 d3 d6	jsr $d6d3	        jsr  seth
.d470	 a6 f9		ldx $f9		        ldx  jobnum
.d472	 4c 93 d5	jmp $d593	        jmp  doit2
.d475	 a9 01		lda #$01	opnird  lda  #1
.d477	 8d 4a 02	sta $024a	opntyp  sta  type
.d47a	 a9 11		lda #$11	        lda  #irsa
.d47c	 85 83		sta $83		        sta  sa
.d47e	 20 46 dc	jsr $dc46	        jsr  opnrch
.d481	 a9 02		lda #$02	        lda  #2
.d483	 4c c8 d4	jmp $d4c8	        jmp  setpnt
.d486	 a9 12		lda #$12	opniwr  lda  #iwsa      ; open internal wr chnl
.d488	 85 83		sta $83		        sta  sa         ; sa=16
.d48a	 4c da dc	jmp $dcda	        jmp  opnwch
.d48d	 20 3b de	jsr $de3b	nxdrbk  jsr  curblk
.d490	 a9 01		lda #$01	        lda  #1
.d492	 85 6f		sta $6f		        sta  temp
.d494	 a5 69		lda $69		        lda  secinc
.d496	 48		pha		        pha
.d497	 a9 03		lda #$03	        lda  #3         ; incr sec by 3 in dir
.d499	 85 69		sta $69		        sta  secinc
.d49b	 20 2d f1	jsr $f12d	        jsr  nxtds
.d49e	 68		pla		        pla
.d49f	 85 69		sta $69		        sta  secinc
.d4a1	 a9 00		lda #$00	        lda  #0
.d4a3	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.d4a6	 a5 80		lda $80		        lda  track
.d4a8	 20 f1 cf	jsr $cff1	        jsr  putbyt
.d4ab	 a5 81		lda $81		        lda  sector
.d4ad	 20 f1 cf	jsr $cff1	        jsr  putbyt
.d4b0	 20 c7 d0	jsr $d0c7	        jsr  wrtbuf
.d4b3	 20 99 d5	jsr $d599	        jsr  watjob
.d4b6	 a9 00		lda #$00	        lda  #0
.d4b8	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.d4bb	 20 f1 cf	jsr $cff1	nxdb1   jsr  putbyt
.d4be	 d0 fb		bne $d4bb	        bne  nxdb1
.d4c0	 20 f1 cf	jsr $cff1	        jsr  putbyt
.d4c3	 a9 ff		lda #$ff	        lda  #$ff
.d4c5	 4c f1 cf	jmp $cff1	        jmp  putbyt
.d4c8	 85 6f		sta $6f		setpnt  sta  temp       ; new pntr value in a.
.d4ca	 20 93 df	jsr $df93	        jsr  getact
.d4cd	 0a		asl a		        asl  a
.d4ce	 aa		tax		        tax
.d4cf	 b5 9a		lda $9a,x	        lda  buftab+1,x
.d4d1	 85 95		sta $95		        sta  dirbuf+1
.d4d3	 a5 6f		lda $6f		        lda  temp
.d4d5	 95 99		sta $99,x	        sta  buftab,x
.d4d7	 85 94		sta $94		        sta  dirbuf
.d4d9	 60		rts		        rts
.d4da	 a9 11		lda #$11	freich  lda  #irsa
.d4dc	 85 83		sta $83		        sta  sa
.d4de	 20 27 d2	jsr $d227	        jsr  frechn
.d4e1	 a9 12		lda #$12	        lda  #iwsa
.d4e3	 85 83		sta $83		        sta  sa
.d4e5	 4c 27 d2	jmp $d227	        jmp  frechn
.d4e8	 20 93 df	jsr $df93	getpnt  jsr  getact     ; rd act buf pntr
.d4eb	 0a		asl a		gp1     asl  a
.d4ec	 aa		tax		        tax
.d4ed	 b5 9a		lda $9a,x	        lda  buftab+1,x
.d4ef	 85 95		sta $95		        sta  dirbuf+1
.d4f1	 b5 99		lda $99,x	        lda  buftab,x
.d4f3	 85 94		sta $94		        sta  dirbuf
.d4f5	 60		rts		        rts
.d4f6	 85 71		sta $71		drdbyt  sta  temp+2     ; direct rd byte
.d4f8	 20 93 df	jsr $df93	        jsr  getact     ; accm=byte# to rd
.d4fb	 aa		tax		        tax
.d4fc	 bd e0 fe	lda $fee0,x	        lda  bufind,x
.d4ff	 85 72		sta $72		        sta  temp+3
.d501	 a0 00		ldy #$00	        ldy  #0
.d503	 b1 71		lda ($71),y	        lda  (temp+2),y
.d505	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "jobssf.asm"

;******  Processing file "jobssf.asm"

.d506					setljb
.d506	 bd 5b 02	lda $025b,x	        lda  lstjob,x
.d509	 29 01		and #$01	        and  #1
.d50b	 0d 4d 02	ora $024d	        ora  cmd
.d50e					setjob
.d50e	 48		pha		        pha
.d50f	 86 f9		stx $f9		        stx  jobnum
.d511	 8a		txa		        txa
.d512	 0a		asl a		        asl  a
.d513	 aa		tax		        tax
.d514	 b5 07		lda $07,x	        lda  hdrs+1,x   ; 4/12***********
.d516	 8d 4d 02	sta $024d	        sta  cmd        ; save sector
.d519	 b5 06		lda $06,x	        lda  hdrs,x     ; 4/12***********
.d51b	 f0 2d		beq $d54a	        beq  tserr
.d51d	 cd ac 02	cmp $02ac	        cmp  maxtrk
.d520	 b0 28		bcs $d54a	        bcs  tserr      ; track too large
.d522	 aa		tax		        tax
.d523	 68		pla		        pla     	; check for write
.d524	 48		pha		        pha
.d525	 29 f0		and #$f0	        and  #$f0
.d527	 c9 90		cmp #$90	        cmp  #write
.d529	 d0 4f		bne $d57a	        bne  sjb1       ; not write,skip check
.d52b	 68		pla		        pla
.d52c	 48		pha		        pha
.d52d	 4a		lsr a		        lsr  a
.d52e	 b0 05		bcs $d535	        bcs  sjb2       ; drive 1
.d530	 ad 01 01	lda $0101	        lda  dskver     ; get version #
.d533	 90 03		bcc $d538	        bcc  sjb3
.d535					sjb2
.d535	 ad 02 01	lda $0102	        lda  dskver+1   ; get drive 1 ver#
.d538					sjb3
.d538	 f0 05		beq $d53f	        beq  sjb4       ; no # is ok, too
.d53a	 cd d5 fe	cmp $fed5	        cmp  vernum
.d53d	 d0 33		bne $d572	        bne  vnerr      ; not same vernum #
.d53f					sjb4
.d53f	 8a		txa		        txa     	; restore track #
.d540	 20 4b f2	jsr $f24b	        jsr  maxsec
.d543	 cd 4d 02	cmp $024d	        cmp  cmd
.d546	 f0 02		beq $d54a	        beq  tserr
.d548	 b0 30		bcs $d57a	        bcs  sjb1       ; sector is ok!
.d54a					tserr
.d54a	 20 52 d5	jsr $d552	        jsr  hed2ts
.d54d					tser1
.d54d	 a9 66		lda #$66	        lda  #badts
.d54f	 4c 45 e6	jmp $e645	        jmp  cmder2
.d552					hed2ts
.d552	 a5 f9		lda $f9		        lda  jobnum
.d554	 0a		asl a		        asl  a
.d555	 aa		tax		        tax
.d556	 b5 06		lda $06,x	        lda  hdrs,x     ; 4/12***********
.d558	 85 80		sta $80		        sta  track
.d55a	 b5 07		lda $07,x	        lda  hdrs+1,x   ; 4/12***********
.d55c	 85 81		sta $81		        sta  sector
.d55e	 60		rts		        rts
.d55f					tschk
.d55f	 a5 80		lda $80		        lda  track
.d561	 f0 ea		beq $d54d	        beq  tser1
.d563	 cd ac 02	cmp $02ac	        cmp  maxtrk
.d566	 b0 e5		bcs $d54d	        bcs  tser1
.d568	 20 4b f2	jsr $f24b	        jsr  maxsec
.d56b	 c5 81		cmp $81		        cmp  sector
.d56d	 f0 de		beq $d54d	        beq  tser1
.d56f	 90 dc		bcc $d54d	        bcc  tser1
.d571	 60		rts		        rts
.d572					vnerr
.d572	 20 52 d5	jsr $d552	        jsr  hed2ts
.d575	 a9 73		lda #$73	        lda  #cbmv2     ; write to wrong version
.d577	 4c 45 e6	jmp $e645	        jmp  cmder2
.d57a					sjb1
.d57a	 a6 f9		ldx $f9		        ldx  jobnum
.d57c	 68		pla		        pla
.d57d	 8d 4d 02	sta $024d	        sta  cmd
.d580	 95 00		sta $00,x	        sta  jobs,x
.d582	 9d 5b 02	sta $025b,x	        sta  lstjob,x
.d585	 60		rts		        rts
.d586					doread
.d586	 a9 80		lda #$80	        lda  #read
.d588	 d0 02		bne $d58c	        bne  dojob      ; bra
.d58a					dowrit
.d58a	 a9 90		lda #$90	        lda  #write
.d58c					dojob
.d58c	 05 7f		ora $7f		        ora  drvnum
.d58e	 a6 f9		ldx $f9		        ldx  jobnum
.d590	 8d 4d 02	sta $024d	doit    sta  cmd
.d593	 ad 4d 02	lda $024d	doit2   lda  cmd
.d596	 20 0e d5	jsr $d50e	        jsr  setjob
.d599	 20 a6 d5	jsr $d5a6	watjob  jsr  tstjob
.d59c	 b0 fb		bcs $d599	        bcs  watjob
.d59e	 48		pha		        pha     	; clr jobrtn flag
.d59f	 a9 00		lda #$00	        lda  #0
.d5a1	 8d 98 02	sta $0298	        sta  jobrtn
.d5a4	 68		pla		        pla
.d5a5	 60		rts		        rts
.d5a6	 b5 00		lda $00,x	tstjob  lda  jobs,x
.d5a8	 30 1a		bmi $d5c4	        bmi  notyet
.d5aa	 c9 02		cmp #$02	        cmp  #2
.d5ac	 90 14		bcc $d5c2	        bcc  ok
.d5ae	 c9 08		cmp #$08	        cmp  #8         ; check for wp switch on
.d5b0	 f0 08		beq $d5ba	        beq  tj10
.d5b2	 c9 0b		cmp #$0b	        cmp  #11        ; check for id mismatch
.d5b4	 f0 04		beq $d5ba	        beq  tj10
.d5b6	 c9 0f		cmp #$0f	        cmp  #$f        ; check for nodrive
.d5b8	 d0 0c		bne $d5c6	        bne  recov
.d5ba	 2c 98 02	bit $0298	tj10    bit  jobrtn
.d5bd	 30 03		bmi $d5c2	        bmi  ok
.d5bf	 4c 3f d6	jmp $d63f	        jmp  quit2
.d5c2	 18		clc		ok      clc     	; c=0 finished ok or quit
.d5c3	 60		rts		        rts
.d5c4	 38		sec		notyet  sec     	; c=1 not yet
.d5c5	 60		rts		        rts
.d5c6					recov
.d5c6	 98		tya		        tya     	; save .y
.d5c7	 48		pha		        pha
.d5c8	 a5 7f		lda $7f		        lda  drvnum     ; save drive #
.d5ca	 48		pha		        pha
.d5cb	 bd 5b 02	lda $025b,x	        lda  lstjob,x
.d5ce	 29 01		and #$01	        and  #1
.d5d0	 85 7f		sta $7f		        sta  drvnum     ; set active drive #
.d5d2	 a8		tay		        tay
.d5d3	 b9 ca fe	lda $feca,y	        lda  ledmsk,y
.d5d6	 8d 6d 02	sta $026d	        sta  erled
.d5d9	 20 a6 d6	jsr $d6a6	        jsr  dorec
.d5dc	 c9 02		cmp #$02	        cmp  #2
.d5de	 b0 03		bcs $d5e3	        bcs  rec01
.d5e0	 4c 6d d6	jmp $d66d	        jmp  rec95
.d5e3					rec01
.d5e3	 bd 5b 02	lda $025b,x	        lda  lstjob,x   ; original job
.d5e6	 29 f0		and #$f0	        and  #$f0       ; mask job code
.d5e8	 48		pha		        pha     	; save it
.d5e9	 c9 90		cmp #$90	        cmp  #write
.d5eb	 d0 07		bne $d5f4	        bne  rec0       ; not a write
.d5ed	 a5 7f		lda $7f		        lda  drvnum
.d5ef	 09 b8		ora #$b8	        ora  #secsek    ; replace w/ sector seek...
.d5f1	 9d 5b 02	sta $025b,x	        sta  lstjob,x   ; ... during recovery
.d5f4					rec0
.d5f4	 24 6a		bit $6a		        bit  revcnt
.d5f6	 70 39		bvs $d631	        bvs  rec5       ; no track offset
.d5f8	 a9 00		lda #$00	        lda  #0
.d5fa	 8d 99 02	sta $0299	        sta  eptr       ; clr offset table ptr
.d5fd	 8d 9a 02	sta $029a	        sta  toff       ; clr total offset
.d600					rec1
.d600	 ac 99 02	ldy $0299	        ldy  eptr
.d603	 ad 9a 02	lda $029a	        lda  toff
.d606	 38		sec		        sec
.d607	 f9 db fe	sbc $fedb,y	        sbc  offset,y
.d60a	 8d 9a 02	sta $029a	        sta  toff       ; keep track of all offsets
.d60d	 b9 db fe	lda $fedb,y	        lda  offset,y
.d610	 20 a1 ff	jsr $ffa1	        jsr  ptch12	; set micro-stepping flag *rom-05ds 01/21/85*
.d613	 ee 99 02	inc $0299	        inc  eptr       ; bump table ptr
.d616	 20 a6 d6	jsr $d6a6	        jsr  dorec      ; do the recovery
.d619	 c9 02		cmp #$02	        cmp  #2         ; error code < 2?
.d61b	 90 08		bcc $d625	        bcc  rec3       ; job worked
.d61d	 ac 99 02	ldy $0299	        ldy  eptr
.d620	 b9 db fe	lda $fedb,y	        lda  offset,y
.d623	 d0 db		bne $d600	        bne  rec1       ; null indicates end
.d625					rec3
.d625	 ad 9a 02	lda $029a	        lda  toff
.d628	 20 a6 ff	jsr $ffa6	        jsr  ptch13	; clr micro-stepping flag *rom-05ds 01/21/85*
.d62b	 b5 00		lda $00,x	        lda  jobs,x
.d62d	 c9 02		cmp #$02	        cmp  #2
.d62f	 90 2b		bcc $d65c	        bcc  rec9       ; no error
.d631					rec5
.d631	 24 6a		bit $6a		        bit  revcnt     ; check bump-on flag
.d633	 10 0f		bpl $d644	        bpl  rec7       ; no bump
.d635					quit
.d635	 68		pla		        pla
.d636	 c9 90		cmp #$90	        cmp  #write     ; check original job
.d638	 d0 05		bne $d63f	        bne  quit2
.d63a	 05 7f		ora $7f		        ora  drvnum
.d63c	 9d 5b 02	sta $025b,x	        sta  lstjob,x   ; must restore original
.d63f					quit2
.d63f	 b5 00		lda $00,x	        lda  jobs,x     ; .a= error #
.d641	 20 0a e6	jsr $e60a	        jsr  error
.d644					rec7
.d644	 68		pla		        pla
.d645	 2c 98 02	bit $0298	        bit  jobrtn
.d648	 30 23		bmi $d66d	        bmi  rec95      ; return job error
.d64a	 48		pha		        pha
.d64b	 a9 c0		lda #$c0	        lda  #bump
.d64d	 05 7f		ora $7f		        ora  drvnum
.d64f	 95 00		sta $00,x	        sta  jobs,x
.d651					rec8
.d651	 20 b6 9f	jsr $9fb6		jsr  stbctl	; strobe the controller
.d654	 ea		nop			nop
.d655	 20 a6 d6	jsr $d6a6	        jsr  dorec      ; try one last set
.d658	 c9 02		cmp #$02	        cmp  #2
.d65a	 b0 d9		bcs $d635	        bcs  quit       ; it clearly ain't gonna work
.d65c					rec9
.d65c	 68		pla		        pla     	; check original job for write
.d65d	 c9 90		cmp #$90	        cmp  #write
.d65f	 d0 0c		bne $d66d	        bne  rec95      ; original job worked
.d661	 05 7f		ora $7f		        ora  drvnum
.d663	 9d 5b 02	sta $025b,x	        sta  lstjob,x   ; set write job back
.d666	 20 a6 d6	jsr $d6a6	        jsr  dorec      ; try last set of writes
.d669	 c9 02		cmp #$02	        cmp  #2         ; check error code
.d66b	 b0 d2		bcs $d63f	        bcs  quit2      ; error
.d66d					rec95
.d66d	 68		pla		        pla
.d66e	 85 7f		sta $7f		        sta  drvnum     ; restore drive #
.d670	 68		pla		        pla
.d671	 a8		tay		        tay     	; restore .y
.d672	 b5 00		lda $00,x	        lda  jobs,x
.d674	 18		clc		        clc     	; ok!
.d675	 60		rts		        rts
.d676					hedoff
.d676	 c9 00		cmp #$00	        cmp  #0
.d678	 f0 18		beq $d692	        beq  hof3       ; no offset
.d67a	 30 0c		bmi $d688	        bmi  hof2       ; steps are inward
.d67c					hof1
.d67c	 a0 01		ldy #$01	        ldy  #1         ; step out 1 track
.d67e	 20 93 d6	jsr $d693	        jsr  movhed
.d681	 38		sec		        sec
.d682	 e9 01		sbc #$01	        sbc  #1
.d684	 d0 f6		bne $d67c	        bne  hof1       ; not finished
.d686	 f0 0a		beq $d692	        beq  hof3
.d688					hof2
.d688	 a0 ff		ldy #$ff	        ldy  #$ff       ; step in 1 track
.d68a	 20 93 d6	jsr $d693	        jsr  movhed
.d68d	 18		clc		        clc
.d68e	 69 01		adc #$01	        adc  #1
.d690	 d0 f6		bne $d688	        bne  hof2       ;  not finished
.d692					hof3
.d692	 60		rts		        rts
.d693					movhed
.d693	 48		pha		        pha     	; save .a
.d694	 98		tya		        tya     	; put phase in .a
.d695	 a4 7f		ldy $7f		        ldy  drvnum
.d697	 99 fe 02	sta $02fe,y	        sta  phase,y
.d69a					mh10
.d69a	 d9 fe 02	cmp $02fe,y	        cmp  phase,y
.d69d	 f0 fb		beq $d69a	        beq  mh10       ; wait for controller to change it
.d69f	 a9 00		lda #$00	        lda  #0
.d6a1	 99 fe 02	sta $02fe,y	        sta  phase,y    ; clear it out
.d6a4	 68		pla		        pla     	; restore
.d6a5	 60		rts		        rts
.d6a6					dorec
.d6a6	 a5 6a		lda $6a		        lda  revcnt     ; re-try job revcnt...
.d6a8	 29 3f		and #$3f	        and  #$3f       ; ...# of times
.d6aa	 a8		tay		        tay
.d6ab					dorec1
.d6ab	 ad 6d 02	lda $026d	        lda  erled
.d6ae	 4d 00 1c	eor $1c00	        eor  ledprt
.d6b1	 8d 00 1c	sta $1c00	        sta  ledprt
.d6b4	 bd 5b 02	lda $025b,x	        lda  lstjob,x   ; set last job
.d6b7	 95 00		sta $00,x	        sta  jobs,x
.d6b9					dorec2
.d6b9	 20 b6 9f	jsr $9fb6		jsr  stbctl	; strobe the controller *rom-05ds 01/22/85*
.d6bc	 ea		nop			nop
.d6bd	 c9 02		cmp #$02	        cmp  #2
.d6bf	 90 03		bcc $d6c4	        bcc  dorec3     ; it worked
.d6c1	 88		dey		        dey
.d6c2	 d0 e7		bne $d6ab	        bne  dorec1     ; keep trying
.d6c4					dorec3
.d6c4	 48		pha		        pha
.d6c5	 ad 6d 02	lda $026d	        lda  erled      ; leave drive led on
.d6c8	 0d 00 1c	ora $1c00	        ora  ledprt
.d6cb	 8d 00 1c	sta $1c00	        sta  ledprt
.d6ce	 68		pla		        pla
.d6cf	 60		rts		        rts     	; finished
.d6d0	 20 93 df	jsr $df93	sethdr  jsr  getact
.d6d3					seth
.d6d3	 0a		asl a		        asl  a
.d6d4	 a8		tay		        tay
.d6d5	 a5 80		lda $80		        lda  track
.d6d7	 99 06 00	sta $0006,y	        sta  hdrs,y     ; set track
.d6da	 a5 81		lda $81		        lda  sector
.d6dc	 99 07 00	sta $0007,y	        sta  hdrs+1,y   ; set sector
.d6df	 a5 7f		lda $7f		        lda  drvnum     ; get proper id(drvnum)
.d6e1	 0a		asl a		        asl  a
.d6e2	 aa		tax		        tax
.d6e3	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "addfil.asm"

;******  Processing file "addfil.asm"

.d6e4	 a5 83		lda $83		addfil  lda  sa         ; save variables
.d6e6	 48		pha		        pha
.d6e7	 a5 82		lda $82		        lda  lindx
.d6e9	 48		pha		        pha
.d6ea	 a5 81		lda $81		        lda  sector
.d6ec	 48		pha		        pha
.d6ed	 a5 80		lda $80		        lda  track
.d6ef	 48		pha		        pha
.d6f0	 a9 11		lda #$11	        lda  #irsa
.d6f2	 85 83		sta $83		        sta  sa
.d6f4	 20 3b de	jsr $de3b	        jsr  curblk     ; use last accessed search
.d6f7	 ad 4a 02	lda $024a	        lda  type
.d6fa	 48		pha		        pha
.d6fb	 a5 e2		lda $e2		        lda  fildrv
.d6fd	 29 01		and #$01	        and  #1
.d6ff	 85 7f		sta $7f		        sta  drvnum
.d701	 a6 f9		ldx $f9		        ldx  jobnum
.d703	 5d 5b 02	eor $025b,x	        eor  lstjob,x
.d706	 4a		lsr a		        lsr  a
.d707	 90 0c		bcc $d715	        bcc  af08       ; same drive as required
.d709	 a2 01		ldx #$01	        ldx  #1
.d70b	 8e 92 02	stx $0292	        stx  delind     ; look for deleted entry
.d70e	 20 ac c5	jsr $c5ac	        jsr  srchst
.d711	 f0 1d		beq $d730	        beq  af15       ; all full, new sector
.d713	 d0 28		bne $d73d	        bne  af20       ; found one
.d715	 ad 91 02	lda $0291	af08    lda  delsec
.d718	 f0 0c		beq $d726	        beq  af10       ; deleted entry not located
.d71a	 c5 81		cmp $81		        cmp  sector
.d71c	 f0 1f		beq $d73d	        beq  af20       ; sector is resident
.d71e	 85 81		sta $81		        sta  sector
.d720	 20 60 d4	jsr $d460	        jsr  drtrd      ; read sector in
.d723	 4c 3d d7	jmp $d73d	        jmp  af20
.d726	 a9 01		lda #$01	af10    lda  #1         ; find deleted entry
.d728	 8d 92 02	sta $0292	        sta  delind
.d72b	 20 17 c6	jsr $c617	        jsr  search
.d72e	 d0 0d		bne $d73d	        bne  af20
.d730	 20 8d d4	jsr $d48d	af15    jsr  nxdrbk     ; all full, new sector
.d733	 a5 81		lda $81		        lda  sector
.d735	 8d 91 02	sta $0291	        sta  delsec
.d738	 a9 02		lda #$02	        lda  #2
.d73a	 8d 92 02	sta $0292	        sta  delind
.d73d	 ad 92 02	lda $0292	af20    lda  delind
.d740	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.d743	 68		pla		        pla
.d744	 8d 4a 02	sta $024a	        sta  type       ; set type
.d747	 c9 04		cmp #$04	        cmp  #reltyp
.d749	 d0 02		bne $d74d	        bne  af25
.d74b	 09 80		ora #$80	        ora  #$80
.d74d					af25
.d74d	 20 f1 cf	jsr $cff1	        jsr  putbyt
.d750	 68		pla		        pla
.d751	 8d 80 02	sta $0280	        sta  filtrk     ; ...table & entry
.d754	 20 f1 cf	jsr $cff1	        jsr  putbyt
.d757	 68		pla		        pla
.d758	 8d 85 02	sta $0285	        sta  filsec     ; set sector link in...
.d75b	 20 f1 cf	jsr $cff1	        jsr  putbyt     ; ...table & entry
.d75e	 20 93 df	jsr $df93	        jsr  getact
.d761	 a8		tay		        tay
.d762	 ad 7a 02	lda $027a	        lda  filtbl
.d765	 aa		tax		        tax
.d766	 a9 10		lda #$10	        lda  #16
.d768	 20 6e c6	jsr $c66e	        jsr  trname     ; transfer name
.d76b	 a0 10		ldy #$10	        ldy  #16
.d76d	 a9 00		lda #$00	        lda  #0         ; clear # of blocks &...
.d76f	 91 94		sta ($94),y	af30    sta  (dirbuf),y ; ...& replace links
.d771	 c8		iny		        iny
.d772	 c0 1b		cpy #$1b	        cpy  #27
.d774	 90 f9		bcc $d76f	        bcc  af30
.d776	 ad 4a 02	lda $024a	        lda  type       ; a relative file ?
.d779	 c9 04		cmp #$04	        cmp  #reltyp
.d77b	 d0 13		bne $d790	        bne  af50       ; no
.d77d	 a0 10		ldy #$10	        ldy  #16        ; yes
.d77f	 ad 59 02	lda $0259	        lda  trkss      ; get ss track
.d782	 91 94		sta ($94),y	        sta  (dirbuf),y ; put in directory
.d784	 c8		iny		        iny
.d785	 ad 5a 02	lda $025a	        lda  secss      ; get ss sector
.d788	 91 94		sta ($94),y	        sta  (dirbuf),y ; put in
.d78a	 c8		iny		        iny
.d78b	 ad 58 02	lda $0258	        lda  rec        ; get record size
.d78e	 91 94		sta ($94),y	        sta  (dirbuf),y
.d790	 20 64 d4	jsr $d464	af50    jsr  drtwrt     ; write it out
.d793	 68		pla		        pla
.d794	 85 82		sta $82		        sta  lindx
.d796	 aa		tax		        tax
.d797	 68		pla		        pla
.d798	 85 83		sta $83		        sta  sa
.d79a	 ad 91 02	lda $0291	        lda  delsec
.d79d	 85 d8		sta $d8		        sta  entsec
.d79f	 9d 60 02	sta $0260,x	        sta  dsec,x
.d7a2	 ad 92 02	lda $0292	        lda  delind
.d7a5	 85 dd		sta $dd		        sta  entind
.d7a7	 9d 66 02	sta $0266,x	        sta  dind,x
.d7aa	 ad 4a 02	lda $024a	        lda  type
.d7ad	 85 e7		sta $e7		        sta  pattyp
.d7af	 a5 7f		lda $7f		        lda  drvnum
.d7b1	 85 e2		sta $e2		        sta  fildrv
.d7b3	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "open.asm"

;******  Processing file "open.asm"

.d7b4					open
.d7b4	 a5 83		lda $83		        lda  sa
.d7b6	 8d 4c 02	sta $024c	        sta  tempsa
.d7b9	 20 b3 c2	jsr $c2b3	        jsr  cmdset     ; initiate cmd ptrs
.d7bc	 8e 2a 02	stx $022a	        stx  cmdnum
.d7bf	 ae 00 02	ldx $0200	        ldx  cmdbuf
.d7c2	 ad 4c 02	lda $024c	        lda  tempsa
.d7c5	 d0 2c		bne $d7f3	        bne  op021
.d7c7	 e0 2a		cpx #$2a	        cpx  #'*'       ; load last?
.d7c9	 d0 28		bne $d7f3	        bne  op021
.d7cb	 a5 7e		lda $7e		        lda  prgtrk
.d7cd	 f0 4d		beq $d81c	        beq  op0415     ; no last prog, init 0
.d7cf					op02
.d7cf	 85 80		sta $80		        sta  track
.d7d1	 ad 6e 02	lda $026e	        lda  prgdrv
.d7d4	 85 7f		sta $7f		        sta  drvnum
.d7d6	 85 e2		sta $e2		        sta  fildrv
.d7d8	 a9 02		lda #$02	        lda  #prgtyp
.d7da	 85 e7		sta $e7		        sta  pattyp
.d7dc	 ad 6f 02	lda $026f	        lda  prgsec
.d7df	 85 81		sta $81		        sta  sector
.d7e1	 20 00 c1	jsr $c100	        jsr  setlds     ;  make sure led gets turned on!!
.d7e4	 20 46 dc	jsr $dc46	        jsr  opnrch
.d7e7	 a9 04		lda #$04	        lda  #prgtyp+prgtyp
.d7e9	 05 7f		ora $7f		        ora  drvnum
.d7eb	 a6 82		ldx $82		endrd   ldx  lindx
.d7ed	 99 ec 00	sta $00ec,y	        sta  filtyp,y
.d7f0	 4c 94 c1	jmp $c194	        jmp  endcmd
.d7f3	 e0 24		cpx #$24	op021   cpx  #'$'
.d7f5	 d0 1e		bne $d815	        bne  op041
.d7f7	 ad 4c 02	lda $024c	        lda  tempsa     ; load directory
.d7fa	 d0 03		bne $d7ff	        bne  op04
.d7fc	 4c 55 da	jmp $da55	        jmp  loadir
.d7ff	 20 d1 c1	jsr $c1d1	op04    jsr  simprs     ; open dir as seq file
.d802	 ad 85 fe	lda $fe85	        lda  dirtrk
.d805	 85 80		sta $80		        sta  track
.d807	 a9 00		lda #$00	        lda  #0
.d809	 85 81		sta $81		        sta  sector
.d80b	 20 46 dc	jsr $dc46	        jsr  opnrch
.d80e	 a5 7f		lda $7f		        lda  drvnum
.d810	 09 02		ora #$02	        ora  #seqtyp+seqtyp
.d812	 4c eb d7	jmp $d7eb	        jmp  endrd
.d815	 e0 23		cpx #$23	op041   cpx  #'#'       ; "#" is direct access
.d817	 d0 12		bne $d82b	        bne  op042
.d819	 4c 84 cb	jmp $cb84	        jmp  opnblk
.d81c	 a9 02		lda #$02	op0415  lda  #prgtyp    ; program type
.d81e	 8d 96 02	sta $0296	        sta  typflg
.d821	 a9 00		lda #$00	        lda  #0
.d823	 85 7f		sta $7f		        sta  drvnum
.d825	 8d 8e 02	sta $028e	        sta  lstdrv
.d828	 20 42 d0	jsr $d042	        jsr  initdr
.d82b					op042
.d82b	 20 e5 c1	jsr $c1e5	        jsr  prscln     ; look for ":"
.d82e	 d0 04		bne $d834	        bne  op049
.d830	 a2 00		ldx #$00	        ldx  #0
.d832	 f0 0c		beq $d840	        beq  op20       ; bra
.d834					op049
.d834	 8a		txa		        txa
.d835	 f0 05		beq $d83c	        beq  op10
.d837	 a9 30		lda #$30	op05    lda  #badsyn    ; something amiss
.d839	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.d83c	 88		dey		op10    dey     	; back up to ":"
.d83d	 f0 01		beq $d840	        beq  op20       ; 1st char is ":"
.d83f	 88		dey		        dey
.d840	 8c 7a 02	sty $027a	op20    sty  filtbl     ; save filename ptr
.d843	 a9 8d		lda #$8d	        lda  #$8d       ; look for cr-shifted
.d845	 20 68 c2	jsr $c268	        jsr  parse
.d848	 e8		inx		        inx
.d849	 8e 78 02	stx $0278	        stx  f2cnt
.d84c	 20 12 c3	jsr $c312	        jsr  onedrv
.d84f	 20 ca c3	jsr $c3ca	        jsr  optsch
.d852	 20 9d c4	jsr $c49d	        jsr  ffst       ; look for file entry
.d855	 a2 00		ldx #$00	        ldx  #0
.d857	 8e 58 02	stx $0258	        stx  rec
.d85a	 8e 97 02	stx $0297	        stx  mode       ; read mode
.d85d	 8e 4a 02	stx $024a	        stx  type       ; deleted
.d860	 e8		inx		        inx
.d861	 ec 77 02	cpx $0277	        cpx  f1cnt
.d864	 b0 10		bcs $d876	        bcs  op40       ; no parameters
.d866	 20 09 da	jsr $da09	        jsr  cktm       ; check for type & mode
.d869	 e8		inx		        inx
.d86a	 ec 77 02	cpx $0277	        cpx  f1cnt
.d86d	 b0 07		bcs $d876	        bcs  op40       ; only one parameter
.d86f	 c0 04		cpy #$04	        cpy  #reltyp
.d871	 f0 3e		beq $d8b1	        beq  op60       ; set record size
.d873	 20 09 da	jsr $da09	        jsr  cktm       ; set type/mode
.d876					op40
.d876	 ae 4c 02	ldx $024c	        ldx  tempsa
.d879	 86 83		stx $83		        stx  sa         ; set sa back
.d87b	 e0 02		cpx #$02	        cpx  #2
.d87d	 b0 12		bcs $d891	        bcs  op45       ; not load or save
.d87f	 8e 97 02	stx $0297	        stx  mode       ; mode=sa
.d882	 a9 40		lda #$40	        lda  #$40
.d884	 8d f9 02	sta $02f9	        sta  wbam
.d887	 ad 4a 02	lda $024a	        lda  type
.d88a	 d0 1b		bne $d8a7	        bne  op50       ; type from parm
.d88c	 a9 02		lda #$02	        lda  #prgtyp
.d88e	 8d 4a 02	sta $024a	        sta  type       ; use prg
.d891					op45
.d891	 ad 4a 02	lda $024a	        lda  type
.d894	 d0 11		bne $d8a7	        bne  op50       ; type from parm
.d896	 a5 e7		lda $e7		        lda  pattyp
.d898	 29 07		and #$07	        and  #typmsk
.d89a	 8d 4a 02	sta $024a	        sta  type       ; type from file
.d89d	 ad 80 02	lda $0280	        lda  filtrk
.d8a0	 d0 05		bne $d8a7	        bne  op50       ; yes, it exists
.d8a2	 a9 01		lda #$01	        lda  #seqtyp
.d8a4	 8d 4a 02	sta $024a	        sta  type       ; default is seq
.d8a7					op50
.d8a7	 ad 97 02	lda $0297	        lda  mode
.d8aa	 c9 01		cmp #$01	        cmp  #wtmode
.d8ac	 f0 18		beq $d8c6	        beq  op75       ; go write
.d8ae	 4c 40 d9	jmp $d940	        jmp  op90
.d8b1					op60
.d8b1	 bc 7a 02	ldy $027a,x	        ldy  filtbl,x   ; get record size
.d8b4	 b9 00 02	lda $0200,y	        lda  cmdbuf,y
.d8b7	 8d 58 02	sta $0258	        sta  rec
.d8ba	 ad 80 02	lda $0280	        lda  filtrk
.d8bd	 d0 b7		bne $d876	        bne  op40       ; it's here, read
.d8bf	 a9 01		lda #$01	        lda  #wtmode    ; use write to open
.d8c1	 8d 97 02	sta $0297	        sta  mode
.d8c4	 d0 b0		bne $d876	        bne  op40       ; (bra)
.d8c6					op75
.d8c6	 a5 e7		lda $e7		        lda  pattyp
.d8c8	 29 80		and #$80	        and  #$80
.d8ca	 aa		tax		        tax
.d8cb	 d0 14		bne $d8e1	        bne  op81
.d8cd	 a9 20		lda #$20	op77    lda  #$20       ; open write
.d8cf	 24 e7		bit $e7		        bit  pattyp
.d8d1	 f0 06		beq $d8d9	        beq  op80
.d8d3	 20 b6 c8	jsr $c8b6	        jsr  deldir     ; created
.d8d6	 4c e3 d9	jmp $d9e3	        jmp  opwrit
.d8d9	 ad 80 02	lda $0280	op80    lda  filtrk
.d8dc	 d0 03		bne $d8e1	        bne  op81
.d8de	 4c e3 d9	jmp $d9e3	        jmp  opwrit     ; not found, ok!
.d8e1	 ad 00 02	lda $0200	op81    lda  cmdbuf
.d8e4	 c9 40		cmp #$40	        cmp  #'@'       ; check for replace
.d8e6	 f0 0d		beq $d8f5	        beq  op82
.d8e8	 8a		txa		        txa
.d8e9	 d0 05		bne $d8f0	        bne  op815
.d8eb	 a9 63		lda #$63	        lda  #flexst
.d8ed	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.d8f0					op815
.d8f0	 a9 33		lda #$33	        lda  #badfn
.d8f2	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.d8f5					op82
.d8f5	 a5 e7		lda $e7		        lda  pattyp     ; replace
.d8f7	 29 07		and #$07	        and  #typmsk
.d8f9	 cd 4a 02	cmp $024a	        cmp  type
.d8fc	 d0 67		bne $d965	        bne  op115
.d8fe	 c9 04		cmp #$04	        cmp  #reltyp
.d900	 f0 63		beq $d965	        beq  op115
.d902	 20 da dc	jsr $dcda	        jsr  opnwch
.d905	 a5 82		lda $82		        lda  lindx
.d907	 8d 70 02	sta $0270	        sta  wlindx
.d90a	 a9 11		lda #$11	        lda  #irsa      ; internal chan
.d90c	 85 83		sta $83		        sta  sa
.d90e	 20 eb d0	jsr $d0eb	        jsr  fndrch
.d911	 ad 94 02	lda $0294	        lda  index
.d914	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.d917	 a0 00		ldy #$00	        ldy  #0
.d919	 b1 94		lda ($94),y	        lda  (dirbuf),y
.d91b	 09 20		ora #$20	        ora  #$20       ; set replace bit
.d91d	 91 94		sta ($94),y	        sta  (dirbuf),y
.d91f	 a0 1a		ldy #$1a	        ldy  #26
.d921	 a5 80		lda $80		        lda  track
.d923	 91 94		sta ($94),y	        sta  (dirbuf),y
.d925	 c8		iny		        iny
.d926	 a5 81		lda $81		        lda  sector
.d928	 91 94		sta ($94),y	        sta  (dirbuf),y
.d92a	 ae 70 02	ldx $0270	        ldx  wlindx
.d92d	 a5 d8		lda $d8		        lda  entsec
.d92f	 9d 60 02	sta $0260,x	        sta  dsec,x
.d932	 a5 dd		lda $dd		        lda  entind
.d934	 9d 66 02	sta $0266,x	        sta  dind,x
.d937	 20 3b de	jsr $de3b	        jsr  curblk
.d93a	 20 64 d4	jsr $d464	        jsr  drtwrt
.d93d	 4c ef d9	jmp $d9ef	        jmp  opfin
.d940	 ad 80 02	lda $0280	op90    lda  filtrk     ; open read (& load)
.d943	 d0 05		bne $d94a	        bne  op100
.d945					op95
.d945	 a9 62		lda #$62	        lda  #flntfd    ; track not recorded
.d947	 4c c8 c1	jmp $c1c8	        jmp  cmderr     ; not found
.d94a					op100
.d94a	 ad 97 02	lda $0297	        lda  mode
.d94d	 c9 03		cmp #$03	        cmp  #mdmode
.d94f	 f0 0b		beq $d95c	        beq  op110
.d951	 a9 20		lda #$20	        lda  #$20
.d953	 24 e7		bit $e7		        bit  pattyp
.d955	 f0 05		beq $d95c	        beq  op110
.d957	 a9 60		lda #$60	        lda  #filopn
.d959	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.d95c	 a5 e7		lda $e7		op110   lda  pattyp
.d95e	 29 07		and #$07	        and  #typmsk    ; type is in index table
.d960	 cd 4a 02	cmp $024a	        cmp  type
.d963	 f0 05		beq $d96a	        beq  op120
.d965	 a9 64		lda #$64	op115   lda  #mistyp    ; type mismatch
.d967	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.d96a					op120
.d96a	 a0 00		ldy #$00	        ldy  #0
.d96c	 8c 79 02	sty $0279	        sty  f2ptr
.d96f	 ae 97 02	ldx $0297	        ldx  mode
.d972	 e0 02		cpx #$02	        cpx  #apmode
.d974	 d0 1a		bne $d990	        bne  op125
.d976	 c9 04		cmp #$04	        cmp  #reltyp
.d978	 f0 eb		beq $d965	        beq  op115
.d97a	 b1 94		lda ($94),y	        lda  (dirbuf),y
.d97c	 29 4f		and #$4f	        and  #$4f
.d97e	 91 94		sta ($94),y	        sta  (dirbuf),y
.d980	 a5 83		lda $83		        lda  sa
.d982	 48		pha		        pha
.d983	 a9 11		lda #$11	        lda  #irsa
.d985	 85 83		sta $83		        sta  sa
.d987	 20 3b de	jsr $de3b	        jsr  curblk
.d98a	 20 64 d4	jsr $d464	        jsr  drtwrt
.d98d	 68		pla		        pla
.d98e	 85 83		sta $83		        sta  sa
.d990					op125
.d990	 20 a0 d9	jsr $d9a0	        jsr  opread
.d993	 ad 97 02	lda $0297	        lda  mode
.d996	 c9 02		cmp #$02	        cmp  #apmode
.d998	 d0 55		bne $d9ef	        bne  opfin
.d99a	 20 2a da	jsr $da2a	        jsr  append
.d99d	 4c 94 c1	jmp $c194	        jmp  endcmd
.d9a0					opread
.d9a0	 a0 13		ldy #$13	        ldy  #19
.d9a2	 b1 94		lda ($94),y	        lda  (dirbuf),y
.d9a4	 8d 59 02	sta $0259	        sta  trkss
.d9a7	 c8		iny		        iny
.d9a8	 b1 94		lda ($94),y	        lda  (dirbuf),y
.d9aa	 8d 5a 02	sta $025a	        sta  secss
.d9ad	 c8		iny		        iny
.d9ae	 b1 94		lda ($94),y	        lda  (dirbuf),y
.d9b0	 ae 58 02	ldx $0258	        ldx  rec
.d9b3	 8d 58 02	sta $0258	        sta  rec
.d9b6	 8a		txa		        txa
.d9b7	 f0 0a		beq $d9c3	        beq  op130
.d9b9	 cd 58 02	cmp $0258	        cmp  rec
.d9bc	 f0 05		beq $d9c3	        beq  op130
.d9be	 a9 50		lda #$50	        lda  #norec
.d9c0	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.d9c3					op130
.d9c3	 ae 79 02	ldx $0279	        ldx  f2ptr
.d9c6	 bd 80 02	lda $0280,x	        lda  filtrk,x
.d9c9	 85 80		sta $80		        sta  track
.d9cb	 bd 85 02	lda $0285,x	        lda  filsec,x
.d9ce	 85 81		sta $81		        sta  sector
.d9d0	 20 46 dc	jsr $dc46	        jsr  opnrch
.d9d3	 a4 82		ldy $82		        ldy  lindx      ; open a read chnl
.d9d5	 ae 79 02	ldx $0279	        ldx  f2ptr
.d9d8	 b5 d8		lda $d8,x	        lda  entsec,x
.d9da	 99 60 02	sta $0260,y	        sta  dsec,y
.d9dd	 b5 dd		lda $dd,x	        lda  entind,x
.d9df	 99 66 02	sta $0266,y	        sta  dind,y
.d9e2	 60		rts		        rts
.d9e3					opwrit
.d9e3	 a5 e2		lda $e2		        lda  fildrv
.d9e5	 29 01		and #$01	        and  #1
.d9e7	 85 7f		sta $7f		        sta  drvnum
.d9e9	 20 da dc	jsr $dcda	        jsr  opnwch
.d9ec	 20 e4 d6	jsr $d6e4	        jsr  addfil     ; add to directory
.d9ef					opfin
.d9ef	 a5 83		lda $83		        lda  sa
.d9f1	 c9 02		cmp #$02	        cmp  #2
.d9f3	 b0 11		bcs $da06	        bcs  opf1
.d9f5	 20 3e de	jsr $de3e	        jsr  gethdr
.d9f8	 a5 80		lda $80		        lda  track
.d9fa	 85 7e		sta $7e		        sta  prgtrk
.d9fc	 a5 7f		lda $7f		        lda  drvnum
.d9fe	 8d 6e 02	sta $026e	        sta  prgdrv
.da01	 a5 81		lda $81		        lda  sector
.da03	 8d 6f 02	sta $026f	        sta  prgsec
.da06					opf1
.da06	 4c 99 c1	jmp $c199	        jmp  endsav
.da09					cktm
.da09	 bc 7a 02	ldy $027a,x	        ldy  filtbl,x   ; get ptr
.da0c	 b9 00 02	lda $0200,y	        lda  cmdbuf,y   ; get char
.da0f	 a0 04		ldy #$04	        ldy  #nmodes
.da11					ckm1
.da11	 88		dey		        dey
.da12	 30 08		bmi $da1c	        bmi  ckm2       ; no valid mode
.da14	 d9 b2 fe	cmp $feb2,y	        cmp  modlst,y
.da17	 d0 f8		bne $da11	        bne  ckm1
.da19	 8c 97 02	sty $0297	        sty  mode       ; mode found
.da1c					ckm2
.da1c	 a0 05		ldy #$05	        ldy  #ntypes
.da1e					ckt1
.da1e	 88		dey		        dey
.da1f	 30 08		bmi $da29	        bmi  ckt2       ; no valid type
.da21	 d9 b6 fe	cmp $feb6,y	        cmp  tplst,y
.da24	 d0 f8		bne $da1e	        bne  ckt1
.da26	 8c 4a 02	sty $024a	        sty  type       ; type found
.da29					ckt2
.da29	 60		rts		        rts
.da2a					append
.da2a	 20 39 ca	jsr $ca39	        jsr  gcbyte
.da2d	 a9 80		lda #$80	        lda  #lrf
.da2f	 20 a6 dd	jsr $dda6	        jsr  tstflg
.da32	 f0 f6		beq $da2a	        beq  append
.da34	 20 95 de	jsr $de95	        jsr  rdlnk
.da37	 a6 81		ldx $81		        ldx  sector
.da39	 e8		inx		        inx
.da3a	 8a		txa		        txa
.da3b	 d0 05		bne $da42	        bne  ap30
.da3d	 20 a3 d1	jsr $d1a3	        jsr  wrt0       ; get another block
.da40	 a9 02		lda #$02	        lda  #2
.da42					ap30
.da42	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.da45	 a6 82		ldx $82		        ldx  lindx
.da47	 a9 01		lda #$01	        lda  #rdylst
.da49	 95 f2		sta $f2,x	        sta  chnrdy,x
.da4b	 a9 80		lda #$80	        lda  #$80       ; chnl bit
.da4d	 05 82		ora $82		        ora  lindx
.da4f	 a6 83		ldx $83		        ldx  sa
.da51	 9d 2b 02	sta $022b,x	        sta  lintab,x
.da54	 60		rts		        rts
.da55					loadir
.da55	 a9 0c		lda #$0c	        lda  #ldcmd
.da57	 8d 2a 02	sta $022a	        sta  cmdnum
.da5a	 a9 00		lda #$00	        lda  #0         ; load only drive zero
.da5c	 ae 74 02	ldx $0274	        ldx  cmdsiz
.da5f	 ca		dex		        dex
.da60	 f0 0b		beq $da6d	        beq  ld02
.da62	 ca		dex		ld01    dex     	; load by name
.da63	 d0 21		bne $da86	        bne  ld03
.da65	 ad 01 02	lda $0201	        lda  cmdbuf+1
.da68	 20 bd c3	jsr $c3bd	        jsr  tst0v1
.da6b	 30 19		bmi $da86	        bmi  ld03
.da6d					ld02
.da6d	 85 e2		sta $e2		        sta  fildrv
.da6f	 ee 77 02	inc $0277	        inc  f1cnt
.da72	 ee 78 02	inc $0278	        inc  f2cnt
.da75	 ee 7a 02	inc $027a	        inc  filtbl
.da78	 a9 80		lda #$80	        lda  #$80
.da7a	 85 e7		sta $e7		        sta  pattyp
.da7c	 a9 2a		lda #$2a	        lda  #'*'
.da7e	 8d 00 02	sta $0200	        sta  cmdbuf     ; cover both cases
.da81	 8d 01 02	sta $0201	        sta  cmdbuf+1
.da84	 d0 18		bne $da9e	        bne  ld10       ; (branch)
.da86					ld03
.da86	 20 e5 c1	jsr $c1e5	        jsr  prscln
.da89	 d0 05		bne $da90	        bne  ld05       ; found ":"
.da8b	 20 dc c2	jsr $c2dc	        jsr  cmdrst
.da8e	 a0 03		ldy #$03	        ldy  #3
.da90	 88		dey		ld05    dey
.da91	 88		dey		        dey
.da92	 8c 7a 02	sty $027a	        sty  filtbl
.da95	 20 00 c2	jsr $c200	        jsr  tc35       ; parse & set tables
.da98	 20 98 c3	jsr $c398	        jsr  fs1set
.da9b	 20 20 c3	jsr $c320	        jsr  alldrs
.da9e	 20 ca c3	jsr $c3ca	ld10    jsr  optsch     ; new directory
.daa1	 20 b7 c7	jsr $c7b7	        jsr  newdir
.daa4	 20 9d c4	jsr $c49d	        jsr  ffst
.daa7	 20 9e ec	jsr $ec9e	ld20    jsr  stdir      ; start directory
.daaa	 20 37 d1	jsr $d137	        jsr  getbyt     ; set 1st byte
.daad	 a6 82		ldx $82		        ldx  lindx
.daaf	 9d 3e 02	sta $023e,x	        sta  chndat,x
.dab2	 a5 7f		lda $7f		        lda  drvnum
.dab4	 8d 8e 02	sta $028e	        sta  lstdrv
.dab7	 09 04		ora #$04	        ora  #4
.dab9	 95 ec		sta $ec,x	        sta  filtyp,x
.dabb	 a9 00		lda #$00	        lda  #0
.dabd	 85 a3		sta $a3		        sta  buftab+cbptr
.dabf	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "close.asm"

;******  Processing file "close.asm"

.dac0					close
.dac0	 a9 00		lda #$00	        lda  #0
.dac2	 8d f9 02	sta $02f9	        sta  wbam
.dac5	 a5 83		lda $83		        lda  sa
.dac7	 d0 0b		bne $dad4	        bne  cls10      ; directory close
.dac9	 a9 00		lda #$00	        lda  #0
.dacb	 8d 54 02	sta $0254	        sta  dirlst     ; clear dir list
.dace	 20 27 d2	jsr $d227	        jsr  frechn
.dad1					cls05
.dad1	 4c da d4	jmp $d4da	        jmp  freich
.dad4					cls10
.dad4	 c9 0f		cmp #$0f	        cmp  #$f
.dad6	 f0 14		beq $daec	        beq  clsall     ; close cmd chanl
.dad8	 20 02 db	jsr $db02	        jsr  clschn     ; close channel
.dadb	 a5 83		lda $83		        lda  sa
.dadd	 c9 02		cmp #$02	        cmp  #2
.dadf	 90 f0		bcc $dad1	        bcc  cls05
.dae1	 ad 6c 02	lda $026c	        lda  erword
.dae4	 d0 03		bne $dae9	        bne  cls15      ; last command had an error
.dae6	 4c 94 c1	jmp $c194	        jmp  endcmd
.dae9					cls15
.dae9	 4c ad c1	jmp $c1ad	        jmp  scren1
.daec					clsall
.daec	 a9 0e		lda #$0e	        lda  #14
.daee	 85 83		sta $83		        sta  sa
.daf0					cls20
.daf0	 20 02 db	jsr $db02	        jsr  clschn
.daf3	 c6 83		dec $83		        dec  sa
.daf5	 10 f9		bpl $daf0	        bpl  cls20
.daf7	 ad 6c 02	lda $026c	        lda  erword
.dafa	 d0 03		bne $daff	        bne  cls25      ;  last command had an error
.dafc	 4c 94 c1	jmp $c194	        jmp  endcmd
.daff					cls25
.daff	 4c ad c1	jmp $c1ad	        jmp  scren1
.db02					clschn
.db02	 a6 83		ldx $83		        ldx  sa
.db04	 bd 2b 02	lda $022b,x	        lda  lintab,x
.db07	 c9 ff		cmp #$ff	        cmp  #$ff
.db09	 d0 01		bne $db0c	        bne  clsc28
.db0b	 60		rts		        rts
.db0c					clsc28
.db0c	 29 0f		and #$0f	        and  #$f
.db0e	 85 82		sta $82		        sta  lindx
.db10	 20 25 d1	jsr $d125	        jsr  typfil
.db13	 c9 07		cmp #$07	        cmp  #dirtyp
.db15	 f0 0f		beq $db26	        beq  clsc30     ; direct channel
.db17	 c9 04		cmp #$04	        cmp  #reltyp
.db19	 f0 11		beq $db2c	        beq  clsrel
.db1b	 20 07 d1	jsr $d107	        jsr  fndwch     ; look for write channel
.db1e	 b0 09		bcs $db29	        bcs  clsc31
.db20	 20 62 db	jsr $db62	        jsr  clswrt     ; close seq write
.db23	 20 a5 db	jsr $dba5	        jsr  clsdir     ; close directory
.db26					clsc30
.db26	 20 f4 ee	jsr $eef4	        jsr  mapout     ; write bam
.db29					clsc31
.db29	 4c 27 d2	jmp $d227	        jmp  frechn
.db2c					clsrel
.db2c	 20 f1 dd	jsr $ddf1	        jsr  scrub
.db2f	 20 1e cf	jsr $cf1e	        jsr  dblbuf
.db32	 20 cb e1	jsr $e1cb	        jsr  ssend
.db35	 a6 d5		ldx $d5		        ldx  ssnum
.db37	 86 73		stx $73		        stx  t4
.db39	 e6 73		inc $73		        inc  t4
.db3b	 a9 00		lda #$00	        lda  #0
.db3d	 85 70		sta $70		        sta  t1
.db3f	 85 71		sta $71		        sta  t2
.db41	 a5 d6		lda $d6		        lda  ssind
.db43	 38		sec		        sec
.db44	 e9 0e		sbc #$0e	        sbc  #ssioff-2
.db46	 85 72		sta $72		        sta  t3
.db48	 20 51 df	jsr $df51	        jsr  sscalc
.db4b	 a6 82		ldx $82		        ldx  lindx
.db4d	 a5 70		lda $70		        lda  t1
.db4f	 95 b5		sta $b5,x	        sta  nbkl,x
.db51	 a5 71		lda $71		        lda  t2
.db53	 95 bb		sta $bb,x	        sta  nbkh,x
.db55	 a9 40		lda #$40	        lda  #dyfile
.db57	 20 a6 dd	jsr $dda6	        jsr  tstflg
.db5a	 f0 03		beq $db5f	        beq  clsr1
.db5c	 20 a5 db	jsr $dba5	        jsr  clsdir
.db5f	 4c 27 d2	jmp $d227	clsr1   jmp  frechn
.db62					clswrt
.db62	 a6 82		ldx $82		        ldx  lindx
.db64	 b5 b5		lda $b5,x	        lda  nbkl,x
.db66	 15 bb		ora $bb,x	        ora  nbkh,x
.db68	 d0 0c		bne $db76	        bne  clsw10     ; at least 1 block written
.db6a	 20 e8 d4	jsr $d4e8	        jsr  getpnt
.db6d	 c9 02		cmp #$02	        cmp  #2
.db6f	 d0 05		bne $db76	        bne  clsw10     ; at least 1 byte written
.db71	 a9 0d		lda #$0d	        lda  #cr
.db73	 20 f1 cf	jsr $cff1	        jsr  putbyt
.db76					clsw10
.db76	 20 e8 d4	jsr $d4e8	        jsr  getpnt
.db79	 c9 02		cmp #$02	        cmp  #2
.db7b	 d0 0f		bne $db8c	        bne  clsw20     ; not mt buffer
.db7d	 20 1e cf	jsr $cf1e	        jsr  dblbuf     ; switch bufs
.db80	 a6 82		ldx $82		        ldx  lindx
.db82	 b5 b5		lda $b5,x	        lda  nbkl,x
.db84	 d0 02		bne $db88	        bne  clsw15
.db86	 d6 bb		dec $bb,x	        dec  nbkh,x
.db88					clsw15
.db88	 d6 b5		dec $b5,x	        dec  nbkl,x
.db8a	 a9 00		lda #$00	        lda  #0
.db8c					clsw20
.db8c	 38		sec		        sec
.db8d	 e9 01		sbc #$01	        sbc  #1         ; back up 1
.db8f	 48		pha		        pha     	; save it
.db90	 a9 00		lda #$00	        lda  #0
.db92	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.db95	 20 f1 cf	jsr $cff1	        jsr  putbyt     ; tlink=0
.db98	 68		pla		        pla     	; lstchr count
.db99	 20 f1 cf	jsr $cff1	        jsr  putbyt
.db9c	 20 c7 d0	jsr $d0c7	        jsr  wrtbuf     ; write out last buffer
.db9f	 20 99 d5	jsr $d599	        jsr  watjob     ; finish job up
.dba2	 4c 1e cf	jmp $cf1e	        jmp  dblbuf     ; make sure both bufs ok
.dba5	 a6 82		ldx $82		clsdir  ldx  lindx      ; save lindx
.dba7	 8e 70 02	stx $0270	        stx  wlindx     ; &sa
.dbaa	 a5 83		lda $83		        lda  sa
.dbac	 48		pha		        pha
.dbad	 bd 60 02	lda $0260,x	        lda  dsec,x     ; get directory sector
.dbb0	 85 81		sta $81		        sta  sector
.dbb2	 bd 66 02	lda $0266,x	        lda  dind,x     ; get sector offset
.dbb5	 8d 94 02	sta $0294	        sta  index
.dbb8	 b5 ec		lda $ec,x	        lda  filtyp,x   ; drv # in filtyp
.dbba	 29 01		and #$01	        and  #1
.dbbc	 85 7f		sta $7f		        sta  drvnum
.dbbe	 ad 85 fe	lda $fe85	        lda  dirtrk
.dbc1	 85 80		sta $80		        sta  track
.dbc3	 20 93 df	jsr $df93	        jsr  getact     ; allocate a buffer
.dbc6	 48		pha		        pha
.dbc7	 85 f9		sta $f9		        sta  jobnum
.dbc9	 20 60 d4	jsr $d460	        jsr  drtrd      ; read directory sector
.dbcc	 a0 00		ldy #$00	        ldy  #0
.dbce	 bd e0 fe	lda $fee0,x	        lda  bufind,x   ; .x is job#
.dbd1	 85 87		sta $87		        sta  r0+1
.dbd3	 ad 94 02	lda $0294	        lda  index
.dbd6	 85 86		sta $86		        sta  r0
.dbd8	 b1 86		lda ($86),y	        lda  (r0),y
.dbda	 29 20		and #$20	        and  #$20
.dbdc	 f0 43		beq $dc21	        beq  clsd5
.dbde	 20 25 d1	jsr $d125	        jsr  typfil
.dbe1	 c9 04		cmp #$04	        cmp  #reltyp
.dbe3	 f0 44		beq $dc29	        beq  clsd6
.dbe5	 b1 86		lda ($86),y	        lda  (r0),y
.dbe7	 29 8f		and #$8f	        and  #$8f       ; replace file
.dbe9	 91 86		sta ($86),y	        sta  (r0),y
.dbeb	 c8		iny		        iny
.dbec	 b1 86		lda ($86),y	        lda  (r0),y
.dbee	 85 80		sta $80		        sta  track
.dbf0	 84 71		sty $71		        sty  temp+2
.dbf2	 a0 1b		ldy #$1b	        ldy  #27        ; extract replacement link
.dbf4	 b1 86		lda ($86),y	        lda  (r0),y     ;  to last sector
.dbf6	 48		pha		        pha
.dbf7	 88		dey		        dey
.dbf8	 b1 86		lda ($86),y	        lda  (r0),y
.dbfa	 d0 0a		bne $dc06	        bne  clsd4
.dbfc	 85 80		sta $80		        sta  track
.dbfe	 68		pla		        pla
.dbff	 85 81		sta $81		        sta  sector
.dc01	 a9 67		lda #$67	        lda  #$67
.dc03	 20 45 e6	jsr $e645	        jsr  cmder2
.dc06					clsd4
.dc06	 48		pha		        pha
.dc07	 a9 00		lda #$00	        lda  #0
.dc09	 91 86		sta ($86),y	        sta  (r0),y
.dc0b	 c8		iny		        iny
.dc0c	 91 86		sta ($86),y	        sta  (r0),y
.dc0e	 68		pla		        pla
.dc0f	 a4 71		ldy $71		        ldy  temp+2
.dc11	 91 86		sta ($86),y	        sta  (r0),y
.dc13	 c8		iny		        iny
.dc14	 b1 86		lda ($86),y	        lda  (r0),y
.dc16	 85 81		sta $81		        sta  sector
.dc18	 68		pla		        pla
.dc19	 91 86		sta ($86),y	        sta  (r0),y
.dc1b	 20 7d c8	jsr $c87d	        jsr  delfil     ; delete old file
.dc1e	 4c 29 dc	jmp $dc29	        jmp  clsd6      ; set close bit
.dc21					clsd5
.dc21	 b1 86		lda ($86),y	        lda  (r0),y
.dc23	 29 0f		and #$0f	        and  #$f
.dc25	 09 80		ora #$80	        ora  #$80
.dc27	 91 86		sta ($86),y	        sta  (r0),y
.dc29	 ae 70 02	ldx $0270	clsd6   ldx  wlindx
.dc2c	 a0 1c		ldy #$1c	        ldy  #28        ; set # of blocks
.dc2e	 b5 b5		lda $b5,x	        lda  nbkl,x
.dc30	 91 86		sta ($86),y	        sta  (r0),y
.dc32	 c8		iny		        iny
.dc33	 b5 bb		lda $bb,x	        lda  nbkh,x
.dc35	 91 86		sta ($86),y	        sta  (r0),y
.dc37	 68		pla		        pla
.dc38	 aa		tax		        tax
.dc39	 a9 90		lda #$90	        lda  #write     ; write directory sector
.dc3b	 05 7f		ora $7f		        ora  drvnum
.dc3d	 20 90 d5	jsr $d590	        jsr  doit
.dc40	 68		pla		        pla
.dc41	 85 83		sta $83		        sta  sa
.dc43	 4c 07 d1	jmp $d107	        jmp  fndwch     ; restore lindx

;******  Return to file "serlib.asm"

						.include "opnchnl.asm"

;******  Processing file "opnchnl.asm"

.dc46	 a9 01		lda #$01	opnrch  lda  #1         ; get one data buffer
.dc48	 20 e2 d1	jsr $d1e2	        jsr  getrch
.dc4b	 20 b6 dc	jsr $dcb6	        jsr  initp      ; clear pointers
.dc4e	 ad 4a 02	lda $024a	        lda  type
.dc51	 48		pha		        pha
.dc52	 0a		asl a		        asl  a
.dc53	 05 7f		ora $7f		        ora  drvnum
.dc55	 95 ec		sta $ec,x	        sta  filtyp,x   ; set file type
.dc57	 20 9b d0	jsr $d09b	        jsr  strrd      ; read 1st one or two blocks
.dc5a	 a6 82		ldx $82		        ldx  lindx
.dc5c	 a5 80		lda $80		        lda  track
.dc5e	 d0 05		bne $dc65	        bne  or10
.dc60	 a5 81		lda $81		        lda  sector
.dc62	 9d 44 02	sta $0244,x	        sta  lstchr,x   ; set last char ptr
.dc65					or10
.dc65	 68		pla		        pla
.dc66	 c9 04		cmp #$04	        cmp  #reltyp
.dc68	 d0 3f		bne $dca9	        bne  or30       ; must be sequential stuff
.dc6a	 a4 83		ldy $83		        ldy  sa
.dc6c	 b9 2b 02	lda $022b,y	        lda  lintab,y   ; set channel as r/w
.dc6f	 09 40		ora #$40	        ora  #$40
.dc71	 99 2b 02	sta $022b,y	        sta  lintab,y
.dc74	 ad 58 02	lda $0258	        lda  rec
.dc77	 95 c7		sta $c7,x	        sta  rs,x       ; set record size
.dc79	 20 8e d2	jsr $d28e	        jsr  getbuf     ; get ss buffer
.dc7c	 10 03		bpl $dc81	        bpl  or20
.dc7e	 4c 0f d2	jmp $d20f	        jmp  gberr      ; no buffer
.dc81					or20
.dc81	 a6 82		ldx $82		        ldx  lindx
.dc83	 95 cd		sta $cd,x	        sta  ss,x
.dc85	 ac 59 02	ldy $0259	        ldy  trkss      ; set ss track
.dc88	 84 80		sty $80		        sty  track
.dc8a	 ac 5a 02	ldy $025a	        ldy  secss      ; set ss sector
.dc8d	 84 81		sty $81		        sty  sector
.dc8f	 20 d3 d6	jsr $d6d3	        jsr  seth       ; set ss header
.dc92	 20 73 de	jsr $de73	        jsr  rdss       ; read it in
.dc95	 20 99 d5	jsr $d599	        jsr  watjob
.dc98					orow
.dc98	 a6 82		ldx $82		        ldx  lindx
.dc9a	 a9 02		lda #$02	        lda  #2
.dc9c	 95 c1		sta $c1,x	        sta  nr,x       ; set for nxtrec
.dc9e	 a9 00		lda #$00	        lda  #0
.dca0	 20 c8 d4	jsr $d4c8	        jsr  setpnt     ; set first data byte
.dca3	 20 53 e1	jsr $e153	        jsr  rd40       ; set up 1st record
.dca6	 4c 3e de	jmp $de3e	        jmp  gethdr     ; restore t&s
.dca9					or30
.dca9	 20 56 d1	jsr $d156	        jsr  rdbyt      ; sequential set up
.dcac	 a6 82		ldx $82		        ldx  lindx
.dcae	 9d 3e 02	sta $023e,x	        sta  chndat,x
.dcb1	 a9 88		lda #$88	        lda  #rdytlk
.dcb3	 95 f2		sta $f2,x	        sta  chnrdy,x
.dcb5	 60		rts		        rts
.dcb6	 a6 82		ldx $82		initp   ldx  lindx
.dcb8	 b5 a7		lda $a7,x	        lda  buf0,x
.dcba	 0a		asl a		        asl  a
.dcbb	 30 06		bmi $dcc3		bmi  +		; *** rom ds 02/27/85 ***
.dcbd	 a8		tay		        tay
.dcbe	 a9 02		lda #$02	        lda  #2
.dcc0	 99 99 00	sta $0099,y	        sta  buftab,y
.dcc3	 b5 ae		lda $ae,x	+       lda  buf1,x
.dcc5	 09 80		ora #$80	        ora  #$80
.dcc7	 95 ae		sta $ae,x	        sta  buf1,x
.dcc9	 0a		asl a		        asl  a
.dcca	 30 06		bmi $dcd2		bmi  +		; *** rom ds 02/27/85 ***
.dccc	 a8		tay		        tay
.dccd	 a9 02		lda #$02	        lda  #2
.dccf	 99 99 00	sta $0099,y	        sta  buftab,y
.dcd2	 a9 00		lda #$00	+       lda  #0
.dcd4	 95 b5		sta $b5,x	        sta  nbkl,x
.dcd6	 4c 7f a9	jmp $a97f		jmp  ptch41	; *** rom ds 02/27/85 ***
.dcd9	 ea		nop			nop		; fill
.dcda	 20 a9 f1	jsr $f1a9	opnwch  jsr  intts      ; get first track,sector
.dcdd	 a9 01		lda #$01	        lda  #1
.dcdf	 20 df d1	jsr $d1df	        jsr  getwch     ; get 1 buffers for writing
.dce2	 20 d0 d6	jsr $d6d0	        jsr  sethdr     ; set up buffer headers
.dce5	 20 b6 dc	jsr $dcb6	        jsr  initp      ; zropnt
.dce8	 a6 82		ldx $82		        ldx  lindx
.dcea	 ad 4a 02	lda $024a	        lda  type
.dced	 48		pha		        pha
.dcee	 0a		asl a		        asl  a
.dcef	 05 7f		ora $7f		        ora  drvnum
.dcf1	 95 ec		sta $ec,x	        sta  filtyp,x   ; set filtyp=seq
.dcf3	 68		pla		        pla
.dcf4	 c9 04		cmp #$04	        cmp  #reltyp
.dcf6	 f0 05		beq $dcfd	        beq  ow10
.dcf8	 a9 01		lda #$01	        lda  #rdylst    ;  active listener
.dcfa	 95 f2		sta $f2,x	        sta  chnrdy,x
.dcfc	 60		rts		        rts
.dcfd					ow10
.dcfd	 a4 83		ldy $83		        ldy  sa
.dcff	 b9 2b 02	lda $022b,y	        lda  lintab,y
.dd02	 29 3f		and #$3f	        and  #$3f
.dd04	 09 40		ora #$40	        ora  #$40
.dd06	 99 2b 02	sta $022b,y	        sta  lintab,y   ; set channel as r/w
.dd09	 ad 58 02	lda $0258	        lda  rec
.dd0c	 95 c7		sta $c7,x	        sta  rs,x       ; set record size
.dd0e	 20 8e d2	jsr $d28e	        jsr  getbuf     ; get ss buffer
.dd11	 10 03		bpl $dd16	        bpl  ow20
.dd13	 4c 0f d2	jmp $d20f	        jmp  gberr      ; no buffer
.dd16					ow20
.dd16	 a6 82		ldx $82		        ldx  lindx
.dd18	 95 cd		sta $cd,x	        sta  ss,x
.dd1a	 20 c1 de	jsr $dec1	        jsr  clrbuf
.dd1d	 20 1e f1	jsr $f11e	        jsr  nxtts
.dd20	 a5 80		lda $80		        lda  track
.dd22	 8d 59 02	sta $0259	        sta  trkss      ; save ss t&s
.dd25	 a5 81		lda $81		        lda  sector
.dd27	 8d 5a 02	sta $025a	        sta  secss
.dd2a	 a6 82		ldx $82		        ldx  lindx
.dd2c	 b5 cd		lda $cd,x	        lda  ss,x
.dd2e	 20 d3 d6	jsr $d6d3	        jsr  seth       ; set ss header
.dd31	 a9 00		lda #$00	        lda  #0
.dd33	 20 e9 de	jsr $dee9	        jsr  setssp
.dd36	 a9 00		lda #$00	        lda  #0         ; set null link
.dd38	 20 8d dd	jsr $dd8d	        jsr  putss
.dd3b	 a9 11		lda #$11	        lda  #ssioff+1  ; set last char
.dd3d	 20 8d dd	jsr $dd8d	        jsr  putss
.dd40	 a9 00		lda #$00	        lda  #0         ; set this ss #
.dd42	 20 8d dd	jsr $dd8d	        jsr  putss
.dd45	 ad 58 02	lda $0258	        lda  rec        ; record size
.dd48	 20 8d dd	jsr $dd8d	        jsr  putss
.dd4b	 a5 80		lda $80		        lda  track
.dd4d	 20 8d dd	jsr $dd8d	        jsr  putss
.dd50	 a5 81		lda $81		        lda  sector
.dd52	 20 8d dd	jsr $dd8d	        jsr  putss
.dd55	 a9 10		lda #$10	        lda  #ssioff
.dd57	 20 e9 de	jsr $dee9	        jsr  setssp
.dd5a	 20 3e de	jsr $de3e	        jsr  gethdr     ; get first t&s
.dd5d	 a5 80		lda $80		        lda  track
.dd5f	 20 8d dd	jsr $dd8d	        jsr  putss
.dd62	 a5 81		lda $81		        lda  sector
.dd64	 20 8d dd	jsr $dd8d	        jsr  putss
.dd67	 20 6c de	jsr $de6c	        jsr  wrtss      ; write it out
.dd6a	 20 99 d5	jsr $d599	        jsr  watjob
.dd6d	 a9 02		lda #$02	        lda  #2
.dd6f	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.dd72	 a6 82		ldx $82		        ldx  lindx      ; set nr for null buffer
.dd74	 38		sec		        sec
.dd75	 a9 00		lda #$00	        lda  #0
.dd77	 f5 c7		sbc $c7,x	        sbc  rs,x
.dd79	 95 c1		sta $c1,x	        sta  nr,x
.dd7b	 20 e2 e2	jsr $e2e2	        jsr  nulbuf     ; null records
.dd7e	 20 19 de	jsr $de19	        jsr  nullnk
.dd81	 20 5e de	jsr $de5e	        jsr  wrtout
.dd84	 20 99 d5	jsr $d599	        jsr  watjob
.dd87	 20 f4 ee	jsr $eef4	        jsr  mapout
.dd8a	 4c 98 dc	jmp $dc98	        jmp  orow
.dd8d	 48		pha		putss   pha
.dd8e	 a6 82		ldx $82		        ldx  lindx
.dd90	 b5 cd		lda $cd,x	        lda  ss,x
.dd92	 4c fd cf	jmp $cffd	        jmp  putb1

;******  Return to file "serlib.asm"

						.include "tstflg.asm"

;******  Processing file "tstflg.asm"

.dd95	 90 06		bcc $dd9d	        bcc  clrflg
.dd97	 a6 82		ldx $82		setflg  ldx  lindx
.dd99	 15 ec		ora $ec,x	        ora  filtyp,x
.dd9b	 d0 06		bne $dda3	        bne  clrf10
.dd9d	 a6 82		ldx $82		clrflg  ldx  lindx
.dd9f	 49 ff		eor #$ff	        eor  #$ff
.dda1	 35 ec		and $ec,x	        and  filtyp,x
.dda3	 95 ec		sta $ec,x	clrf10  sta  filtyp,x
.dda5	 60		rts		        rts
.dda6	 a6 82		ldx $82		tstflg  ldx  lindx
.dda8	 35 ec		and $ec,x	        and  filtyp,x
.ddaa	 60		rts		        rts
.ddab	 20 93 df	jsr $df93	tstwrt  jsr  getact
.ddae	 aa		tax		        tax
.ddaf	 bd 5b 02	lda $025b,x	        lda  lstjob,x
.ddb2	 29 f0		and #$f0	        and  #$f0
.ddb4	 c9 90		cmp #$90	        cmp  #write
.ddb6	 60		rts		        rts
.ddb7	 a2 00		ldx #$00	tstchn  ldx  #0         ; start search at top
.ddb9	 86 71		stx $71		tstc20  stx  temp+2     ; save to look on
.ddbb	 bd 2b 02	lda $022b,x	        lda  lintab,x   ; get lindx
.ddbe	 c9 ff		cmp #$ff	        cmp  #$ff
.ddc0	 d0 08		bne $ddca	        bne  tstc40     ; if plus test it
.ddc2	 a6 71		ldx $71		tstc30  ldx  temp+2     ; not active
.ddc4	 e8		inx		        inx
.ddc5	 e0 10		cpx #$10	        cpx  #maxsa-2   ; searched all
.ddc7	 90 f0		bcc $ddb9	        bcc  tstc20     ; no
.ddc9	 60		rts		        rts     	; yes
.ddca	 86 71		stx $71		tstc40  stx  temp+2     ; save x
.ddcc	 29 3f		and #$3f	        and  #$3f
.ddce	 a8		tay		        tay     	; use lindx as index
.ddcf	 b9 ec 00	lda $00ec,y	        lda  filtyp,y   ; right drive # ?
.ddd2	 29 01		and #$01	        and  #1
.ddd4	 85 70		sta $70		        sta  temp+1
.ddd6	 ae 53 02	ldx $0253	        ldx  entfnd     ; index entry found
.ddd9	 b5 e2		lda $e2,x	        lda  fildrv,x
.dddb	 29 01		and #$01	        and  #1
.dddd	 c5 70		cmp $70		        cmp  temp+1     ; same drive # ?
.dddf	 d0 e1		bne $ddc2	        bne  tstc30     ; no
.dde1	 b9 60 02	lda $0260,y	        lda  dsec,y     ; yes - same dir. entry ?
.dde4	 d5 d8		cmp $d8,x	        cmp  entsec,x
.dde6	 d0 da		bne $ddc2	        bne  tstc30     ; no
.dde8	 b9 66 02	lda $0266,y	        lda  dind,y
.ddeb	 d5 dd		cmp $dd,x	        cmp  entind,x
.dded	 d0 d3		bne $ddc2	        bne  tstc30     ; no
.ddef	 18		clc		        clc     	; set flag
.ddf0	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "tsutil.asm"

;******  Processing file "tsutil.asm"

.ddf1	 20 9e df	jsr $df9e	scrub   jsr  gaflgs     ; wr out buf if dirty
.ddf4	 50 06		bvc $ddfc	        bvc  scr1       ; not dirty
.ddf6	 20 5e de	jsr $de5e	        jsr  wrtout
.ddf9	 20 99 d5	jsr $d599	        jsr  watjob
.ddfc	 60		rts		scr1    rts
.ddfd	 20 2b de	jsr $de2b	setlnk  jsr  set00      ; put trk,sec in buffer
.de00	 a5 80		lda $80		        lda  track
.de02	 91 94		sta ($94),y	        sta  (dirbuf),y
.de04	 c8		iny		        iny
.de05	 a5 81		lda $81		        lda  sector
.de07	 91 94		sta ($94),y	        sta  (dirbuf),y
.de09	 4c 05 e1	jmp $e105	        jmp  sdirty
.de0c	 20 2b de	jsr $de2b	getlnk  jsr  set00      ; get link from buffer
.de0f	 b1 94		lda ($94),y	        lda  (dirbuf),y ; into trk and sec
.de11	 85 80		sta $80		        sta  track
.de13	 c8		iny		        iny
.de14	 b1 94		lda ($94),y	        lda  (dirbuf),y
.de16	 85 81		sta $81		        sta  sector
.de18	 60		rts		        rts
.de19	 20 2b de	jsr $de2b	nullnk  jsr  set00      ; set trk link=0 and
.de1c	 a9 00		lda #$00	        lda  #0         ; link=last non-zero char.
.de1e	 91 94		sta ($94),y	        sta  (dirbuf),y
.de20	 c8		iny		        iny
.de21	 a6 82		ldx $82		        ldx  lindx
.de23	 b5 c1		lda $c1,x	        lda  nr,x
.de25	 aa		tax		        tax
.de26	 ca		dex		        dex
.de27	 8a		txa		        txa
.de28	 91 94		sta ($94),y	        sta  (dirbuf),y
.de2a	 60		rts		        rts
.de2b	 20 93 df	jsr $df93	set00   jsr  getact     ; set pntr to buffer
.de2e	 0a		asl a		        asl  a
.de2f	 aa		tax		        tax
.de30	 b5 9a		lda $9a,x	        lda  buftab+1,x
.de32	 85 95		sta $95		        sta  dirbuf+1
.de34	 a9 00		lda #$00	        lda  #0
.de36	 85 94		sta $94		        sta  dirbuf
.de38	 a0 00		ldy #$00	        ldy  #0
.de3a	 60		rts		        rts
.de3b	 20 eb d0	jsr $d0eb	curblk  jsr  fndrch     ; rd trk,sec from header
.de3e	 20 93 df	jsr $df93	gethdr  jsr  getact
.de41	 85 f9		sta $f9		        sta  jobnum
.de43	 0a		asl a		        asl  a
.de44	 a8		tay		        tay
.de45	 b9 06 00	lda $0006,y	        lda  hdrs,y     ; 4/12
.de48	 85 80		sta $80		        sta  track
.de4a	 b9 07 00	lda $0007,y	        lda  hdrs+1,y   ; 4/12
.de4d	 85 81		sta $81		        sta  sector
.de4f	 60		rts		        rts
.de50	 a9 90		lda #$90	wrtab   lda  #write	; wrtab/rdab
.de52	 8d 4d 02	sta $024d	        sta  cmd        ; wrtout/rdin
.de55	 d0 28		bne $de7f	        bne  sj10       ; wrtss/rdss
.de57	 a9 80		lda #$80	rdab    lda  #read
.de59	 8d 4d 02	sta $024d	        sta  cmd
.de5c	 d0 21		bne $de7f	        bne  sj10
.de5e	 a9 90		lda #$90	wrtout  lda  #write
.de60	 8d 4d 02	sta $024d	        sta  cmd
.de63	 d0 26		bne $de8b	        bne  sj20
.de65	 a9 80		lda #$80	        lda  #read
.de67	 8d 4d 02	sta $024d	        sta  cmd
.de6a	 d0 1f		bne $de8b	        bne  sj20
.de6c	 a9 90		lda #$90	wrtss   lda  #write
.de6e	 8d 4d 02	sta $024d	        sta  cmd
.de71	 d0 02		bne $de75	        bne  rds5
.de73	 a9 80		lda #$80	rdss    lda  #read
.de75	 8d 4d 02	sta $024d	rds5    sta  cmd
.de78	 a6 82		ldx $82		        ldx  lindx
.de7a	 b5 cd		lda $cd,x	        lda  ss,x
.de7c	 aa		tax		        tax
.de7d	 10 13		bpl $de92	        bpl  sj30
.de7f	 20 d0 d6	jsr $d6d0	sj10    jsr  sethdr
.de82	 20 93 df	jsr $df93	        jsr  getact
.de85	 aa		tax		        tax
.de86	 a5 7f		lda $7f		        lda  drvnum
.de88	 9d 5b 02	sta $025b,x	        sta  lstjob,x
.de8b	 20 15 e1	jsr $e115	sj20    jsr  cdirty
.de8e	 20 93 df	jsr $df93	        jsr  getact
.de91	 aa		tax		        tax
.de92	 4c 06 d5	jmp $d506	sj30    jmp  setljb
.de95	 a9 00		lda #$00	rdlnk   lda  #0         ; rdlnk
.de97	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.de9a	 20 37 d1	jsr $d137	        jsr  getbyt
.de9d	 85 80		sta $80		        sta  track
.de9f	 20 37 d1	jsr $d137	        jsr  getbyt
.dea2	 85 81		sta $81		        sta  sector
.dea4	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "ssutil.asm"

;******  Processing file "ssutil.asm"

.dea5	 48		pha		b0tob0  pha     	; buff to buff transfr
.dea6	 a9 00		lda #$00	        lda  #0
.dea8	 85 6f		sta $6f		        sta  temp
.deaa	 85 71		sta $71		        sta  temp+2
.deac	 b9 e0 fe	lda $fee0,y	        lda  bufind,y
.deaf	 85 70		sta $70		        sta  temp+1
.deb1	 bd e0 fe	lda $fee0,x	        lda  bufind,x
.deb4	 85 72		sta $72		        sta  temp+3
.deb6	 68		pla		        pla
.deb7	 a8		tay		        tay
.deb8	 88		dey		        dey
.deb9	 b1 6f		lda ($6f),y	b02     lda  (temp),y
.debb	 91 71		sta ($71),y	        sta  (temp+2),y
.debd	 88		dey		        dey
.debe	 10 f9		bpl $deb9	        bpl  b02
.dec0	 60		rts		        rts
.dec1	 a8		tay		clrbuf  tay     	; clr given buffer
.dec2	 b9 e0 fe	lda $fee0,y	        lda  bufind,y   ; accm =buff
.dec5	 85 70		sta $70		        sta  temp+1
.dec7	 a9 00		lda #$00	        lda  #0
.dec9	 85 6f		sta $6f		        sta  temp
.decb	 a8		tay		        tay
.decc	 91 6f		sta ($6f),y	cb10    sta  (temp),y
.dece	 c8		iny		        iny
.decf	 d0 fb		bne $decc	        bne  cb10
.ded1	 60		rts		        rts
.ded2	 a9 00		lda #$00	ssset   lda  #0         ; set ss pntr=0
.ded4	 20 dc de	jsr $dedc	        jsr  ssdir
.ded7	 a0 02		ldy #$02	        ldy  #2
.ded9	 b1 94		lda ($94),y	        lda  (dirbuf),y ; accm=ss number
.dedb	 60		rts		        rts
.dedc	 85 94		sta $94		ssdir   sta  dirbuf     ; set dirbuf w/current
.dede	 a6 82		ldx $82		        ldx  lindx      ; ss pointer. accm=low byte
.dee0	 b5 cd		lda $cd,x	        lda  ss,x
.dee2	 aa		tax		        tax
.dee3	 bd e0 fe	lda $fee0,x	        lda  bufind,x
.dee6	 85 95		sta $95		        sta  dirbuf+1
.dee8	 60		rts		        rts
.dee9	 48		pha		setssp  pha     	; set dirbuf and buftbl with
.deea	 20 dc de	jsr $dedc	        jsr  ssdir      ; current ss pntr. acm=low byte
.deed	 48		pha		        pha
.deee	 8a		txa		        txa
.deef	 0a		asl a		        asl  a
.def0	 aa		tax		        tax
.def1	 68		pla		        pla
.def2	 95 9a		sta $9a,x	        sta  buftab+1,x
.def4	 68		pla		        pla
.def5	 95 99		sta $99,x	        sta  buftab,x
.def7	 60		rts		        rts
.def8	 20 66 df	jsr $df66	sspos   jsr  sstest     ; set ss/buftbl to
.defb	 30 0e		bmi $df0b	        bmi  ssp10      ; to ssnum ssind
.defd	 50 13		bvc $df12	        bvc  ssp20      ; er0:ok, in range
.deff	 a6 82		ldx $82		        ldx  lindx      ; er1: possibly in range
.df01	 b5 cd		lda $cd,x	        lda  ss,x
.df03	 20 1b df	jsr $df1b	        jsr  ibrd       ; read ss in
.df06	 20 66 df	jsr $df66	        jsr  sstest     ; test again
.df09	 10 07		bpl $df12	        bpl  ssp20
.df0b	 20 cb e1	jsr $e1cb	ssp10   jsr  ssend      ; not in range,set end
.df0e	 2c ce fe	bit $fece	        bit  er1
.df11	 60		rts		        rts     	; v=1
.df12	 a5 d6		lda $d6		ssp20   lda  ssind      ; ok, set ptr w/ index
.df14	 20 e9 de	jsr $dee9	        jsr  setssp
.df17	 2c cd fe	bit $fecd	        bit  er0
.df1a	 60		rts		        rts     	; v=0
.df1b	 85 f9		sta $f9		ibrd    sta  jobnum     ; indir block rd/wr.
.df1d	 a9 80		lda #$80	        lda  #read	; accm= buf#, x=lindx
.df1f	 d0 04		bne $df25	        bne  ibop       ; dirbuf)y pnts to t&s for r/w
.df21	 85 f9		sta $f9		        sta  jobnum
.df23	 a9 90		lda #$90	        lda  #write
.df25	 48		pha		ibop    pha
.df26	 b5 ec		lda $ec,x	        lda  filtyp,x
.df28	 29 01		and #$01	        and  #1
.df2a	 85 7f		sta $7f		        sta  drvnum
.df2c	 68		pla		        pla
.df2d	 05 7f		ora $7f		        ora  drvnum
.df2f	 8d 4d 02	sta $024d		sta  cmd
.df32	 b1 94		lda ($94),y	        lda  (dirbuf),y
.df34	 85 80		sta $80		        sta  track
.df36	 c8		iny		        iny
.df37	 b1 94		lda ($94),y	        lda  (dirbuf),y
.df39	 85 81		sta $81		        sta  sector
.df3b	 a5 f9		lda $f9		        lda  jobnum
.df3d	 20 d3 d6	jsr $d6d3	        jsr  seth
.df40	 a6 f9		ldx $f9		        ldx  jobnum
.df42	 4c 93 d5	jmp $d593	        jmp  doit2
.df45	 a6 82		ldx $82		gsspnt  ldx  lindx
.df47	 b5 cd		lda $cd,x	        lda  ss,x
.df49	 4c eb d4	jmp $d4eb	        jmp  gp1
.df4c	 a9 78		lda #$78	scal1   lda  #nssp
.df4e	 20 5c df	jsr $df5c	        jsr  addt12     ; add (#ss needed)*120
.df51	 ca		dex		sscalc  dex
.df52	 10 f8		bpl $df4c	        bpl  scal1
.df54	 a5 72		lda $72		        lda  t3         ; add (# ss indices needed)
.df56	 4a		lsr a		        lsr  a
.df57	 20 5c df	jsr $df5c	        jsr  addt12
.df5a	 a5 73		lda $73		        lda  t4         ; add (# ss blocks needed)
.df5c	 18		clc		addt12  clc     	; add .a to t1,t2
.df5d	 65 70		adc $70		        adc  t1
.df5f	 85 70		sta $70		        sta  t1
.df61	 90 02		bcc $df65	        bcc  addrts
.df63	 e6 71		inc $71		        inc  t2
.df65	 60		rts		addrts  rts

;******  Return to file "serlib.asm"

						.include "sstest.asm"

;******  Processing file "sstest.asm"

.df66	 20 d2 de	jsr $ded2	sstest  jsr  ssset      ; set pointer & ss #
.df69	 c5 d5		cmp $d5		        cmp  ssnum
.df6b	 d0 0e		bne $df7b	        bne  st20       ; not this ss
.df6d	 a4 d6		ldy $d6		        ldy  ssind
.df6f	 b1 94		lda ($94),y	        lda  (dirbuf),y
.df71	 f0 04		beq $df77	        beq  st10
.df73	 2c cd fe	bit $fecd	        bit  er0        ; ok, resident
.df76	 60		rts		        rts
.df77	 2c cf fe	bit $fecf	st10    bit  er2        ; out of range, res
.df7a	 60		rts		        rts
.df7b	 a5 d5		lda $d5		st20    lda  ssnum
.df7d	 c9 06		cmp #$06	        cmp  #nssl
.df7f	 b0 0a		bcs $df8b	        bcs  st30
.df81	 0a		asl a		        asl  a
.df82	 a8		tay		        tay
.df83	 a9 04		lda #$04	        lda  #4
.df85	 85 94		sta $94		        sta  dirbuf
.df87	 b1 94		lda ($94),y	        lda  (dirbuf),y
.df89	 d0 04		bne $df8f	        bne  st40
.df8b	 2c d0 fe	bit $fed0	st30    bit  er3        ; way out of range
.df8e	 60		rts		        rts
.df8f	 2c ce fe	bit $fece	st40    bit  er1        ; not res, range???
.df92	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "getact.asm"

;******  Processing file "getact.asm"

.df93					getact
.df93	 a6 82		ldx $82		        ldx  lindx
.df95	 b5 a7		lda $a7,x	        lda  buf0,x
.df97	 10 02		bpl $df9b	        bpl  ga1
.df99	 b5 ae		lda $ae,x	        lda  buf1,x
.df9b					ga1
.df9b	 29 bf		and #$bf	        and  #$bf       ;  strip dirty bit
.df9d	 60		rts		        rts
.df9e					gaflgs
.df9e	 a6 82		ldx $82		        ldx  lindx
.dfa0	 8e 57 02	stx $0257	ga2     stx  lbused     ; save buf #
.dfa3	 b5 a7		lda $a7,x	        lda  buf0,x
.dfa5	 10 09		bpl $dfb0	        bpl  ga3
.dfa7	 8a		txa		        txa
.dfa8	 18		clc		        clc
.dfa9	 69 07		adc #$07	        adc  #mxchns+1
.dfab	 8d 57 02	sta $0257	        sta  lbused
.dfae	 b5 ae		lda $ae,x	        lda  buf1,x
.dfb0					ga3
.dfb0	 85 70		sta $70		        sta  t1
.dfb2	 29 1f		and #$1f	        and  #$1f
.dfb4	 24 70		bit $70		        bit  t1
.dfb6	 60		rts		        rts
.dfb7	 a6 82		ldx $82		getina  ldx  lindx
.dfb9	 b5 a7		lda $a7,x	        lda  buf0,x
.dfbb	 30 02		bmi $dfbf	        bmi  gi10
.dfbd	 b5 ae		lda $ae,x	        lda  buf1,x
.dfbf	 c9 ff		cmp #$ff	gi10    cmp  #$ff
.dfc1	 60		rts		        rts
.dfc2	 a6 82		ldx $82		putina  ldx  lindx
.dfc4	 09 80		ora #$80	        ora  #$80
.dfc6	 b4 a7		ldy $a7,x	        ldy  buf0,x
.dfc8	 10 03		bpl $dfcd	        bpl  pi1
.dfca	 95 a7		sta $a7,x	        sta  buf0,x
.dfcc	 60		rts		        rts
.dfcd	 95 ae		sta $ae,x	pi1     sta  buf1,x
.dfcf	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "rel1.asm"

;******  Processing file "rel1.asm"

.dfd0					nxtrec
.dfd0	 a9 20		lda #$20	        lda  #ovrflo
.dfd2	 20 9d dd	jsr $dd9d	        jsr  clrflg
.dfd5	 a9 80		lda #$80	        lda  #lrf
.dfd7	 20 a6 dd	jsr $dda6	        jsr  tstflg
.dfda	 d0 41		bne $e01d	        bne  nxtr40
.dfdc	 a6 82		ldx $82		        ldx  lindx
.dfde	 f6 b5		inc $b5,x	        inc  recl,x     ;  goto next record #
.dfe0	 d0 02		bne $dfe4	        bne  nxtr15
.dfe2	 f6 bb		inc $bb,x	        inc  rech,x
.dfe4					nxtr15
.dfe4	 a6 82		ldx $82		        ldx  lindx
.dfe6	 b5 c1		lda $c1,x	        lda  nr,x
.dfe8	 f0 2e		beq $e018	        beq  nxtr45     ; there is a nr
.dfea	 20 e8 d4	jsr $d4e8	        jsr  getpnt     ;  get pointer
.dfed	 a6 82		ldx $82		        ldx  lindx      ; test if same buffer
.dfef	 d5 c1		cmp $c1,x	        cmp  nr,x
.dff1	 90 03		bcc $dff6	        bcc  nxtr20     ;  yes, bt<nr
.dff3	 20 3c e0	jsr $e03c	        jsr  nrbuf      ;  no,next buffer
.dff6	 a6 82		ldx $82		nxtr20  ldx  lindx
.dff8	 b5 c1		lda $c1,x	        lda  nr,x
.dffa	 20 c8 d4	jsr $d4c8	        jsr  setpnt     ; advance to next rec
.dffd	 a1 99		lda ($99,x)	        lda  (buftab,x) ; read 1st dat byte
.dfff	 85 85		sta $85		        sta  data       ; save for read channel
.e001	 a9 20		lda #$20	        lda  #ovrflo
.e003	 20 9d dd	jsr $dd9d	        jsr  clrflg     ;  clear
.e006	 20 04 e3	jsr $e304	        jsr  addnr      ; advance nr
.e009					nxout
.e009	 48		pha		        pha
.e00a	 90 28		bcc $e034	        bcc  nxtr30     ; no block boundary
.e00c	 a9 00		lda #$00	        lda  #0
.e00e	 20 f6 d4	jsr $d4f6	        jsr  drdbyt     ; check track link
.e011	 d0 21		bne $e034	        bne  nxtr30     ; not last block
.e013	 68		pla		        pla
.e014	 c9 02		cmp #$02	        cmp  #2
.e016	 f0 12		beq $e02a	        beq  nxtr50
.e018					nxtr45
.e018	 a9 80		lda #$80	        lda  #lrf
.e01a	 20 97 dd	jsr $dd97	        jsr  setflg
.e01d					nxtr40
.e01d	 20 2f d1	jsr $d12f	        jsr  getpre
.e020	 b5 99		lda $99,x	        lda  buftab,x
.e022	 99 44 02	sta $0244,y	        sta  lstchr,y
.e025	 a9 0d		lda #$0d	        lda  #cr
.e027	 85 85		sta $85		        sta  data
.e029	 60		rts		        rts
.e02a					nxtr50
.e02a	 20 35 e0	jsr $e035	        jsr  nxtr35
.e02d	 a6 82		ldx $82		        ldx  lindx
.e02f	 a9 00		lda #$00	        lda  #0
.e031	 95 c1		sta $c1,x	        sta  nr,x
.e033	 60		rts		        rts
.e034					nxtr30
.e034	 68		pla		        pla
.e035					nxtr35
.e035	 a6 82		ldx $82		        ldx  lindx
.e037	 95 c1		sta $c1,x	        sta  nr,x
.e039	 4c 6e e1	jmp $e16e	        jmp  setlst
.e03c					nrbuf
.e03c	 20 d3 d1	jsr $d1d3	        jsr  setdrn
.e03f	 20 95 de	jsr $de95	        jsr  rdlnk
.e042	 20 9e df	jsr $df9e	        jsr  gaflgs     ; test if dirty
.e045	 50 16		bvc $e05d	        bvc  nrbu50     ; clean, dont write out
.e047	 20 5e de	jsr $de5e	        jsr  wrtout     ; dirty, write out
.e04a	 20 1e cf	jsr $cf1e	        jsr  dblbuf     ; toggle active buffer
.e04d	 a9 02		lda #$02	        lda  #2
.e04f	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.e052	 20 ab dd	jsr $ddab	        jsr  tstwrt     ; test if lstjob is wrt
.e055	 d0 24		bne $e07b	        bne  nrbu20     ; not a write,buffer ok
.e057	 20 57 de	jsr $de57	        jsr  rdab       ; read in needed buffer
.e05a	 4c 99 d5	jmp $d599	        jmp  watjob     ; wait around till done
.e05d	 20 1e cf	jsr $cf1e	nrbu50  jsr  dblbuf     ; toggle act buf
.e060	 20 ab dd	jsr $ddab	        jsr  tstwrt     ; was lstjob a wrt?
.e063	 d0 06		bne $e06b	        bne  nrbu70     ; not a write
.e065	 20 57 de	jsr $de57	        jsr  rdab       ; read in needed buffer
.e068	 20 99 d5	jsr $d599	        jsr  watjob     ; wait till done
.e06b					nrbu70
.e06b	 20 95 de	jsr $de95	        jsr  rdlnk      ; to do a read ahead
.e06e	 a5 80		lda $80		        lda  track      ; test if last buffer
.e070	 f0 09		beq $e07b	        beq  nrbu20     ; yes,no dbl buff todo
.e072	 20 1e cf	jsr $cf1e	        jsr  dblbuf     ; start read job on the
.e075	 20 57 de	jsr $de57	        jsr  rdab       ; inactive buffer
.e078	 20 1e cf	jsr $cf1e	        jsr  dblbuf
.e07b	 60		rts		nrbu20  rts

;******  Return to file "serlib.asm"

						.include "rel2.asm"

;******  Processing file "rel2.asm"

.e07c	 20 05 e1	jsr $e105	relput  jsr  sdirty     ; write data to buffer
.e07f	 20 93 df	jsr $df93	        jsr  getact
.e082	 0a		asl a		        asl  a
.e083	 aa		tax		        tax
.e084	 a5 85		lda $85		        lda  data
.e086	 81 99		sta ($99,x)	        sta  (buftab,x)
.e088	 b4 99		ldy $99,x	        ldy  buftab,x   ; inc the pointer
.e08a	 c8		iny		        iny
.e08b	 d0 09		bne $e096	        bne  relp05
.e08d	 a4 82		ldy $82		        ldy  lindx
.e08f	 b9 c1 00	lda $00c1,y	        lda  nr,y
.e092	 f0 0a		beq $e09e	        beq  relp07
.e094					relp06
.e094	 a0 02		ldy #$02	        ldy  #2
.e096					relp05
.e096	 98		tya		        tya
.e097	 a4 82		ldy $82		        ldy  lindx
.e099	 d9 c1 00	cmp $00c1,y	        cmp  nr,y       ; test if nr=pointer
.e09c	 d0 05		bne $e0a3	        bne  relp10     ; no,set new pointer
.e09e	 a9 20		lda #$20	relp07  lda  #ovrflo    ; yes,set overflow
.e0a0	 4c 97 dd	jmp $dd97	        jmp  setflg
.e0a3					relp10
.e0a3	 f6 99		inc $99,x	        inc  buftab,x
.e0a5	 d0 03		bne $e0aa	        bne  relp20     ; test if =0
.e0a7	 20 3c e0	jsr $e03c	        jsr  nrbuf      ; prepare nxt buffer
.e0aa	 60		rts		relp20  rts
.e0ab					wrtrel
.e0ab	 a9 a0		lda #$a0	        lda  #lrf+ovrflo ;check all flags
.e0ad	 20 a6 dd	jsr $dda6	        jsr  tstflg
.e0b0	 d0 27		bne $e0d9	        bne  wr50       ; some flag is set
.e0b2					wr10
.e0b2	 a5 85		lda $85		        lda  data       ; ready to put data
.e0b4	 20 7c e0	jsr $e07c	        jsr  relput
.e0b7					wr20
.e0b7	 a5 f8		lda $f8		        lda  eoiflg
.e0b9	 f0 0d		beq $e0c8	        beq  wr40       ; eoi was sent
.e0bb	 60		rts		        rts
.e0bc					wr30
.e0bc	 a9 20		lda #$20	        lda  #ovrflo
.e0be	 20 a6 dd	jsr $dda6	        jsr  tstflg
.e0c1	 f0 05		beq $e0c8	        beq  wr40       ; no rec overflow
.e0c3	 a9 51		lda #$51	        lda  #recovf
.e0c5	 8d 6c 02	sta $026c	        sta  erword     ; set error for end of print
.e0c8					wr40
.e0c8	 20 f3 e0	jsr $e0f3	        jsr  clrec      ; clear rest of record
.e0cb	 20 53 e1	jsr $e153	        jsr  rd40
.e0ce	 ad 6c 02	lda $026c	        lda  erword
.e0d1	 f0 03		beq $e0d6	        beq  wr45
.e0d3	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.e0d6					wr45
.e0d6	 4c bc e6	jmp $e6bc	        jmp  okerr
.e0d9					wr50
.e0d9	 29 80		and #$80	        and  #lrf
.e0db	 d0 05		bne $e0e2	        bne  wr60       ; last rec, add
.e0dd	 a5 f8		lda $f8		        lda  eoiflg
.e0df	 f0 db		beq $e0bc	        beq  wr30
.e0e1					wr51
.e0e1	 60		rts		        rts
.e0e2					wr60
.e0e2	 a5 85		lda $85		        lda  data
.e0e4	 48		pha		        pha
.e0e5	 20 1c e3	jsr $e31c	        jsr  addrel     ; add to file
.e0e8	 68		pla		        pla
.e0e9	 85 85		sta $85		        sta  data
.e0eb	 a9 80		lda #$80	        lda  #lrf
.e0ed	 20 9d dd	jsr $dd9d	        jsr  clrflg
.e0f0	 4c b2 e0	jmp $e0b2	        jmp  wr10
.e0f3	 a9 20		lda #$20	clrec   lda  #ovrflo    ; put 0's into rest of record
.e0f5	 20 a6 dd	jsr $dda6	        jsr  tstflg
.e0f8	 d0 0a		bne $e104	        bne  clr10
.e0fa	 a9 00		lda #$00	        lda  #0
.e0fc	 85 85		sta $85		        sta  data
.e0fe	 20 7c e0	jsr $e07c	        jsr  relput
.e101	 4c f3 e0	jmp $e0f3	        jmp  clrec
.e104	 60		rts		clr10   rts
.e105	 a9 40		lda #$40	sdirty  lda  #dyfile
.e107	 20 97 dd	jsr $dd97	        jsr  setflg
.e10a	 20 9e df	jsr $df9e	        jsr  gaflgs
.e10d	 09 40		ora #$40	        ora  #$40
.e10f	 ae 57 02	ldx $0257	        ldx  lbused
.e112	 95 a7		sta $a7,x	        sta  buf0,x
.e114	 60		rts		        rts
.e115	 20 9e df	jsr $df9e	cdirty  jsr  gaflgs
.e118	 29 bf		and #$bf	        and  #$bf
.e11a	 ae 57 02	ldx $0257	        ldx  lbused
.e11d	 95 a7		sta $a7,x	        sta  buf0,x
.e11f	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "rel3.asm"

;******  Processing file "rel3.asm"

.e120					rdrel
.e120	 a9 80		lda #$80	        lda  #lrf
.e122	 20 a6 dd	jsr $dda6	        jsr  tstflg
.e125	 d0 37		bne $e15e	        bne  rd05       ; no record error
.e127					rd10
.e127	 20 2f d1	jsr $d12f	        jsr  getpre
.e12a	 b5 99		lda $99,x	        lda  buftab,x
.e12c	 d9 44 02	cmp $0244,y	        cmp  lstchr,y
.e12f	 f0 22		beq $e153	        beq  rd40
.e131	 f6 99		inc $99,x	        inc  buftab,x
.e133	 d0 06		bne $e13b	        bne  rd20
.e135	 20 3c e0	jsr $e03c	        jsr  nrbuf
.e138					rd15
.e138	 20 2f d1	jsr $d12f	        jsr  getpre
.e13b					rd20
.e13b	 a1 99		lda ($99,x)	        lda  (buftab,x)
.e13d					rd25
.e13d	 99 3e 02	sta $023e,y	        sta  chndat,y
.e140	 a9 89		lda #$89	        lda  #rndrdy
.e142	 99 f2 00	sta $00f2,y	        sta  chnrdy,y
.e145	 b5 99		lda $99,x	        lda  buftab,x
.e147	 d9 44 02	cmp $0244,y	        cmp  lstchr,y
.e14a	 f0 01		beq $e14d	        beq  rd30
.e14c	 60		rts		        rts
.e14d					rd30
.e14d	 a9 81		lda #$81	        lda  #rndeoi
.e14f	 99 f2 00	sta $00f2,y	        sta  chnrdy,y
.e152	 60		rts		        rts
.e153					rd40
.e153	 20 d0 df	jsr $dfd0	        jsr  nxtrec
.e156	 20 2f d1	jsr $d12f	        jsr  getpre
.e159	 a5 85		lda $85		        lda  data
.e15b	 4c 3d e1	jmp $e13d	        jmp  rd25
.e15e					rd05
.e15e	 a6 82		ldx $82		        ldx  lindx      ; no record char set up
.e160	 a9 0d		lda #$0d	        lda  #cr
.e162	 9d 3e 02	sta $023e,x	        sta  chndat,x
.e165	 a9 81		lda #$81	        lda  #rndeoi
.e167	 95 f2		sta $f2,x	        sta  chnrdy,x
.e169	 a9 50		lda #$50	        lda  #norec
.e16b	 20 c8 c1	jsr $c1c8	        jsr  cmderr

;******  Return to file "serlib.asm"

						.include "rel4.asm"

;******  Processing file "rel4.asm"

.e16e	 a6 82		ldx $82		setlst  ldx  lindx
.e170	 b5 c1		lda $c1,x	        lda  nr,x
.e172	 85 87		sta $87		        sta  r1
.e174	 c6 87		dec $87		        dec  r1
.e176	 c9 02		cmp #$02	        cmp  #2
.e178	 d0 04		bne $e17e	        bne  setl01
.e17a	 a9 ff		lda #$ff	        lda  #$ff
.e17c	 85 87		sta $87		        sta  r1
.e17e					setl01
.e17e	 b5 c7		lda $c7,x	        lda  rs,x
.e180	 85 88		sta $88		        sta  r2
.e182	 20 e8 d4	jsr $d4e8	        jsr  getpnt
.e185	 a6 82		ldx $82		        ldx  lindx
.e187	 c5 87		cmp $87		        cmp  r1
.e189	 90 19		bcc $e1a4	        bcc  setl10
.e18b	 f0 17		beq $e1a4	        beq  setl10
.e18d	 20 1e cf	jsr $cf1e	        jsr  dblbuf
.e190	 20 b2 e1	jsr $e1b2	        jsr  fndlst
.e193	 90 08		bcc $e19d	        bcc  setl05
.e195	 a6 82		ldx $82		        ldx  lindx
.e197	 9d 44 02	sta $0244,x	        sta  lstchr,x
.e19a	 4c 1e cf	jmp $cf1e	        jmp  dblbuf
.e19d	 20 1e cf	jsr $cf1e	setl05  jsr  dblbuf
.e1a0	 a9 ff		lda #$ff	        lda  #$ff
.e1a2	 85 87		sta $87		        sta  r1
.e1a4	 20 b2 e1	jsr $e1b2	setl10  jsr  fndlst
.e1a7	 b0 03		bcs $e1ac	        bcs  setl40
.e1a9	 20 e8 d4	jsr $d4e8	        jsr  getpnt
.e1ac	 a6 82		ldx $82		setl40  ldx  lindx
.e1ae	 9d 44 02	sta $0244,x	        sta  lstchr,x
.e1b1	 60		rts		        rts
.e1b2					fndlst
.e1b2	 20 2b de	jsr $de2b	        jsr  set00
.e1b5	 a4 87		ldy $87		        ldy  r1         ; offset to start at
.e1b7	 b1 94		lda ($94),y	fndl10  lda  (dirbuf),y
.e1b9	 d0 0d		bne $e1c8	        bne  fndl20
.e1bb	 88		dey		        dey
.e1bc	 c0 02		cpy #$02	        cpy  #2
.e1be	 90 04		bcc $e1c4	        bcc  fndl30
.e1c0	 c6 88		dec $88		        dec  r2         ; limit counter
.e1c2	 d0 f3		bne $e1b7	        bne  fndl10
.e1c4	 c6 88		dec $88		fndl30  dec  r2
.e1c6	 18		clc		        clc     	;  not found here
.e1c7	 60		rts		        rts
.e1c8	 98		tya		fndl20  tya     	; found the end char
.e1c9	 38		sec		        sec
.e1ca	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "ssend.asm"

;******  Processing file "ssend.asm"

.e1cb	 20 d2 de	jsr $ded2	ssend   jsr  ssset      ; set ss & buftbl to
.e1ce	 85 d5		sta $d5		        sta  ssnum      ; end of last record
.e1d0	 a9 04		lda #$04	        lda  #4
.e1d2	 85 94		sta $94		        sta  dirbuf
.e1d4	 a0 0a		ldy #$0a	        ldy  #ssioff-6
.e1d6	 d0 04		bne $e1dc	        bne  se20       ; bra
.e1d8	 88		dey		se10    dey
.e1d9	 88		dey		        dey
.e1da	 30 26		bmi $e202	        bmi  break
.e1dc	 b1 94		lda ($94),y	se20    lda  (dirbuf),y ; look for last ss #
.e1de	 f0 f8		beq $e1d8	        beq  se10       ; t=0: not yet
.e1e0	 98		tya		        tya
.e1e1	 4a		lsr a		        lsr  a
.e1e2	 c5 d5		cmp $d5		        cmp  ssnum      ; check ss #
.e1e4	 f0 09		beq $e1ef	        beq  se30       ; this is last ss
.e1e6	 85 d5		sta $d5		        sta  ssnum
.e1e8	 a6 82		ldx $82		        ldx  lindx
.e1ea	 b5 cd		lda $cd,x	        lda  ss,x
.e1ec	 20 1b df	jsr $df1b	        jsr  ibrd       ; read last ss
.e1ef	 a0 00		ldy #$00	se30    ldy  #0         ; set ssind
.e1f1	 84 94		sty $94		        sty  dirbuf
.e1f3	 b1 94		lda ($94),y	        lda  (dirbuf),y ; debug
.e1f5	 d0 0b		bne $e202	        bne  break
.e1f7	 c8		iny		        iny
.e1f8	 b1 94		lda ($94),y	        lda  (dirbuf),y
.e1fa	 a8		tay		        tay     	; back up to track
.e1fb	 88		dey		        dey
.e1fc	 84 d6		sty $d6		        sty  ssind
.e1fe	 98		tya		        tya
.e1ff	 4c e9 de	jmp $dee9	        jmp  setssp
.e202	 a9 67		lda #$67	break   lda  #$67
.e204	 20 45 e6	jsr $e645	        jsr  cmder2

;******  Return to file "serlib.asm"

						.include "record.asm"

;******  Processing file "record.asm"

.e207					record
.e207	 20 b3 c2	jsr $c2b3	        jsr  cmdset     ; init tables, ptrs
.e20a	 ad 01 02	lda $0201	        lda  cmdbuf+1
.e20d	 85 83		sta $83		        sta  sa
.e20f	 20 eb d0	jsr $d0eb	        jsr  fndrch
.e212	 90 05		bcc $e219	        bcc  r20        ; got channel's lindex
.e214	 a9 70		lda #$70	        lda  #nochnl    ; no valid channel
.e216	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.e219					r20
.e219	 a9 a0		lda #$a0	        lda  #lrf+ovrflo
.e21b	 20 9d dd	jsr $dd9d	        jsr  clrflg
.e21e	 20 25 d1	jsr $d125	        jsr  typfil     ; get file type
.e221	 f0 05		beq $e228	        beq  r30        ; it is relative file
.e223	 a9 64		lda #$64	        lda  #mistyp    ; wrong type
.e225	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.e228					r30
.e228	 b5 ec		lda $ec,x	        lda  filtyp,x
.e22a	 29 01		and #$01	        and  #1
.e22c	 85 7f		sta $7f		        sta  drvnum
.e22e	 ad 02 02	lda $0202	        lda  cmdbuf+2
.e231	 95 b5		sta $b5,x	        sta  recl,x     ; get record #
.e233	 ad 03 02	lda $0203	        lda  cmdbuf+3
.e236	 95 bb		sta $bb,x	        sta  rech,x
.e238	 a6 82		ldx $82		        ldx  lindx      ; clear chnrdy to rndrdy
.e23a	 a9 89		lda #$89	        lda  #rndrdy
.e23c	 95 f2		sta $f2,x	        sta  chnrdy,x
.e23e	 ad 04 02	lda $0204	        lda  cmdbuf+4   ; get offset
.e241	 f0 10		beq $e253	        beq  r40
.e243	 38		sec		        sec
.e244	 e9 01		sbc #$01	        sbc  #1
.e246	 f0 0b		beq $e253	        beq  r40
.e248	 d5 c7		cmp $c7,x	        cmp  rs,x
.e24a	 90 07		bcc $e253	        bcc  r35
.e24c	 a9 51		lda #$51	        lda  #recovf
.e24e	 8d 6c 02	sta $026c	        sta  erword
.e251	 a9 00		lda #$00	        lda  #0
.e253					r35
.e253					r40
.e253	 85 d4		sta $d4		        sta  recptr     ; set offset
.e255	 20 0e ce	jsr $ce0e	        jsr  fndrel     ; calc ss stuff
.e258	 20 f8 de	jsr $def8	        jsr  sspos      ; set ss ptrs
.e25b	 50 08		bvc $e265	        bvc  r50
.e25d	 a9 80		lda #$80	        lda  #lrf       ; beyond the end
.e25f	 20 97 dd	jsr $dd97	        jsr  setflg     ; set last rec flag
.e262	 4c 5e e1	jmp $e15e	        jmp  rd05
.e265					r50
.e265	 20 75 e2	jsr $e275	        jsr  positn     ; position to record
.e268	 a9 80		lda #$80	        lda  #lrf
.e26a	 20 a6 dd	jsr $dda6	        jsr  tstflg
.e26d	 f0 03		beq $e272	        beq  r60
.e26f	 4c 5e e1	jmp $e15e	        jmp  rd05
.e272					r60
.e272	 4c 94 c1	jmp $c194	        jmp  endcmd     ; that's all
.e275					positn
.e275	 20 9c e2	jsr $e29c	        jsr  posbuf     ; position buffers
.e278	 a5 d7		lda $d7		        lda  relptr
.e27a	 20 c8 d4	jsr $d4c8	        jsr  setpnt     ; set ptr from fndrel
.e27d	 a6 82		ldx $82		        ldx  lindx
.e27f	 b5 c7		lda $c7,x	        lda  rs,x
.e281	 38		sec		        sec     	; calc the offset
.e282	 e5 d4		sbc $d4		        sbc  recptr
.e284	 b0 03		bcs $e289	        bcs  p2
.e286	 4c 02 e2	jmp $e202	        jmp  break      ; should not be needed
.e289					p2
.e289	 18		clc		        clc
.e28a	 65 d7		adc $d7		        adc  relptr
.e28c	 90 03		bcc $e291	        bcc  p30
.e28e	 69 01		adc #$01	        adc  #1
.e290	 38		sec		        sec
.e291					p30
.e291	 20 09 e0	jsr $e009	        jsr  nxout      ; set nr
.e294	 4c 38 e1	jmp $e138	        jmp  rd15
.e297	 a9 51		lda #$51	        lda  #recovf
.e299	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.e29c					posbuf
.e29c	 a5 94		lda $94		        lda  dirbuf
.e29e	 85 89		sta $89		        sta  r3
.e2a0	 a5 95		lda $95		        lda  dirbuf+1
.e2a2	 85 8a		sta $8a		        sta  r4
.e2a4	 20 d0 e2	jsr $e2d0	        jsr  bhere      ; is buffer in?
.e2a7	 d0 01		bne $e2aa	        bne  p10        ; yes!
.e2a9	 60		rts		        rts
.e2aa					p10
.e2aa	 20 f1 dd	jsr $ddf1	        jsr  scrub      ; clean buffer
.e2ad	 20 0c de	jsr $de0c	        jsr  getlnk
.e2b0	 a5 80		lda $80		        lda  track
.e2b2	 f0 0e		beq $e2c2	        beq  p80
.e2b4	 20 d3 e2	jsr $e2d3	        jsr  bhere2
.e2b7	 d0 06		bne $e2bf	        bne  p75
.e2b9	 20 1e cf	jsr $cf1e	        jsr  dblbuf
.e2bc	 4c da d2	jmp $d2da	        jmp  freiac
.e2bf					p75
.e2bf	 20 da d2	jsr $d2da	        jsr  freiac
.e2c2					p80
.e2c2	 a0 00		ldy #$00	        ldy  #0         ; get proper block
.e2c4	 b1 89		lda ($89),y	        lda  (r3),y
.e2c6	 85 80		sta $80		        sta  track
.e2c8	 c8		iny		        iny
.e2c9	 b1 89		lda ($89),y	        lda  (r3),y
.e2cb	 85 81		sta $81		        sta  sector
.e2cd	 4c af d0	jmp $d0af	        jmp  strdbl     ; get next block, too.
.e2d0					bhere
.e2d0	 20 3e de	jsr $de3e	        jsr  gethdr     ; get the header
.e2d3					bhere2
.e2d3	 a0 00		ldy #$00	        ldy  #0
.e2d5	 b1 89		lda ($89),y	        lda  (r3),y
.e2d7	 c5 80		cmp $80		        cmp  track
.e2d9	 f0 01		beq $e2dc	        beq  bh10       ; test sector, too.
.e2db	 60		rts		        rts
.e2dc					bh10
.e2dc	 c8		iny		        iny
.e2dd	 b1 89		lda ($89),y	        lda  (r3),y
.e2df	 c5 81		cmp $81		        cmp  sector     ; set .z
.e2e1	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "nulbuf.asm"

;******  Processing file "nulbuf.asm"

.e2e2					nulbuf
.e2e2	 20 2b de	jsr $de2b	        jsr  set00      ; set indirect ptr
.e2e5	 a0 02		ldy #$02	        ldy  #2
.e2e7	 a9 00		lda #$00	        lda  #0
.e2e9					nb10
.e2e9	 91 94		sta ($94),y	        sta  (dirbuf),y ; clear buffer
.e2eb	 c8		iny		        iny
.e2ec	 d0 fb		bne $e2e9	        bne  nb10
.e2ee	 20 04 e3	jsr $e304	        jsr  addnr      ; advance nr
.e2f1					nb20
.e2f1	 95 c1		sta $c1,x	        sta  nr,x
.e2f3	 a8		tay		        tay
.e2f4	 a9 ff		lda #$ff	        lda  #$ff
.e2f6	 91 94		sta ($94),y	        sta  (dirbuf),y ; init record w/ cr
.e2f8	 20 04 e3	jsr $e304	        jsr  addnr
.e2fb	 90 f4		bcc $e2f1	        bcc  nb20       ; not done
.e2fd	 d0 04		bne $e303	        bne  nb30
.e2ff	 a9 00		lda #$00	        lda  #0
.e301	 95 c1		sta $c1,x	        sta  nr,x
.e303					nb30
.e303	 60		rts		        rts
.e304					addnr
.e304	 a6 82		ldx $82		        ldx  lindx
.e306	 b5 c1		lda $c1,x	        lda  nr,x
.e308	 38		sec		        sec
.e309	 f0 0d		beq $e318	        beq  an05
.e30b	 18		clc		        clc
.e30c	 75 c7		adc $c7,x	        adc  rs,x
.e30e	 90 0b		bcc $e31b	        bcc  an10
.e310	 d0 06		bne $e318	        bne  an05
.e312	 a9 02		lda #$02	        lda  #2
.e314	 2c cc fe	bit $fecc	        bit  er00
.e317	 60		rts		        rts
.e318					an05
.e318	 69 01		adc #$01	        adc  #1         ; adjust for link
.e31a	 38		sec		        sec
.e31b					an10
.e31b	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "addrel.asm"

;******  Processing file "addrel.asm"

.e31c					addrel
.e31c	 20 d3 d1	jsr $d1d3	        jsr  setdrn
.e31f	 20 cb e1	jsr $e1cb	        jsr  ssend      ; set up end of file
.e322	 20 9c e2	jsr $e29c	        jsr  posbuf
.e325	 20 7b cf	jsr $cf7b	        jsr  dbset
.e328	 a5 d6		lda $d6		        lda  ssind
.e32a	 85 87		sta $87		        sta  r1         ; save ss index
.e32c	 a5 d5		lda $d5		        lda  ssnum
.e32e	 85 86		sta $86		        sta  r0         ; save ss number
.e330	 a9 00		lda #$00	        lda  #0
.e332	 85 88		sta $88		        sta  r2         ; clear flag for one block
.e334	 a9 00		lda #$00	        lda  #0         ; clear for calculation...
.e336	 85 d4		sta $d4		        sta  recptr     ; ...to 1st byte in record
.e338	 20 0e ce	jsr $ce0e	        jsr  fndrel     ; calc ss ptrs
.e33b					addr1
.e33b	 20 4d ef	jsr $ef4d	        jsr  numfre     ; calc available...
.e33e	 a4 82		ldy $82		        ldy  lindx      ; record span?
.e340	 b6 c7		ldx $c7,y	        ldx  rs,y
.e342	 ca		dex		        dex
.e343	 8a		txa		        txa
.e344	 18		clc		        clc
.e345	 65 d7		adc $d7		        adc  relptr
.e347	 90 0c		bcc $e355	        bcc  ar10       ; no span
.e349	 e6 d6		inc $d6		        inc  ssind      ; inc ss ptrs & check
.e34b	 e6 d6		inc $d6		        inc  ssind      ; inc ss ptrs & check
.e34d	 d0 06		bne $e355	        bne  ar10
.e34f	 e6 d5		inc $d5		        inc  ssnum
.e351	 a9 10		lda #$10	        lda  #ssioff
.e353	 85 d6		sta $d6		        sta  ssind
.e355					ar10
.e355	 a5 87		lda $87		        lda  r1
.e357	 18		clc		        clc
.e358	 69 02		adc #$02	        adc  #2
.e35a	 20 e9 de	jsr $dee9	        jsr  setssp
.e35d	 a5 d5		lda $d5		        lda  ssnum
.e35f	 c9 06		cmp #$06	        cmp  #nssl
.e361	 90 05		bcc $e368	        bcc  ar25       ; valid range
.e363					ar20
.e363	 a9 52		lda #$52	        lda  #bigfil
.e365	 20 c8 c1	jsr $c1c8	        jsr  cmderr     ; too many ss's
.e368					ar25
.e368	 a5 d6		lda $d6		        lda  ssind      ; calc # blocks needed...
.e36a	 38		sec		        sec     	; ...& check against avail.
.e36b	 e5 87		sbc $87		        sbc  r1
.e36d	 b0 03		bcs $e372	        bcs  ar30
.e36f	 e9 0f		sbc #$0f	        sbc  #ssioff-1
.e371	 18		clc		        clc
.e372					ar30
.e372	 85 72		sta $72		        sta  t3         ; # ss indices
.e374	 a5 d5		lda $d5		        lda  ssnum
.e376	 e5 86		sbc $86		        sbc  r0
.e378	 85 73		sta $73		        sta  t4         ; # ss needed
.e37a	 a2 00		ldx #$00	        ldx  #0         ; clear accum.
.e37c	 86 70		stx $70		        stx  t1
.e37e	 86 71		stx $71		        stx  t2
.e380	 aa		tax		        tax     	; .x=# ss
.e381	 20 51 df	jsr $df51	        jsr  sscalc     ; calc # of blocks needed
.e384	 a5 71		lda $71		        lda  t2
.e386	 d0 07		bne $e38f	        bne  ar35
.e388	 a6 70		ldx $70		        ldx  t1
.e38a	 ca		dex		        dex
.e38b	 d0 02		bne $e38f	        bne  ar35
.e38d	 e6 88		inc $88		        inc  r2
.e38f					ar35
.e38f	 cd 73 02	cmp $0273	        cmp  nbtemp+1
.e392	 90 09		bcc $e39d	        bcc  ar40       ; ok!!
.e394	 d0 cd		bne $e363	        bne  ar20
.e396	 ad 72 02	lda $0272	        lda  nbtemp
.e399	 c5 70		cmp $70		        cmp  t1
.e39b	 90 c6		bcc $e363	        bcc  ar20       ; not enuf blocks
.e39d					ar40
.e39d	 a9 01		lda #$01	        lda  #1
.e39f	 20 f6 d4	jsr $d4f6	        jsr  drdbyt     ; look at sector link
.e3a2	 18		clc		        clc
.e3a3	 69 01		adc #$01	        adc  #1         ; +1 is nr
.e3a5	 a6 82		ldx $82		        ldx  lindx
.e3a7	 95 c1		sta $c1,x	        sta  nr,x
.e3a9	 20 1e f1	jsr $f11e	        jsr  nxtts      ; get next block...
.e3ac	 20 fd dd	jsr $ddfd	        jsr  setlnk     ; ...& set link.
.e3af	 a5 88		lda $88		        lda  r2
.e3b1	 d0 15		bne $e3c8	        bne  ar50       ; add one block
.e3b3	 20 5e de	jsr $de5e	        jsr  wrtout     ; write current last rec
.e3b6					ar45
.e3b6	 20 1e cf	jsr $cf1e	        jsr  dblbuf     ; switch bufs
.e3b9	 20 d0 d6	jsr $d6d0	        jsr  sethdr     ; set hdr from t & s
.e3bc	 20 1e f1	jsr $f11e	        jsr  nxtts      ; get another
.e3bf	 20 fd dd	jsr $ddfd	        jsr  setlnk     ; set up link
.e3c2	 20 e2 e2	jsr $e2e2	        jsr  nulbuf     ; clean it out
.e3c5	 4c d4 e3	jmp $e3d4	        jmp  ar55
.e3c8					ar50
.e3c8	 20 1e cf	jsr $cf1e	        jsr  dblbuf     ; switch bufs
.e3cb	 20 d0 d6	jsr $d6d0	        jsr  sethdr     ; set hdr from t & s
.e3ce	 20 e2 e2	jsr $e2e2	        jsr  nulbuf     ; clean buffer
.e3d1	 20 19 de	jsr $de19	        jsr  nullnk     ; last block =0,lstchr
.e3d4					ar55
.e3d4	 20 5e de	jsr $de5e	        jsr  wrtout     ; write buffer
.e3d7	 20 0c de	jsr $de0c	        jsr  getlnk     ; get t&s from link
.e3da	 a5 80		lda $80		        lda  track
.e3dc	 48		pha		        pha     	; save 'em
.e3dd	 a5 81		lda $81		        lda  sector
.e3df	 48		pha		        pha
.e3e0	 20 3e de	jsr $de3e	        jsr  gethdr     ; now get hdr t&s
.e3e3	 a5 81		lda $81		        lda  sector
.e3e5	 48		pha		        pha     	; save 'em
.e3e6	 a5 80		lda $80		        lda  track
.e3e8	 48		pha		        pha
.e3e9	 20 45 df	jsr $df45	        jsr  gsspnt     ; check ss ptr
.e3ec	 aa		tax		        tax
.e3ed	 d0 0a		bne $e3f9	        bne  ar60
.e3ef	 20 4e e4	jsr $e44e	        jsr  newss      ; need another ss
.e3f2	 a9 10		lda #$10	        lda  #ssioff
.e3f4	 20 e9 de	jsr $dee9	        jsr  setssp     ; .a=bt val
.e3f7	 e6 86		inc $86		        inc  r0         ; advance ss count
.e3f9					ar60
.e3f9	 68		pla		        pla
.e3fa	 20 8d dd	jsr $dd8d	        jsr  putss      ; record t&s...
.e3fd	 68		pla		        pla
.e3fe	 20 8d dd	jsr $dd8d	        jsr  putss      ; ...in ss.
.e401	 68		pla		        pla     	; get t&s from link
.e402	 85 81		sta $81		        sta  sector
.e404	 68		pla		        pla
.e405	 85 80		sta $80		        sta  track
.e407	 f0 0f		beq $e418	        beq  ar65       ; t=0: that's all!!
.e409	 a5 86		lda $86		        lda  r0
.e40b	 c5 d5		cmp $d5		        cmp  ssnum
.e40d	 d0 a7		bne $e3b6	        bne  ar45       ; not even done yet
.e40f	 20 45 df	jsr $df45	        jsr  gsspnt
.e412	 c5 d6		cmp $d6		        cmp  ssind
.e414	 90 a0		bcc $e3b6	        bcc  ar45       ; almost done
.e416	 f0 b0		beq $e3c8	        beq  ar50       ; one more block left
.e418					ar65
.e418	 20 45 df	jsr $df45	        jsr  gsspnt
.e41b	 48		pha		        pha
.e41c	 a9 00		lda #$00	        lda  #0
.e41e	 20 dc de	jsr $dedc	        jsr  ssdir
.e421	 a9 00		lda #$00	        lda  #0
.e423	 a8		tay		        tay
.e424	 91 94		sta ($94),y	        sta  (dirbuf),y
.e426	 c8		iny		        iny
.e427	 68		pla		        pla
.e428	 38		sec		        sec
.e429	 e9 01		sbc #$01	        sbc  #1
.e42b	 91 94		sta ($94),y	        sta  (dirbuf),y
.e42d	 20 6c de	jsr $de6c	        jsr  wrtss      ; write ss
.e430	 20 99 d5	jsr $d599	        jsr  watjob
.e433	 20 f4 ee	jsr $eef4	        jsr  mapout
.e436	 20 0e ce	jsr $ce0e	        jsr  fndrel
.e439	 20 1e cf	jsr $cf1e	        jsr  dblbuf     ; get back to leading buffer
.e43c	 20 f8 de	jsr $def8	        jsr  sspos
.e43f	 70 03		bvs $e444	        bvs  ar70
.e441	 4c 75 e2	jmp $e275	        jmp  positn
.e444					ar70
.e444	 a9 80		lda #$80	        lda  #lrf
.e446	 20 97 dd	jsr $dd97	        jsr  setflg
.e449	 a9 50		lda #$50	        lda  #norec
.e44b	 20 c8 c1	jsr $c1c8	        jsr  cmderr

;******  Return to file "serlib.asm"

						.include "newss.asm"

;******  Processing file "newss.asm"

.e44e					newss
.e44e	 20 1e f1	jsr $f11e	        jsr  nxtts      ; get t&s based on hdr
.e451	 20 1e cf	jsr $cf1e	        jsr  dblbuf     ; use inactive buffer
.e454	 20 f1 dd	jsr $ddf1	        jsr  scrub
.e457	 20 93 df	jsr $df93	        jsr  getact
.e45a	 48		pha		        pha
.e45b	 20 c1 de	jsr $dec1	        jsr  clrbuf
.e45e	 a6 82		ldx $82		        ldx  lindx
.e460	 b5 cd		lda $cd,x	        lda  ss,x       ; set regs for transfer
.e462	 a8		tay		        tay
.e463	 68		pla		        pla
.e464	 aa		tax		        tax
.e465	 a9 10		lda #$10	        lda  #ssioff    ; # of chars
.e467	 20 a5 de	jsr $dea5	        jsr  b0tob0     ; transfer at buf(0)
.e46a	 a9 00		lda #$00	        lda  #0
.e46c	 20 dc de	jsr $dedc	        jsr  ssdir
.e46f	 a0 02		ldy #$02	        ldy  #2
.e471	 b1 94		lda ($94),y	        lda  (dirbuf),y ; get ss #
.e473	 48		pha		        pha
.e474	 a9 00		lda #$00	        lda  #0
.e476	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.e479	 68		pla		        pla
.e47a	 18		clc		        clc
.e47b	 69 01		adc #$01	        adc  #1
.e47d	 91 94		sta ($94),y	        sta  (dirbuf),y ; put ss # in new ss
.e47f	 0a		asl a		        asl  a
.e480	 69 04		adc #$04	        adc  #4
.e482	 85 89		sta $89		        sta  r3         ; save position
.e484	 a8		tay		        tay
.e485	 38		sec		        sec
.e486	 e9 02		sbc #$02	        sbc  #2
.e488	 85 8a		sta $8a		        sta  r4
.e48a	 a5 80		lda $80		        lda  track
.e48c	 85 87		sta $87		        sta  r1         ; save for ss update
.e48e	 91 94		sta ($94),y	        sta  (dirbuf),y ; put track in ss
.e490	 c8		iny		        iny
.e491	 a5 81		lda $81		        lda  sector
.e493	 85 88		sta $88		        sta  r2         ; save for ss update
.e495	 91 94		sta ($94),y	        sta  (dirbuf),y ; put sector in ss
.e497	 a0 00		ldy #$00	        ldy  #0
.e499	 98		tya		        tya
.e49a	 91 94		sta ($94),y	        sta  (dirbuf),y ; null link
.e49c	 c8		iny		        iny
.e49d	 a9 11		lda #$11	        lda  #ssioff+1  ; ptr to last byte
.e49f	 91 94		sta ($94),y	        sta  (dirbuf),y
.e4a1	 a9 10		lda #$10	        lda  #ssioff
.e4a3	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.e4a6	 20 50 de	jsr $de50	        jsr  wrtab
.e4a9	 20 99 d5	jsr $d599	        jsr  watjob
.e4ac					ns20
.e4ac	 a6 82		ldx $82		        ldx  lindx
.e4ae	 b5 cd		lda $cd,x	        lda  ss,x       ; get ss buffer #
.e4b0	 48		pha		        pha
.e4b1	 20 9e df	jsr $df9e	        jsr  gaflgs
.e4b4	 a6 82		ldx $82		        ldx  lindx
.e4b6	 95 cd		sta $cd,x	        sta  ss,x       ; swap act-buf & ss
.e4b8	 68		pla		        pla
.e4b9	 ae 57 02	ldx $0257	        ldx  lbused
.e4bc	 95 a7		sta $a7,x	        sta  buf0,x
.e4be	 a9 00		lda #$00	        lda  #0
.e4c0	 20 c8 d4	jsr $d4c8	        jsr  setpnt     ; set link to new ss
.e4c3	 a0 00		ldy #$00	        ldy  #0
.e4c5	 a5 80		lda $80		        lda  track
.e4c7	 91 94		sta ($94),y	        sta  (dirbuf),y
.e4c9	 c8		iny		        iny
.e4ca	 a5 81		lda $81		        lda  sector
.e4cc	 91 94		sta ($94),y	        sta  (dirbuf),y
.e4ce	 4c de e4	jmp $e4de	        jmp  ns50
.e4d1					ns40
.e4d1	 20 93 df	jsr $df93	        jsr  getact
.e4d4	 a6 82		ldx $82		        ldx  lindx
.e4d6	 20 1b df	jsr $df1b	        jsr  ibrd       ; read next ss
.e4d9	 a9 00		lda #$00	        lda  #0
.e4db	 20 c8 d4	jsr $d4c8	        jsr  setpnt     ; ptr=0
.e4de					ns50
.e4de	 c6 8a		dec $8a		        dec  r4
.e4e0	 c6 8a		dec $8a		        dec  r4
.e4e2	 a4 89		ldy $89		        ldy  r3         ; get new ss link ptr
.e4e4	 a5 87		lda $87		        lda  r1
.e4e6	 91 94		sta ($94),y	        sta  (dirbuf),y ; put track in
.e4e8	 c8		iny		        iny
.e4e9	 a5 88		lda $88		        lda  r2
.e4eb	 91 94		sta ($94),y	        sta  (dirbuf),y ; put sector in
.e4ed	 20 5e de	jsr $de5e	        jsr  wrtout     ; write it back...
.e4f0	 20 99 d5	jsr $d599	        jsr  watjob     ; ...& wait
.e4f3	 a4 8a		ldy $8a		        ldy  r4
.e4f5	 c0 03		cpy #$03	        cpy  #3
.e4f7	 b0 d8		bcs $e4d1	        bcs  ns40       ; more ss to update!
.e4f9	 4c 1e cf	jmp $cf1e	        jmp  dblbuf     ; reset active buffer

;******  Return to file "serlib.asm"

						.include "erproc.asm"

;******  Processing file "erproc.asm"

=0030					badsyn   =$30
=0031					badcmd   =$31
=0032					longln   =$32
=0033					badfn    =$33
=0034					nofile   =$34
=0039					nocfil   =$39
=0050					norec    =$50
=0051					recovf   =$51
=0052					bigfil   =$52
=0060					filopn   =$60
=0061					filnop   =$61
=0062					flntfd   =$62
=0063					flexst   =$63
=0064					mistyp   =$64
=0065					noblk    =$65
=0066					badts    =$66
=0067					systs    =$67
=0070					nochnl   =$70
=0071					direrr   =$71
=0072					dskful   =$72
=0073					cbmv2    =$73
=0074					nodriv   =$74
.e4fc					errtab

>e4fc	 00 a0 4f cb              		.text    0,$a0,'O',$cb
>e500	 20 21 22 23 24 27        		.text    $20,$21,$22,$23,$24,$27
>e506	 d2 45 41 44 89           		.text    $d2,'EAD',$89
>e50b	 52 83 20 54 4f 4f 20 4c 		.text    $52,$83,' TOO LARG',$c5
>e513	 41 52 47 c5 
>e517	 50 8b 06 20 50 52 45 53 		.text    $50,$8b,6,' PRESEN',$d4
>e51f	 45 4e d4 
>e522	 51 cf 56 45 52 46 4c 4f 		.text    $51,$cf,'VERFLOW '
>e52a	 57 20 
>e52c	 49 4e 8b                 		.text    'IN',$8b
>e52f	 25 28 8a 89              		.text    $25,$28,$8a,$89
>e533	 26 8a 20 50 52 4f 54 45 		.text    $26,$8a,' PROTECT O',$ce
>e53b	 43 54 20 4f ce 
>e540	 29 88 20 49 44 85        		.text    $29,$88,' ID',$85
>e546	 30 31 32 33 34           		.text    $30,$31,$32,$33,$34
>e54b	 d3 59 4e 54 41 58 89     		.text    $d3,'YNTAX',$89
>e552	 60 8a 03 84              		.text    $60,$8a,3,$84
>e556	 63 83 20 45 58 49 53 54 		.text    $63,$83,' EXIST',$d3
>e55e	 d3 
>e55f	 64 83 20 54 59 50 45 85  		.text    $64,$83,' TYPE',$85
>e567	 65 ce 4f 20 42 4c 4f 43 		.text    $65,$ce,'O BLOC',$cb
>e56f	 cb 
>e570	 66 67 c9 4c 4c 45 47 41 		.text   $66,$67,$c9,'LLEGAL TRACK'
>e578	 4c 20 54 52 41 43 4b 
>e57f	 20 4f 52 20 53 45 43 54 		.text   ' OR SECTO',$d2
>e587	 4f d2 
>e589	 61 83 06 84              		.text    $61,$83,6,$84
>e58d	 39 62 83 06 87           		.text    $39,$62,$83,6,$87
>e592	 01 83 53 20 53 43 52 41 		.text    1,$83,'S SCRATCHE',$c4
>e59a	 54 43 48 45 c4 
>e59f	 70 ce 4f 20 43 48 41 4e 		.text    $70,$ce,'O CHANNE',$cc
>e5a7	 4e 45 cc 
>e5aa	 71 c4 49 52 89           		.text    $71,$c4,'IR',$89
>e5af	 72 88 20 46 55 4c cc     		.text    $72,$88,' FUL',$cc
>e5b6	 73 c3 42 4d 20 44 4f 53 		.text   $73,$c3,'BM DOS V3.0 157',$b1
>e5be	 20 56 33 2e 30 20 31 35 
>e5c6	 37 b1 
>e5c8	 74 c4 52 49 56 45 06 20 		.text   $74,$c4,'RIVE',6,' READ',$d9
>e5d0	 52 45 41 44 d9 
>e5d5	 09 c5 52 52 4f d2        		.text    9,$c5,'RRO',$d2
>e5db	 0a d7 52 49 54 c5        		.text    $a,$d7,'RIT',$c5
>e5e1	 03 c6 49 4c c5           		.text    3,$c6,'IL',$c5
>e5e6	 04 cf 50 45 ce           		.text    4,$cf,'PE',$ce
>e5eb	 05 cd 49 53 4d 41 54 43 		.text    5,$cd,'ISMATC',$c8
>e5f3	 c8 
>e5f4	 06 ce 4f d4              		.text    6,$ce,'O',$d4
>e5f8	 07 c6 4f 55 4e c4        		.text    7,$c6,'OUN',$c4
>e5fe	 08 c4 49 53 cb           		.text    8,$c4,'IS',$cb
>e603	 0b d2 45 43 4f 52 c4     		.text   $b,$d2,'ECOR',$c4
=e60a					etend    =*

.e60a					error
.e60a	 4c b9 a9	jmp $a9b9		jmp  ptch46	; *** rom ds 03/31/85 ***
.e60d	 8a		txa		rtch46  txa
.e60e	 0a		asl a			asl  a
.e60f	 aa		tax			tax
.e610	 b5 06		lda $06,x		lda  hdrs,x     ; 4/12********* track,sector
.e612	 85 80		sta $80			sta  track
.e614	 b5 07		lda $07,x		lda  hdrs+1,x   ; 4/12*********
.e616	 85 81		sta $81			sta  sector
.e618	 68		pla			pla
.e619	 29 0f		and #$0f		and  #$f        ; convert controller...
.e61b	 f0 08		beq $e625		beq  err1       ; ...errors to dos errors
.e61d	 c9 0f		cmp #$0f		cmp  #$f        ; check nodrive error
.e61f	 d0 06		bne $e627		bne  err2
.e621	 a9 74		lda #$74		lda  #nodriv
.e623	 d0 08		bne $e62d		bne  err3       ; bra
.e625					err1
.e625	 a9 06		lda #$06		lda  #6         ; code=16-->14
.e627	 09 20		ora #$20	err2    ora  #$20
.e629	 aa		tax			tax
.e62a	 ca		dex			dex
.e62b	 ca		dex			dex
.e62c	 8a		txa			txa
.e62d					err3
.e62d	 48		pha			pha
.e62e	 ad 2a 02	lda $022a		lda  cmdnum
.e631	 c9 00		cmp #$00		cmp  #val
.e633	 d0 0f		bne $e644		bne  err4
.e635	 a9 ff		lda #$ff		lda  #$ff
.e637	 8d 2a 02	sta $022a		sta  cmdnum
.e63a	 68		pla			pla
.e63b	 20 c7 e6	jsr $e6c7		jsr  errmsg
.e63e	 20 42 d0	jsr $d042		jsr  initdr     ; init for validate
.e641	 4c 48 e6	jmp $e648		jmp  cmder3
.e644					err4
.e644	 68		pla			pla
.e645					cmder2
.e645	 20 c7 e6	jsr $e6c7		jsr  errmsg
.e648					cmder3
.e648	 20 bd c1	jsr $c1bd		jsr  clrcb      ; clear cmdbuf
.e64b	 a9 00		lda #$00		lda  #0
.e64d	 8d f9 02	sta $02f9		sta  wbam       ; clear after error
.e650	 20 2c c1	jsr $c12c		jsr  erron      ; set error led
.e653	 20 da d4	jsr $d4da		jsr  freich     ; free internal channel
.e656	 a9 00		lda #$00		lda  #0         ; clear pointers
.e658	 85 a3		sta $a3			sta  buftab+cbptr
.e65a	 a2 45		ldx #$45		ldx  #topwrt
.e65c	 9a		txs			txs     	;  purge stack
.e65d	 a5 84		lda $84			lda  orgsa
.e65f	 29 0f		and #$0f		and  #$f
.e661	 85 83		sta $83			sta  sa
.e663	 c9 0f		cmp #$0f		cmp  #$f
.e665	 f0 31		beq $e698		beq  err10
.e667	 78		sei			sei
.e668	 a5 79		lda $79			lda  lsnact
.e66a	 d0 1c		bne $e688		bne  lsnerr
.e66c	 a5 7a		lda $7a			lda  tlkact
.e66e	 d0 10		bne $e680		bne  tlkerr
.e670	 a6 83		ldx $83			ldx  sa
.e672	 bd 2b 02	lda $022b,x		lda  lintab,x
.e675	 c9 ff		cmp #$ff		cmp  #$ff
.e677	 f0 1f		beq $e698		beq  err10
.e679	 29 0f		and #$0f		and  #$f
.e67b	 85 82		sta $82			sta  lindx
.e67d	 4c 8e e6	jmp $e68e		jmp  tlerr
.e680					tlkerr
.e680	 20 eb d0	jsr $d0eb		jsr  fndrch

>e683	 ea ea ea                 		.byte  $ea,$ea,$ea      ; fill in 'jsr'

.e686	 d0 06		bne $e68e		bne  tlerr      	; finish
.e688					lsnerr
.e688	 20 07 d1	jsr $d107		jsr  fndwch

>e68b	 ea ea ea                 		.byte  $ea,$ea,$ea      ; fill in 'jsr'

.e68e					tlerr
.e68e	 20 25 d1	jsr $d125		jsr  typfil
.e691	 c9 04		cmp #$04		cmp  #reltyp
.e693	 b0 03		bcs $e698		bcs  err10
.e695	 20 27 d2	jsr $d227		jsr  frechn
.e698					err10
.e698	 4c 6b 83	jmp $836b		jmp  xidle		; *** rom ds 01/22/84 ***
.e69b	 aa		tax		hexdec  tax
.e69c	 4c fc aa	jmp $aafc		jmp  ptch67	; *** rom ds 05/15/86 ***
.e69f	 e0 00		cpx #$00	hex0    cpx  #0
.e6a1	 f0 07		beq $e6aa		beq  hex5
.e6a3	 18		clc			clc
.e6a4	 69 01		adc #$01		adc  #1
.e6a6	 ca		dex			dex
.e6a7	 4c 9f e6	jmp $e69f		jmp  hex0
.e6aa	 d8		cld		hex5    cld
.e6ab	 aa		tax		bcddec  tax
.e6ac	 4a		lsr a			lsr  a
.e6ad	 4a		lsr a			lsr  a
.e6ae	 4a		lsr a			lsr  a
.e6af	 4a		lsr a			lsr  a
.e6b0	 20 b4 e6	jsr $e6b4		jsr  bcd2
.e6b3	 8a		txa			txa
.e6b4					bcd2
.e6b4	 29 0f		and #$0f		and  #$f
.e6b6	 09 30		ora #$30		ora  #$30
.e6b8	 91 a5		sta ($a5),y		sta  (cb+2),y
.e6ba	 c8		iny			iny
.e6bb	 60		rts			rts
.e6bc					okerr
.e6bc	 20 23 c1	jsr $c123		jsr  erroff
.e6bf	 a9 00		lda #$00		lda  #0
.e6c1					errts0
.e6c1	 a0 00		ldy #$00		ldy  #0
.e6c3	 84 80		sty $80			sty  track
.e6c5	 84 81		sty $81			sty  sector
.e6c7					errmsg
.e6c7	 a0 00		ldy #$00		ldy  #0
.e6c9	 a2 d5		ldx #$d5		ldx  #<errbuf
.e6cb	 86 a5		stx $a5			stx  cb+2
.e6cd	 a2 02		ldx #$02		ldx  #>errbuf
.e6cf	 86 a6		stx $a6			stx  cb+3
.e6d1	 20 ab e6	jsr $e6ab		jsr  bcddec     ; convert error #
.e6d4	 a9 2c		lda #$2c		lda  #','
.e6d6	 91 a5		sta ($a5),y		sta  (cb+2),y
.e6d8	 c8		iny			iny
.e6d9	 ad d5 02	lda $02d5		lda  errbuf
.e6dc	 8d 43 02	sta $0243		sta  chndat+errchn
.e6df	 8a		txa			txa     	; error # in .x
.e6e0	 20 06 e7	jsr $e706		jsr  ermove     ; move message
.e6e3	 a9 2c		lda #$2c	ermsg2  lda  #','
.e6e5	 91 a5		sta ($a5),y		sta  (cb+2),y
.e6e7	 c8		iny			iny
.e6e8	 a5 80		lda $80			lda  track
.e6ea	 20 9b e6	jsr $e69b		jsr  hexdec     ; convert track #
.e6ed	 a9 2c		lda #$2c		lda  #','
.e6ef	 91 a5		sta ($a5),y		sta  (cb+2),y
.e6f1	 c8		iny			iny
.e6f2	 a5 81		lda $81			lda  sector     ; convert sector #
.e6f4	 20 9b e6	jsr $e69b		jsr  hexdec
.e6f7	 88		dey			dey
.e6f8	 98		tya			tya
.e6f9	 18		clc			clc
.e6fa	 69 d5		adc #$d5		adc  #<errbuf   ; set last char
.e6fc	 8d 49 02	sta $0249		sta  lstchr+errchn
.e6ff	 e6 a5		inc $a5			inc  cb+2
.e701	 a9 88		lda #$88		lda  #rdytlk
.e703	 85 f7		sta $f7			sta  chnrdy+errchn
.e705	 60		rts			rts
.e706					ermove
.e706	 aa		tax			tax     	; save .a
.e707	 a5 86		lda $86			lda  r0         ; save r0,r0+1
.e709	 48		pha			pha
.e70a	 a5 87		lda $87			lda  r0+1
.e70c	 48		pha			pha
.e70d	 a9 fc		lda #$fc		lda  #<errtab   ; set pointer to table
.e70f	 85 86		sta $86			sta  r0
.e711	 a9 e4		lda #$e4		lda  #>errtab
.e713	 85 87		sta $87			sta  r0+1
.e715	 8a		txa			txa     	; restore .a
.e716	 a2 00		ldx #$00		ldx  #0         ; .x=0 for indirect
.e718					e10
.e718	 c1 86		cmp ($86,x)		cmp  (r0,x)     ; ?error # = table entry?
.e71a	 f0 21		beq $e73d		beq  e50        ; yes, send message
.e71c	 48		pha			pha     	; save error #
.e71d	 20 75 e7	jsr $e775		jsr  eadv2      ; check & advance ptr
.e720	 90 05		bcc $e727		bcc  e30        ; more #'s to check
.e722					e20
.e722	 20 75 e7	jsr $e775		jsr  eadv2      ; advance past this message
.e725	 90 fb		bcc $e722		bcc  e20
.e727					e30
.e727	 a5 87		lda $87			lda  r0+1       ; check ptr
.e729	 c9 e6		cmp #$e6		cmp  #>etend
.e72b	 90 08		bcc $e735		bcc  e40        ; <, continue
.e72d	 d0 0a		bne $e739		bne  e45        ; >, quit
.e72f	 a9 0a		lda #$0a		lda  #<etend
.e731	 c5 86		cmp $86			cmp  r0
.e733	 90 04		bcc $e739		bcc  e45        ; past end of table
.e735					e40
.e735	 68		pla			pla     	; restore error #
.e736	 4c 18 e7	jmp $e718		jmp  e10        ; check next entry
.e739					e45
.e739	 68		pla			pla     	; pop error #
.e73a	 4c 4d e7	jmp $e74d		jmp  e90        ; go quit
.e73d					e50
.e73d	 20 67 e7	jsr $e767		jsr  eadv1
.e740	 90 fb		bcc $e73d		bcc  e50        ; advance past other #'s
.e742					e55
.e742	 20 54 e7	jsr $e754		jsr  e60
.e745	 20 67 e7	jsr $e767		jsr  eadv1
.e748	 90 f8		bcc $e742		bcc  e55
.e74a	 20 54 e7	jsr $e754		jsr  e60        ; check for token or last word
.e74d					e90
.e74d	 68		pla			pla     	; all finished
.e74e	 85 87		sta $87			sta  r0+1       ; restore r0
.e750	 68		pla			pla
.e751	 85 86		sta $86			sta  r0
.e753	 60		rts			rts
.e754					e60
.e754	 c9 20		cmp #$20		cmp  #$20       ; (max token #)+1
.e756	 b0 0b		bcs $e763		bcs  e70        ; not a token
.e758	 aa		tax			tax
.e759	 a9 20		lda #$20		lda  #$20       ; implied leading space
.e75b	 91 a5		sta ($a5),y		sta  (cb+2),y
.e75d	 c8		iny			iny
.e75e	 8a		txa			txa     	; restore token #
.e75f	 20 06 e7	jsr $e706		jsr  ermove     ; add token word to message
.e762	 60		rts			rts
.e763					e70
.e763	 91 a5		sta ($a5),y		sta  (cb+2),y   ; put char in message
.e765	 c8		iny			iny
.e766	 60		rts			rts
.e767					eadv1
.e767	 e6 86		inc $86			inc  r0         ; advance ptr
.e769	 d0 02		bne $e76d		bne  ea10
.e76b	 e6 87		inc $87			inc  r0+1
.e76d					ea10
.e76d	 a1 86		lda ($86,x)		lda  (r0,x)     ; get current entry
.e76f	 0a		asl a			asl  a          ; .c=1 is end or beginning
.e770	 a1 86		lda ($86,x)		lda  (r0,x)
.e772	 29 7f		and #$7f		and  #$7f       ; mask off bit7
.e774	 60		rts			rts
.e775					eadv2
.e775	 20 6d e7	jsr $e76d		jsr  ea10       ; check table entry
.e778	 e6 86		inc $86			inc  r0
.e77a	 d0 02		bne $e77e		bne  ea20
.e77c	 e6 87		inc $87			inc  r0+1
.e77e					ea20
.e77e	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "utlodr.asm"

;******  Processing file "utlodr.asm"

.e77f	 60		rts			rts
.e780	 60		rts		boot	rts
.e781	 ea		nop			nop
.e782	 ea		nop			nop
.e783	 ea		nop			nop
.e784	 ea		nop			nop
.e785	 ea		nop			nop
.e786	 ea		nop			nop
.e787	 ea		nop			nop
.e788	 ea		nop			nop
.e789	 ea		nop			nop
.e78a	 ea		nop			nop
.e78b	 ea		nop			nop
.e78c	 ea		nop			nop
.e78d	 ea		nop			nop
.e78e	 ea		nop			nop
.e78f	 ea		nop			nop
.e790	 ea		nop			nop
.e791	 ea		nop			nop
.e792	 ea		nop			nop
.e793	 ea		nop			nop
.e794	 ea		nop			nop
.e795	 ea		nop			nop
.e796	 ea		nop			nop
.e797	 ea		nop			nop
.e798	 ea		nop			nop
.e799	 ea		nop			nop
.e79a	 ea		nop			nop
.e79b	 ea		nop			nop
.e79c	 ea		nop			nop
.e79d	 ea		nop			nop
.e79e	 ea		nop			nop
.e79f	 ea		nop			nop
.e7a0	 ea		nop			nop
.e7a1	 ea		nop			nop
.e7a2	 60		rts			rts
.e7a3	 4c fe a5	jmp $a5fe	utlodr  jmp  ptch18
.e7a6	 ea		nop			nop
.e7a7	 ea		nop			nop
.e7a8	 20 58 f2	jsr $f258	rtch18	jsr  killp
.e7ab	 ad 78 02	lda $0278	        lda  f2cnt
.e7ae	 48		pha		        pha     	; save file count for utility
.e7af	 a9 01		lda #$01	        lda  #1
.e7b1	 8d 78 02	sta $0278	        sta  f2cnt
.e7b4	 a9 ff		lda #$ff	        lda  #$ff       ; init firstbyte flag
.e7b6	 85 86		sta $86		        sta  r0         ; r0 is flag
.e7b8	 20 4f c4	jsr $c44f	        jsr  lookup     ; locate filename on disk
.e7bb	 ad 80 02	lda $0280	        lda  filtrk     ; check if found. err if not
.e7be	 d0 05		bne $e7c5	        bne  utld00
.e7c0	 a9 39		lda #$39	+       lda  #nocfil
.e7c2	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.e7c5	 68		pla		utld00  pla
.e7c6	 8d 78 02	sta $0278	        sta  f2cnt      ; restore file count
.e7c9	 ad 80 02	lda $0280	        lda  filtrk     ; init trk,sec for open
.e7cc	 85 80		sta $80		        sta  track
.e7ce	 ad 85 02	lda $0285	        lda  filsec
.e7d1	 85 81		sta $81		        sta  sector
.e7d3	 a9 03		lda #$03	        lda  #usrtyp    ; open sys type file(5)
.e7d5	 20 77 d4	jsr $d477	        jsr  opntyp     ; open
.e7d8	 a9 00		lda #$00	utld10  lda  #$00       ; init checksum
.e7da	 85 87		sta $87		        sta  r1         ; chksum resides in r1
.e7dc	 20 39 e8	jsr $e839	        jsr  gtabyt     ; fetch load adr lo
.e7df	 85 88		sta $88		        sta  r2
.e7e1	 20 4b e8	jsr $e84b	        jsr  addsum     ; add into checksum
.e7e4	 20 39 e8	jsr $e839	        jsr  gtabyt     ; fetch load adr hi
.e7e7	 85 89		sta $89		        sta  r3
.e7e9	 20 4b e8	jsr $e84b	        jsr  addsum
.e7ec	 a5 86		lda $86		        lda  r0         ; first byte address?
.e7ee	 f0 0a		beq $e7fa	        beq  utld20     ; br if not
.e7f0	 a5 88		lda $88		        lda  r2         ; sav this adr
.e7f2	 48		pha		        pha     	; lo first
.e7f3	 a5 89		lda $89		        lda  r3
.e7f5	 48		pha		        pha     	; hi next
.e7f6	 a9 00		lda #$00	        lda  #$00       ; clear flag
.e7f8	 85 86		sta $86		        sta  r0         ; first byte flag
.e7fa	 20 39 e8	jsr $e839	utld20  jsr  gtabyt     ; fetch data byte count
.e7fd	 85 8a		sta $8a		        sta  r4         ; save in r4
.e7ff	 20 4b e8	jsr $e84b	        jsr  addsum     ; add into checksum
.e802	 20 39 e8	jsr $e839	utld30  jsr  gtabyt     ; fetch data byt
.e805	 a0 00		ldy #$00	        ldy  #$00       ; init index
.e807	 91 88		sta ($88),y	        sta  (r2),y     ; store byte
.e809	 20 4b e8	jsr $e84b	        jsr  addsum     ; add into checksum
.e80c	 a5 88		lda $88		        lda  r2         ; pointer:=pointer+1
.e80e	 18		clc		        clc
.e80f	 69 01		adc #$01	        adc  #$01
.e811	 85 88		sta $88		        sta  r2
.e813	 90 02		bcc $e817	        bcc  utld35
.e815	 e6 89		inc $89		        inc  r3         ; add in carry
.e817	 c6 8a		dec $8a		utld35  dec  r4         ; update byte counter
.e819	 d0 e7		bne $e802	        bne  utld30     ; if nonzero, continue
.e81b	 20 35 ca	jsr $ca35	        jsr  gibyte     ; get byte without chk for eoi
.e81e	 a5 85		lda $85		        lda  data
.e820	 c5 87		cmp $87		        cmp  r1         ; last byte was chksum
.e822	 f0 08		beq $e82c	        beq  utld50     ; ...everything ok
.e824	 20 3e de	jsr $de3e	        jsr  gethdr
.e827	 a9 50		lda #$50	        lda  #norec     ; show record overflow
.e829	 20 45 e6	jsr $e645	        jsr  cmder2     ; and leave to err exit
.e82c	 a5 f8		lda $f8		utld50  lda  eoiflg     ; check for eof
.e82e	 d0 a8		bne $e7d8	        bne  utld10     ; if nonzero, not done
.e830	 68		pla		        pla     	; xfer cntrl to
.e831	 85 89		sta $89		        sta  r3         ; 1st byte addr.
.e833	 68		pla		        pla
.e834	 85 88		sta $88		        sta  r2
.e836	 6c 88 00	jmp ($0088)	        jmp  (r2)
.e839	 20 35 ca	jsr $ca35	gtabyt  jsr  gibyte     ; fetch a byte
.e83c	 a5 f8		lda $f8		        lda  eoiflg     ; check if eof exists
.e83e	 d0 08		bne $e848	        bne  gtabye     ; ok if nonzero
.e840	 20 3e de	jsr $de3e	        jsr  gethdr
.e843	 a9 51		lda #$51	        lda  #recovf    ; record size error
.e845	 20 45 e6	jsr $e645	        jsr  cmder2     ; error routine
.e848	 a5 85		lda $85		gtabye  lda  data
.e84a	 60		rts		        rts
.e84b	 18		clc		addsum  clc
.e84c	 65 87		adc $87		        adc  r1         ; .a=.a+r1
.e84e	 69 00		adc #$00	        adc  #$00       ; .a=.a+carry
.e850	 85 87		sta $87		        sta  r1         ; save new checksum
.e852	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "sieee.asm"

;******  Processing file "sieee.asm"

.e853	 ad 01 18	lda $1801	atnirq  lda  pa1
.e856	 a9 01		lda #$01	        lda  #1
.e858	 85 7c		sta $7c		        sta  atnpnd
.e85a	 60		rts		        rts
.e85b	 78		sei		atnsrv  sei
.e85c	 a9 00		lda #$00		lda  #0
.e85e	 85 7c		sta $7c			sta  atnpnd
.e860	 85 79		sta $79			sta  lsnact
.e862	 85 7a		sta $7a			sta  tlkact
.e864	 a2 45		ldx #$45		ldx  #topwrt    ; reset stack
.e866	 9a		txs			txs
.e867	 a9 80		lda #$80		lda  #$80       ; set atn mode flag for acpt routine
.e869	 85 f8		sta $f8			sta  eoiflg     ; reset eoi flag to non-eoi state
.e86b	 85 7d		sta $7d			sta  atnact
.e86d	 20 b7 e9	jsr $e9b7		jsr  clkhi
.e870	 20 a5 e9	jsr $e9a5		jsr  datlow     ; set data line low as response
.e873	 ad 00 18	lda $1800		lda  pb         ; set atn ack to release data line
.e876	 09 10		ora #$10		ora  #atna
.e878	 8d 00 18	sta $1800		sta  pb
.e87b	 ad 00 18	lda $1800	-       lda  pb         ; test atn still here
.e87e	 10 57		bpl $e8d7		bpl  atns20     ; gone !
.e880	 29 04		and #$04		and  #clkin     ; clock still low
.e882	 d0 f7		bne $e87b		bne  -
.e884	 20 c9 e9	jsr $e9c9	atns3   jsr  acptr      ; get a command byte
.e887	 c9 3f		cmp #$3f		cmp  #unlsn
.e889	 d0 06		bne $e891		bne  atns4
.e88b	 a9 00		lda #$00		lda  #0
.e88d	 85 79		sta $79			sta  lsnact
.e88f	 f0 71		beq $e902		beq  atns9      ; bra
.e891	 c9 5f		cmp #$5f	atns4   cmp  #untlk
.e893	 d0 06		bne $e89b		bne  atns5
.e895	 a9 00		lda #$00		lda  #0
.e897	 85 7a		sta $7a			sta  tlkact
.e899	 f0 67		beq $e902	        beq  atns9      ; jmp
.e89b	 c5 78		cmp $78		atns5   cmp  tlkadr     ; our talk address?
.e89d	 d0 0a		bne $e8a9		bne  atns7      ; nope
.e89f	 a9 01		lda #$01		lda  #1
.e8a1	 85 7a		sta $7a			sta  tlkact     ; set talk flag
.e8a3	 a9 00		lda #$00		lda  #0
.e8a5	 85 79		sta $79			sta  lsnact     ; clear listen flag
.e8a7	 f0 29		beq $e8d2		beq  atns8      ; bra
.e8a9	 c5 77		cmp $77		atns7   cmp  lsnadr     ; our listen address?
.e8ab	 d0 0a		bne $e8b7		bne  atns10     ; nope
.e8ad	 a9 01		lda #$01		lda  #1
.e8af	 85 79		sta $79			sta  lsnact     ; set listen flag
.e8b1	 a9 00		lda #$00		lda  #0
.e8b3	 85 7a		sta $7a			sta  tlkact     ; clear talk flag
.e8b5	 f0 1b		beq $e8d2		beq  atns8      ; bra
.e8b7	 aa		tax		atns10  tax             ; test if sa
.e8b8	 29 60		and #$60		and  #$60
.e8ba	 c9 60		cmp #$60		cmp  #$60       ; sa = $60 + n
.e8bc	 d0 3f		bne $e8fd		bne  atns11     ; did not get a valid command
.e8be	 8a		txa			txa             ; a sa for me
.e8bf	 85 84		sta $84			sta  orgsa
.e8c1	 29 0f		and #$0f		and  #$0f       ; strip junk
.e8c3	 85 83		sta $83			sta  sa
.e8c5	 a5 84		lda $84			lda  orgsa      ; test if close
.e8c7	 29 f0		and #$f0		and  #$f0
.e8c9	 c9 e0		cmp #$e0		cmp  #$e0
.e8cb	 d0 35		bne $e902		bne  atns9      ; no
.e8cd	 58		cli			cli
.e8ce	 20 c0 da	jsr $dac0		jsr  close      ; close the file
.e8d1	 78		sei			sei
.e8d2	 2c 00 18	bit $1800	atns8   bit  pb         ; test atn still here
.e8d5	 30 ad		bmi $e884		bmi  atns3
.e8d7	 a9 00		lda #$00	atns20  lda  #0
.e8d9	 85 7d		sta $7d			sta  atnact     ; clear atn mode
.e8db	 ad 00 18	lda $1800		lda  pb         ; atn gone, release atn ack
.e8de	 29 ef		and #$ef		and  #all-atna
.e8e0	 8d 00 18	sta $1800		sta  pb
.e8e3	 a5 79		lda $79			lda  lsnact     ; listen ?
.e8e5	 f0 06		beq $e8ed		beq  atns12
.e8e7	 20 2e ea	jsr $ea2e		jsr  listen
.e8ea	 4c 6b 83	jmp $836b		jmp  xidle
.e8ed	 a5 7a		lda $7a		atns12  lda  tlkact     ; talk?
.e8ef	 f0 09		beq $e8fa		beq  atns13
.e8f1	 20 9c e9	jsr $e99c		jsr  dathi      ; release data line
.e8f4	 20 ae e9	jsr $e9ae		jsr  clklo
.e8f7	 20 09 e9	jsr $e909		jsr  talk
.e8fa	 4c 4e ea	jmp $ea4e	atns13  jmp  ilerr      ; release all lines and go to idle
.e8fd					atns11
.e8fd	 a9 10		lda #$10		lda  #atna
.e8ff	 8d 00 18	sta $1800		sta  pb         ; kill all
.e902	 2c 00 18	bit $1800	atns9   bit  pb
.e905	 10 d0		bpl $e8d7		bpl  atns20     ; exit out same way after atn done
.e907	 30 f9		bmi $e902		bmi  atns9      ; bra
.e909					talk
.e909	 78		sei			sei             ; find if open channel
.e90a	 20 eb d0	jsr $d0eb		jsr  fndrch
.e90d	 b0 06		bcs $e915		bcs  m1         ; no one home
.e90f	 a6 82		ldx $82		m2      ldx  lindx
.e911	 b5 f2		lda $f2,x		lda  chnrdy,x
.e913	 30 01		bmi $e916		bmi  m3
.e915	 60		rts		m1      rts
.e916	 20 59 ea	jsr $ea59	m3      jsr  tstatn     ; test for atn
.e919	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.e91c	 29 01		and #$01		and  #datin
.e91e	 08		php			php
.e91f	 20 b7 e9	jsr $e9b7		jsr  clkhi      ; set clk hi
.e922	 28		plp			plp             ; see if verify error...
.e923	 f0 12		beq $e937		beq  m4         ; br,  yes...data line hi, eoi !!!!
.e925	 20 59 ea	jsr $ea59	-       jsr  tstatn     ; test for atn
.e928	 20 c0 e9	jsr $e9c0		jsr  debnc
.e92b	 29 01		and #$01		and  #datin
.e92d	 d0 f6		bne $e925		bne  -          ; wait for data high
.e92f	 a6 82		ldx $82			ldx  lindx      ; prepare to send eoi if needed
.e931	 b5 f2		lda $f2,x		lda  chnrdy,x
.e933	 29 08		and #$08		and  #eoi
.e935	 d0 14		bne $e94b		bne  m7         ; no eoi
.e937	 20 59 ea	jsr $ea59	m4      jsr  tstatn     ; test for atn
.e93a	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.e93d	 29 01		and #$01		and  #datin     ; test if data line is low
.e93f	 d0 f6		bne $e937		bne  m4         ; yes, wait till hi
.e941	 20 59 ea	jsr $ea59	-       jsr  tstatn     ; test for atn
.e944	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.e947	 29 01		and #$01		and  #datin
.e949	 f0 f6		beq $e941		beq  -
.e94b	 20 ae e9	jsr $e9ae	m7      jsr  clklo      ; set clock low
.e94e	 20 59 ea	jsr $ea59		jsr  tstatn     ; chk atn line
.e951	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.e954	 29 01		and #$01		and  #datin
.e956	 d0 f3		bne $e94b		bne  m7
.e958	 a9 08		lda #$08		lda  #8         ; set up bit counter
.e95a	 85 98		sta $98			sta  cont
.e95c					m11
.e95c	 20 c0 e9	jsr $e9c0		jsr  debnc      ; let port settle
.e95f	 29 01		and #$01		and  #datin     ; test that data line is now high before we send
.e961	 d0 36		bne $e999		bne  m16
.e963	 a6 82		ldx $82		m12     ldx  lindx      ; get byte to send
.e965	 bd 3e 02	lda $023e,x		lda  chndat,x
.e968	 6a		ror a			ror  a
.e969	 9d 3e 02	sta $023e,x		sta  chndat,x
.e96c	 b0 05		bcs $e973		bcs  m13        ; send a 1
.e96e	 20 a5 e9	jsr $e9a5		jsr  datlow     ; send a 0
.e971	 d0 03		bne $e976		bne  m14        ; and clock it
.e973	 20 9c e9	jsr $e99c	m13     jsr  dathi
.e976	 20 b7 e9	jsr $e9b7	m14     jsr  clkhi
.e979	 a5 23		lda $23			lda  slflag     ; slow down?
.e97b	 d0 03		bne $e980		bne  m17
.e97d	 20 f3 fe	jsr $fef3		jsr  slowd      ; delay 40 us ( host dma )
.e980	 20 fb fe	jsr $fefb	m17     jsr  patch4     ; rising edge clock
.e983	 c6 98		dec $98			dec  cont       ; more bits?
.e985	 d0 d5		bne $e95c		bne  m11        ; yes
.e987	 20 59 ea	jsr $ea59	m9      jsr  tstatn     ; test for atn
.e98a	 20 c0 e9	jsr $e9c0		jsr  debnc      ; debounce
.e98d	 29 01		and #$01		and  #datin
.e98f	 f0 f6		beq $e987		beq  m9         ; wait for data low
.e991	 58		cli			cli             ; let the controller run
.e992	 20 aa d3	jsr $d3aa		jsr  get        ; get the next byte
.e995	 78		sei			sei             ; sorry sync protocol
.e996	 4c 0f e9	jmp $e90f		jmp  m2         ; keep on talkin
.e999	 4c 4e ea	jmp $ea4e	m16     jmp  ilerr
.e99c	 ad 00 18	lda $1800	dathi   lda  pb         ; set data out hi
.e99f	 29 fd		and #$fd		and  #all-datout
.e9a1	 8d 00 18	sta $1800		sta  pb
.e9a4	 60		rts			rts
.e9a5	 ad 00 18	lda $1800	datlow  lda  pb         ; set data out low
.e9a8	 09 02		ora #$02		ora  #datout
.e9aa	 8d 00 18	sta $1800		sta  pb
.e9ad	 60		rts			rts
.e9ae	 ad 00 18	lda $1800	clklo   lda  pb         ; set clk out low
.e9b1	 09 08		ora #$08		ora  #clkout
.e9b3	 8d 00 18	sta $1800		sta  pb
.e9b6	 60		rts			rts
.e9b7	 ad 00 18	lda $1800	clkhi   lda  pb         ; set clk out high
.e9ba	 29 f7		and #$f7		and  #$ff-clkout
.e9bc	 8d 00 18	sta $1800		sta  pb
.e9bf	 60		rts			rts
.e9c0	 ad 00 18	lda $1800	debnc   lda  pb         ; debounce port
.e9c3	 cd 00 18	cmp $1800		cmp  pb
.e9c6	 d0 f8		bne $e9c0		bne  debnc
.e9c8	 60		rts			rts
.e9c9					acptr
.e9c9	 a9 08		lda #$08		lda  #8         ; set byte bit count
.e9cb	 85 98		sta $98			sta  cont
.e9cd	 20 59 ea	jsr $ea59	-       jsr  tstatn
.e9d0	 20 c0 e9	jsr $e9c0		jsr  debnc
.e9d3	 29 04		and #$04		and  #clkin
.e9d5	 d0 f6		bne $e9cd		bne  -
.e9d7	 20 9c e9	jsr $e99c		jsr  dathi      ; make data line hi
.e9da	 a9 01		lda #$01		lda  #datin
.e9dc	 4c 20 ff	jmp $ff20		jmp  patch6
.e9df					rptch6
.e9df	 20 59 ea	jsr $ea59	m3	jsr  tstatn
.e9e2	 ad 0d 18	lda $180d		lda  ifr1
.e9e5	 29 40		and #$40		and  #$40
.e9e7	 d0 09		bne $e9f2		bne  m4
.e9e9	 20 c0 e9	jsr $e9c0		jsr  debnc      ; test clock low
.e9ec	 29 04		and #$04		and  #clkin
.e9ee	 f0 ef		beq $e9df		beq  m3         ; no
.e9f0	 d0 19		bne $ea0b		bne  m5         ; yes
.e9f2	 20 a5 e9	jsr $e9a5	m4      jsr  datlow     ; set data line low as response
.e9f5	 a2 0a		ldx #$0a		ldx  #10        ; delay for talker turnaround
.e9f7	 ca		dex		-       dex
.e9f8	 d0 fd		bne $e9f7		bne  -
.e9fa	 20 9c e9	jsr $e99c		jsr  dathi      ; set data line hi
.e9fd	 20 59 ea	jsr $ea59	-       jsr  tstatn
.ea00	 20 c0 e9	jsr $e9c0		jsr  debnc      ; wait for low clock
.ea03	 29 04		and #$04		and  #clkin
.ea05	 f0 f6		beq $e9fd		beq  -
.ea07	 a9 00		lda #$00		lda  #0         ; set eoi received
.ea09	 85 f8		sta $f8			sta  eoiflg
.ea0b	 ad 00 18	lda $1800	m5      lda  pb         ; wait for clock high
.ea0e	 49 01		eor #$01		eor  #01        ; complement datain
.ea10	 4a		lsr a			lsr  a          ; shift into carry
.ea11	 29 02		and #$02		and  #$02       ; clkin/2
.ea13	 d0 f6		bne $ea0b		bne  m5
.ea15	 ea		nop			nop
.ea16	 ea		nop			nop
.ea17	 ea		nop			nop
.ea18	 66 85		ror $85			ror  data
.ea1a	 20 59 ea	jsr $ea59	-       jsr  tstatn
.ea1d	 20 c0 e9	jsr $e9c0		jsr  debnc
.ea20	 29 04		and #$04		and  #clkin     ; wait for clock low
.ea22	 f0 f6		beq $ea1a		beq  -
.ea24	 c6 98		dec $98			dec  cont       ; more to do?
.ea26	 d0 e3		bne $ea0b		bne  m5
.ea28	 20 a5 e9	jsr $e9a5	m10     jsr  datlow     ; set data line low
.ea2b	 a5 85		lda $85			lda  data
.ea2d	 60		rts			rts
.ea2e					listen
.ea2e	 78		sei			sei
.ea2f	 20 07 d1	jsr $d107		jsr  fndwch     ; test if active write channel
.ea32	 b0 05		bcs $ea39		bcs  m1
.ea34	 b5 f2		lda $f2,x		lda  chnrdy,x
.ea36	 6a		ror a			ror  a
.ea37	 b0 0b		bcs $ea44		bcs  m2
.ea39	 a5 84		lda $84		m1      lda  orgsa      ; test if open
.ea3b	 29 f0		and #$f0		and  #$f0
.ea3d	 c9 f0		cmp #$f0		cmp  #$f0
.ea3f	 f0 03		beq $ea44		beq  m2         ; its an open
.ea41	 4c 4e ea	jmp $ea4e		jmp  ilerr      ; not active channel
.ea44	 20 c9 e9	jsr $e9c9	m2      jsr  acptr      ; get a byte
.ea47	 58		cli			cli
.ea48	 20 b7 cf	jsr $cfb7		jsr  put        ; put(data,eoiflg,sa)
.ea4b	 4c 2e ea	jmp $ea2e		jmp  listen     ; and keep on listen
.ea4e	 a9 00		lda #$00	ilerr   lda  #0
.ea50	 8d 00 18	sta $1800		sta  pb         ; in atnmod, release all bus lines
.ea53	 4c 6b 83	jmp $836b		jmp  xidle      ; go idle it
.ea56	 4c 5b e8	jmp $e85b	        jmp  atnsrv
.ea59					tstatn
.ea59	 a5 7d		lda $7d			lda  atnact
.ea5b	 f0 06		beq $ea63		beq  m1         ; no
.ea5d	 ad 00 18	lda $1800		lda  pb         ; in atnmod
.ea60	 10 09		bpl $ea6b		bpl  m2         ; atn gone,do what we are told to do
.ea62	 60		rts		m3      rts             ; still in atn  mode
.ea63	 ad 00 18	lda $1800	m1      lda  pb         ; not atnmode
.ea66	 10 fa		bpl $ea62		bpl  m3         ; no atn present
.ea68	 4c b3 a7	jmp $a7b3		jmp  ptch30     ; do atn command
.ea6b	 4c ac a9	jmp $a9ac	m2      jmp  ptch45

;******  Return to file "serlib.asm"

						.include "dskintsf.asm"

;******  Processing file "dskintsf.asm"

.ea6e	 a2 00		ldx #$00	pezro   ldx  #0         ; error #1 for zero page

>ea70	 2c                       		.byte skip2     ; skip next two bytes

.ea71	 a6 6f		ldx $6f		perr    ldx  temp       ; get error #
.ea73	 9a		txs		        txs     	; use stack as storage reg.
.ea74	 ba		tsx		pe20    tsx     	; restore error #
.ea75	 a9 08		lda #$08	pe30    lda  #led0+led1
.ea77	 0d 00 1c	ora $1c00	        ora  ledprt
.ea7a	 4c ea fe	jmp $feea	        jmp  pea7a
.ea7d	 98		tya		rea7d   tya     	; clear inner ctr !!!!patch return!!!!
.ea7e	 18		clc		pd10    clc
.ea7f	 69 01		adc #$01	pd20    adc  #1         ; count inner ctr
.ea81	 d0 fc		bne $ea7f	        bne  pd20
.ea83	 88		dey		        dey     	; done ?
.ea84	 d0 f8		bne $ea7e	        bne  pd10       ; no
.ea86	 ad 00 1c	lda $1c00	        lda  ledprt
.ea89	 29 f7		and #$f7	        and  #$ff-led0-led1
.ea8b	 8d 00 1c	sta $1c00	        sta  ledprt     ; turn off all leds
.ea8e					pe40
.ea8e	 98		tya		        tya     	; clear inner ctr
.ea8f	 18		clc		pd11    clc
.ea90	 69 01		adc #$01	pd21    adc  #1         ; count inner ctr
.ea92	 d0 fc		bne $ea90	        bne  pd21
.ea94	 88		dey		        dey     	; done ?
.ea95	 d0 f8		bne $ea8f	        bne  pd11       ; no
.ea97	 ca		dex		        dex     	; blinked # ?
.ea98	 10 db		bpl $ea75	        bpl  pe30       ; no - blink again
.ea9a	 e0 fc		cpx #$fc	        cpx  #$fc       ; waited between counts ?
.ea9c	 d0 f0		bne $ea8e	        bne  pe40       ; no
.ea9e	 f0 d4		beq $ea74	        beq  pe20       ; always - all again
.eaa0	 78		sei		dskint  sei
.eaa1	 d8		cld		        cld
.eaa2	 a2 66		ldx #$66	        ldx  #$66	; *,atnout,clk,*,*,side,fsdir,trk0
.eaa4	 4c 10 ff	jmp $ff10	        jmp  patch5     ; *** rom ds 8/18/83 ***
.eaa7	 e8		inx		dkit10  inx		; fill
.eaa8	 a0 00		ldy #$00	        ldy  #0
.eaaa	 a2 00		ldx #$00	        ldx  #0
.eaac	 8a		txa		pu10    txa     	; fill z-page accend pattern
.eaad	 95 00		sta $00,x	        sta  $0,x
.eaaf	 e8		inx		        inx
.eab0	 d0 fa		bne $eaac	        bne  pu10
.eab2	 8a		txa		pu20    txa     	; check pattern by inc...
.eab3	 d5 00		cmp $00,x	        cmp  $0,x       ; ...back to orig #
.eab5	 d0 b7		bne $ea6e	        bne  pezro      ; bad bits
.eab7					pu30
.eab7	 f6 00		inc $00,x		inc  $0,x       ; bump contents
.eab9	 c8		iny		        iny
.eaba	 d0 fb		bne $eab7	        bne  pu30       ; not done
.eabc	 d5 00		cmp $00,x	        cmp  $0,x       ; check for good count
.eabe	 d0 ae		bne $ea6e	        bne  pezro      ; something's wrong
.eac0	 94 00		sty $00,x	        sty  $0,x       ; leave z-page zeroed
.eac2	 b5 00		lda $00,x	        lda  $0,x       ; check it
.eac4	 d0 a8		bne $ea6e	        bne  pezro      ; wrong
.eac6	 e8		inx		        inx     	; next!
.eac7	 d0 e9		bne $eab2	        bne  pu20       ; not all done
.eac9	 e6 6f		inc $6f		rm10    inc  temp       ; next error #
.eacb	 a2 7f		ldx #$7f		ldx  #127	; 128 pages
.eacd	 86 76		stx $76		        stx  ip+1       ; save page, start x=0
.eacf	 e8		inx			inx		; **** rom ds 04/22/86 ***
.ead0	 a9 00		lda #$00		lda  #0
.ead2	 85 75		sta $75		        sta  ip         ; zero lo indirect
.ead4	 a0 02		ldy #$02		ldy  #2		; skip signature bytes
.ead6	 18		clc		        clc
.ead7	 e6 76		inc $76		rt10    inc  ip+1       ; do it backwards
.ead9	 71 75		adc ($75),y	rt20    adc  (ip),y     ; total checksum in a
.eadb	 c8		iny		        iny
.eadc	 d0 fb		bne $ead9	        bne  rt20
.eade	 ca		dex		        dex
.eadf	 d0 f6		bne $ead7	        bne  rt10
.eae1	 69 ff		adc #$ff	        adc  #255        ; add in last carry
.eae3	 85 76		sta $76			sta  ip+1
.eae5	 d0 38		bne $eb1f	        bne  perr2      ; no - show error number
.eae7	 ea		nop			nop		 ; fill
.eae8	 ea		nop			nop		 ; fill
.eae9	 ea		nop			nop		 ; fill
.eaea	 a9 01		lda #$01	cr20    lda  #$01       ; start of 1st block
.eaec	 85 76		sta $76		cr30    sta  ip+1       ; save page #
.eaee	 e6 6f		inc $6f		        inc  temp       ; bump error #
.eaf0	 a2 07		ldx #$07	ramtst  ldx  #7         ; save page count
.eaf2	 98		tya		ra10    tya     	; fill with adr sensitive pattern
.eaf3	 18		clc		        clc
.eaf4	 65 76		adc $76		        adc  ip+1
.eaf6	 91 75		sta ($75),y	        sta  (ip),y
.eaf8	 c8		iny		        iny
.eaf9	 d0 f7		bne $eaf2	        bne  ra10
.eafb	 e6 76		inc $76		        inc  ip+1
.eafd	 ca		dex		        dex
.eafe	 d0 f2		bne $eaf2	        bne  ra10
.eb00	 a2 07		ldx #$07	        ldx  #7         ; restore page count
.eb02	 c6 76		dec $76		ra30    dec  ip+1       ; check pattern backwards
.eb04	 88		dey		ra40    dey
.eb05	 98		tya		        tya     	; gen pattern again
.eb06	 18		clc		        clc
.eb07	 65 76		adc $76		        adc  ip+1
.eb09	 d1 75		cmp ($75),y	        cmp  (ip),y     ; ok ?
.eb0b	 d0 12		bne $eb1f	        bne  perr2      ; no - show error #
.eb0d	 49 ff		eor #$ff	        eor  #$ff       ; yes - test inverse pattern
.eb0f	 91 75		sta ($75),y	        sta  (ip),y
.eb11	 51 75		eor ($75),y	        eor  (ip),y     ; ok ?
.eb13	 91 75		sta ($75),y	        sta  (ip),y     ; leave memory zero
.eb15	 d0 08		bne $eb1f	        bne  perr2      ; no - show error #
.eb17	 98		tya		        tya
.eb18	 d0 ea		bne $eb04	        bne  ra40
.eb1a	 ca		dex		        dex
.eb1b	 d0 e5		bne $eb02	        bne  ra30
.eb1d	 f0 03		beq $eb22	        beq  diagok
.eb1f	 4c 71 ea	jmp $ea71	perr2   jmp  perr
.eb22					diagok
.eb22	 4c c0 a7	jmp $a7c0		jmp  ptch31	; *** rom ds 05/01/85 ***
.eb25	 ad 00 1c	lda $1c00	rtch31  lda  ledprt     ; clear leds
.eb28	 29 f7		and #$f7	        and  #$ff-led0-led1
.eb2a	 8d 00 1c	sta $1c00	        sta  ledprt
.eb2d	 a9 03		lda #$03	        lda  #3         ; neg edge of atn & edge on wp
.eb2f	 8d 0c 18	sta $180c	        sta  pcr1
.eb32	 a9 82		lda #$82	        lda  #%10000010 ; set,_t1,_t2,_cb1,_cb2,_sr,ca1,_ca2(wps)
.eb34	 8d 0d 18	sta $180d	        sta  ifr1
.eb37	 8d 0e 18	sta $180e		sta  ier1
.eb3a	 ad 00 18	lda $1800	        lda  pb         ; compute primary addr
.eb3d	 29 60		and #$60	        and  #%01100000 ; pb5 and pb6 are unused lines
.eb3f	 0a		asl a		        asl  a          ; shift to lower
.eb40	 2a		rol a		        rol  a
.eb41	 2a		rol a		        rol  a
.eb42	 2a		rol a		        rol  a
.eb43	 09 48		ora #$48	        ora  #$48       ; talk address
.eb45	 85 78		sta $78		        sta  tlkadr
.eb47	 49 60		eor #$60	        eor  #$60       ; listen address
.eb49	 85 77		sta $77		        sta  lsnadr
.eb4b	 a2 00		ldx #$00	inttab  ldx  #0
.eb4d	 a0 00		ldy #$00	        ldy  #0
.eb4f	 a9 00		lda #$00	intt1   lda  #0
.eb51	 95 99		sta $99,x	        sta  buftab,x
.eb53	 e8		inx		        inx
.eb54	 b9 e0 fe	lda $fee0,y	        lda  bufind,y
.eb57	 95 99		sta $99,x	        sta  buftab,x
.eb59	 e8		inx		        inx
.eb5a	 c8		iny		        iny
.eb5b	 c0 05		cpy #$05	        cpy  #bfcnt
.eb5d	 d0 f0		bne $eb4f	        bne  intt1
.eb5f	 a9 00		lda #$00	        lda  #<cmdbuf   ; set pntr to cmdbuf
.eb61	 95 99		sta $99,x	        sta  buftab,x
.eb63	 e8		inx		        inx
.eb64	 a9 02		lda #$02	        lda  #>cmdbuf
.eb66	 95 99		sta $99,x	        sta  buftab,x
.eb68	 e8		inx		        inx
.eb69	 a9 d5		lda #$d5	        lda  #<errbuf   ; set pntr to errbuf
.eb6b	 95 99		sta $99,x	        sta  buftab,x
.eb6d	 e8		inx		        inx
.eb6e	 a9 02		lda #$02	        lda  #>errbuf
.eb70	 95 99		sta $99,x	        sta  buftab,x
.eb72	 a9 ff		lda #$ff	        lda  #$ff
.eb74	 a2 12		ldx #$12	        ldx  #maxsa
.eb76	 9d 2b 02	sta $022b,x	dskin1  sta  lintab,x
.eb79	 ca		dex		        dex
.eb7a	 10 fa		bpl $eb76	        bpl  dskin1
.eb7c	 a2 05		ldx #$05	        ldx  #mxchns-1
.eb7e					dskin2
.eb7e	 95 a7		sta $a7,x	        sta  buf0,x     ; set buffers as unused
.eb80	 95 ae		sta $ae,x	        sta  buf1,x
.eb82	 95 cd		sta $cd,x	        sta  ss,x
.eb84	 ca		dex		        dex
.eb85	 10 f7		bpl $eb7e	        bpl  dskin2
.eb87	 a9 05		lda #$05	        lda  #bfcnt     ; set buffer pointers
.eb89	 85 ab		sta $ab		        sta  buf0+cmdchn
.eb8b	 a9 06		lda #$06	        lda  #bfcnt+1
.eb8d	 85 ac		sta $ac		        sta  buf0+errchn
.eb8f	 a9 ff		lda #$ff	        lda  #$ff
.eb91	 85 ad		sta $ad		        sta  buf0+blindx
.eb93	 85 b4		sta $b4		        sta  buf1+blindx
.eb95	 a9 05		lda #$05	        lda  #errchn
.eb97	 8d 3b 02	sta $023b	        sta  lintab+errsa
.eb9a	 a9 84		lda #$84	        lda  #cmdchn+$80
.eb9c	 8d 3a 02	sta $023a	        sta  lintab+cmdsa
.eb9f	 a9 0f		lda #$0f	        lda  #lxint     ; lindx 0 to 5 free
.eba1	 8d 56 02	sta $0256	        sta  linuse
.eba4	 a9 01		lda #$01	        lda  #rdylst
.eba6	 85 f6		sta $f6		        sta  chnrdy+cmdchn
.eba8	 a9 88		lda #$88	        lda  #rdytlk
.ebaa	 85 f7		sta $f7		        sta  chnrdy+errchn
.ebac	 a9 e0		lda #$e0	        lda  #$e0
.ebae	 8d 4f 02	sta $024f	        sta  bufuse
.ebb1	 a9 ff		lda #$ff	        lda  #$ff
.ebb3	 8d 50 02	sta $0250	        sta  bufuse+1
.ebb6	 20 96 ab	jsr $ab96		jsr  ptch72	; *** rom ds 05/20/86 ***
.ebb9	 ea		nop			nop
.ebba	 85 1d		sta $1d		        sta  wpsw+1
.ebbc	 20 63 cb	jsr $cb63	        jsr  usrint     ; init user jmp
.ebbf	 20 fa ce	jsr $cefa	        jsr  lruint
.ebc2	 20 82 ff	jsr $ff82	        jsr  ptch10     ; *** rom ds 05/01/85 controller init ***
.ebc5	 a9 22		lda #$22	        lda  #<diagok
.ebc7	 85 65		sta $65		        sta  vnmi
.ebc9	 a9 eb		lda #$eb	        lda  #>diagok
.ebcb	 85 66		sta $66		        sta  vnmi+1
.ebcd	 a9 06		lda #$06	        lda  #6	        ; set up sector offset *** rom ds 01/22/85 ***
.ebcf	 85 69		sta $69		        sta  secinc
.ebd1	 a9 05		lda #$05	        lda  #5
.ebd3	 85 6a		sta $6a		        sta  revcnt     ; set up recovery count
.ebd5	 a9 73		lda #$73	seterr  lda  #$73
.ebd7	 20 c1 e6	jsr $e6c1	        jsr  errts0
.ebda	 a9 00		lda #$00	        lda  #$00       ;  data hi, clock hi,atna hi
.ebdc	 8d 00 18	sta $1800	        sta  pb
.ebdf	 a9 1a		lda #$1a	        lda  #%00011010 ;  atna,clkout,datout
.ebe1	 8d 02 18	sta $1802	        sta  ddrb1
.ebe4	 20 86 a7	jsr $a786	    	jsr  ptch29	; *rom ds 02/01/85*

;******  Return to file "serlib.asm"

						.include "idlesf.asm"

;******  Processing file "idlesf.asm"

.ebe7					idle
.ebe7	 58		cli		        cli
.ebe8	 ad 00 18	lda $1800	        lda  pb         ; clock and data high
.ebeb	 29 e5		and #$e5	        and  #$e5       ; clock high
.ebed	 8d 00 18	sta $1800	        sta  pb         ; data high,atna hi
.ebf0	 ad 55 02	lda $0255	        lda  cmdwat     ; test for pending command
.ebf3	 f0 0a		beq $ebff	        beq  idl1       ; no command waiting
.ebf5	 a9 00		lda #$00	        lda  #0
.ebf7	 8d 55 02	sta $0255	        sta  cmdwat
.ebfa	 ea		nop			nop		; *** rom ds -06 *** / fill
.ebfb	 ea		nop			nop		; *** rom ds -06 *** / fill
.ebfc	 4c 1c a6	jmp $a61c		jmp  ptch19	; *rom ds 01/23/85*
.ebff					rtch19
.ebff	 58		cli		idl1    cli     	; test for drive running or openfile
.ec00	 a5 7c		lda $7c		        lda  atnpnd
.ec02	 f0 03		beq $ec07	        beq  idl01
.ec04	 4c b3 a7	jmp $a7b3		jmp  ptch30	; *rom ds 02/04/85*
.ec07					idl01
.ec07	 58		cli		        cli
.ec08	 a9 0e		lda #$0e	        lda  #14
.ec0a	 85 72		sta $72		        sta  temp+3
.ec0c	 a9 00		lda #$00	        lda  #0         ; if file open, turn on act led
.ec0e	 85 6f		sta $6f		        sta  temp
.ec10	 85 70		sta $70		        sta  temp+1
.ec12	 a6 72		ldx $72		idl2    ldx  temp+3     ; look thru lintab
.ec14	 bd 2b 02	lda $022b,x	        lda  lintab,x   ; for active file
.ec17	 c9 ff		cmp #$ff	        cmp  #$ff
.ec19	 f0 10		beq $ec2b	        beq  idl3
.ec1b	 29 3f		and #$3f	        and  #$3f
.ec1d	 85 82		sta $82		        sta  lindx
.ec1f	 20 93 df	jsr $df93		jsr  getact
.ec22	 aa		tax		        tax
.ec23	 bd 5b 02	lda $025b,x	        lda  lstjob,x   ; determine which drv it is on
.ec26	 29 01		and #$01	        and  #1
.ec28	 aa		tax		        tax
.ec29	 f6 6f		inc $6f,x	        inc  temp,x
.ec2b	 c6 72		dec $72		idl3    dec  temp+3     ; set flag indicating drv
.ec2d	 10 e3		bpl $ec12	        bpl  idl2       ; has file open
.ec2f	 a0 04		ldy #$04	        ldy  #bfcnt-1   ; look thru job que for
.ec31	 b9 00 00	lda $0000,y	idl4    lda  jobs,y     ; for jobs still running
.ec34	 10 05		bpl $ec3b	        bpl  idl5
.ec36	 29 01		and #$01	        and  #1
.ec38	 aa		tax		        tax
.ec39	 f6 6f		inc $6f,x	        inc  temp,x     ; set flag indicating drive
.ec3b	 88		dey		idl5    dey     	; is active
.ec3c	 10 f3		bpl $ec31	        bpl  idl4
.ec3e	 78		sei		        sei
.ec3f	 ad 00 1c	lda $1c00	        lda  ledprt
.ec42	 29 f7		and #$f7	        and  #$ff-led0
.ec44	 48		pha		        pha
.ec45	 a5 7f		lda $7f		        lda  drvnum
.ec47	 85 86		sta $86		        sta  r0
.ec49	 a9 00		lda #$00	        lda  #0
.ec4b	 85 7f		sta $7f		        sta  drvnum
.ec4d	 a5 6f		lda $6f		        lda  temp
.ec4f	 f0 0b		beq $ec5c	        beq  idl7
.ec51	 a5 1c		lda $1c		        lda  wpsw
.ec53	 f0 03		beq $ec58	        beq  idl6
.ec55	 20 13 d3	jsr $d313		jsr  cldchn
.ec58					idl6
.ec58	 68		pla		        pla     	; turn on led if drive flag
.ec59	 09 08		ora #$08	        ora  #led0      ;  if not 0
.ec5b	 48		pha		        pha
.ec5c					idl7
.ec5c	 e6 7f		inc $7f		        inc  drvnum
.ec5e	 a5 70		lda $70		        lda  temp+1
.ec60	 f0 0b		beq $ec6d	        beq  idl9
.ec62	 a5 1d		lda $1d		        lda  wpsw+1
.ec64	 f0 03		beq $ec69	        beq  idl8
.ec66	 20 13 d3	jsr $d313	        jsr  cldchn
.ec69					idl8
.ec69	 68		pla		        pla
.ec6a	 09 00		ora #$00	        ora  #led1
.ec6c	 48		pha		        pha
.ec6d					idl9
.ec6d	 a5 86		lda $86		        lda  r0
.ec6f	 85 7f		sta $7f		        sta  drvnum
.ec71	 68		pla		        pla
.ec72	 ae 6c 02	ldx $026c	        ldx  erword
.ec75	 f0 21		beq $ec98	        beq  idl12      ; no error flashing
.ec77	 ad 00 1c	lda $1c00	        lda  ledprt     ; use current leds
.ec7a	 e0 80		cpx #$80	        cpx  #$80
.ec7c	 d0 03		bne $ec81	        bne  idl10      ; not ist time
.ec7e	 4c 8b ec	jmp $ec8b	        jmp  idl11
.ec81					idl10
.ec81	 ae 05 18	ldx $1805	        ldx  timer1
.ec84	 30 12		bmi $ec98	        bmi  idl12      ; still timing
.ec86	 a2 a0		ldx #$a0	        ldx  #$a0       ; count 8 msec
.ec88	 8e 05 18	stx $1805	        stx  timer1
.ec8b					idl11
.ec8b	 ce 6c 02	dec $026c	        dec  erword     ; count units of 8 msec
.ec8e	 d0 08		bne $ec98	        bne  idl12      ; keep counting
.ec90	 4d 6d 02	eor $026d	        eor  erled      ; toggle led
.ec93	 a2 10		ldx #$10	        ldx  #16        ; count 16 units
.ec95	 8e 6c 02	stx $026c	        stx  erword
.ec98					idl12
.ec98	 8d 00 1c	sta $1c00	        sta  ledprt     ; set leds
.ec9b	 4c ff eb	jmp $ebff	        jmp  idl1       ; back to top of lop

;******  Return to file "serlib.asm"

						.include "lstdir.asm"

;******  Processing file "lstdir.asm"

.ec9e	 a9 00		lda #$00	stdir   lda  #0
.eca0	 85 83		sta $83		        sta  sa
.eca2	 a9 01		lda #$01	        lda  #1         ; allocate chanl and 1 bufefer
.eca4	 20 e2 d1	jsr $d1e2	        jsr  getrch
.eca7	 a9 00		lda #$00	        lda  #0
.eca9	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.ecac	 a6 82		ldx $82		        ldx  lindx
.ecae	 a9 00		lda #$00	        lda  #0
.ecb0	 9d 44 02	sta $0244,x	        sta  lstchr,x
.ecb3	 20 93 df	jsr $df93	        jsr  getact
.ecb6	 aa		tax		        tax
.ecb7	 a5 7f		lda $7f		        lda  drvnum
.ecb9	 9d 5b 02	sta $025b,x	        sta  lstjob,x
.ecbc	 a9 01		lda #$01	        lda  #1         ;  put sal in buffer
.ecbe	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecc1	 a9 04		lda #$04	        lda  #4         ; put sah in buffer
.ecc3	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecc6	 a9 01		lda #$01	        lda  #1         ; insert fhoney links (0101)
.ecc8	 20 f1 cf	jsr $cff1	        jsr  putbyt
.eccb	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecce	 ad 72 02	lda $0272	        lda  nbtemp
.ecd1	 20 f1 cf	jsr $cff1	        jsr  putbyt     ; put in drvnum
.ecd4	 a9 00		lda #$00	        lda  #0
.ecd6	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecd9	 20 59 ed	jsr $ed59	        jsr  movbuf     ; get disk name
.ecdc	 20 93 df	jsr $df93	        jsr  getact
.ecdf	 0a		asl a		        asl  a
.ece0	 aa		tax		        tax
.ece1	 d6 99		dec $99,x	        dec  buftab,x
.ece3	 d6 99		dec $99,x	        dec  buftab,x
.ece5	 a9 00		lda #$00	        lda  #0         ; end of this line
.ece7	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecea	 a9 01		lda #$01	dir1    lda  #1         ; insert fhoney links ($0101)
.ecec	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecef	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecf2	 20 ce c6	jsr $c6ce	        jsr  getnam     ; get #bufrs and file name
.ecf5	 90 2c		bcc $ed23	        bcc  dir3       ; test if last entry
.ecf7	 ad 72 02	lda $0272	        lda  nbtemp
.ecfa	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ecfd	 ad 73 02	lda $0273	        lda  nbtemp+1
.ed00	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed03	 20 59 ed	jsr $ed59	        jsr  movbuf
.ed06	 a9 00		lda #$00	        lda  #0         ; end of entry
.ed08	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed0b	 d0 dd		bne $ecea	        bne  dir1
.ed0d	 20 93 df	jsr $df93	dir10   jsr  getact
.ed10	 0a		asl a		        asl  a
.ed11	 aa		tax		        tax
.ed12	 a9 00		lda #$00	        lda  #0
.ed14	 95 99		sta $99,x	        sta  buftab,x
.ed16	 a9 88		lda #$88	        lda  #rdytlk
.ed18	 a4 82		ldy $82		        ldy  lindx
.ed1a	 8d 54 02	sta $0254	        sta  dirlst
.ed1d	 99 f2 00	sta $00f2,y	        sta  chnrdy,y   ;  directory list buffer full
.ed20	 a5 85		lda $85		        lda  data
.ed22	 60		rts		        rts
.ed23	 ad 72 02	lda $0272	dir3    lda  nbtemp     ;  this is end of load
.ed26	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed29	 ad 73 02	lda $0273	        lda  nbtemp+1
.ed2c	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed2f	 20 59 ed	jsr $ed59	        jsr  movbuf
.ed32	 20 93 df	jsr $df93	        jsr  getact
.ed35	 0a		asl a		        asl  a
.ed36	 aa		tax		        tax
.ed37	 d6 99		dec $99,x	        dec  buftab,x
.ed39	 d6 99		dec $99,x	        dec  buftab,x
.ed3b	 a9 00		lda #$00	        lda  #0         ;  end of listing (000)
.ed3d	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed40	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed43	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed46	 20 93 df	jsr $df93	        jsr  getact
.ed49	 0a		asl a		        asl  a
.ed4a	 a8		tay		        tay
.ed4b	 b9 99 00	lda $0099,y	        lda  buftab,y
.ed4e	 a6 82		ldx $82		        ldx  lindx
.ed50	 9d 44 02	sta $0244,x	        sta  lstchr,x
.ed53	 de 44 02	dec $0244,x	        dec  lstchr,x
.ed56	 4c 0d ed	jmp $ed0d	        jmp  dir10
.ed59	 a0 00		ldy #$00	movbuf  ldy  #0
.ed5b	 b9 b1 02	lda $02b1,y	movb1   lda  nambuf,y
.ed5e	 20 f1 cf	jsr $cff1	        jsr  putbyt
.ed61	 c8		iny		        iny
.ed62	 c0 1b		cpy #$1b	        cpy  #27
.ed64	 d0 f5		bne $ed5b	        bne  movb1
.ed66	 60		rts		        rts
.ed67	 20 37 d1	jsr $d137	getdir  jsr  getbyt
.ed6a	 f0 01		beq $ed6d	        beq  getd3
.ed6c	 60		rts		        rts
.ed6d	 85 85		sta $85		getd3   sta  data
.ed6f	 a4 82		ldy $82		        ldy  lindx
.ed71	 b9 44 02	lda $0244,y	        lda  lstchr,y
.ed74	 f0 08		beq $ed7e	        beq  gd1
.ed76	 a9 80		lda #$80	        lda  #eoiout
.ed78	 99 f2 00	sta $00f2,y	        sta  chnrdy,y
.ed7b	 a5 85		lda $85		        lda  data
.ed7d	 60		rts		        rts
.ed7e					gd1
.ed7e	 48		pha		        pha
.ed7f	 20 ea ec	jsr $ecea	        jsr  dir1
.ed82	 68		pla		        pla
.ed83	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "verdir.asm"

;******  Processing file "verdir.asm"

.ed84	 20 d1 c1	jsr $c1d1	verdir  jsr  simprs     ; get drive #
.ed87	 20 42 d0	jsr $d042	        jsr  initdr
.ed8a	 a9 40		lda #$40	        lda  #$40
.ed8c	 8d f9 02	sta $02f9	        sta  wbam
.ed8f	 20 69 aa	jsr $aa69	        jsr  ptch58
.ed92	 a9 00		lda #$00	        lda  #0
.ed94	 8d 92 02	sta $0292	        sta  delind
.ed97	 20 ac c5	jsr $c5ac	        jsr  srchst     ; search first file
.ed9a	 d0 3d		bne $edd9	        bne  vd25       ; found one
.ed9c	 a9 00		lda #$00	vd10    lda  #0         ; set dir sectors..
.ed9e	 85 81		sta $81		        sta  sector     ; ...in bam
.eda0	 ad 85 fe	lda $fe85	        lda  dirtrk
.eda3	 85 80		sta $80		        sta  track
.eda5	 20 e5 ed	jsr $ede5	        jsr  vmkbam
.eda8	 a9 00		lda #$00	        lda  #0
.edaa	 8d f9 02	sta $02f9	        sta  wbam
.edad	 20 ff ee	jsr $eeff		jsr  scrbam	; wrt 'em out
.edb0	 4c 94 c1	jmp $c194	        jmp  endcmd
.edb3	 c8		iny		vd15    iny
.edb4	 b1 94		lda ($94),y	        lda  (dirbuf),y
.edb6	 48		pha		        pha     	; save track
.edb7	 c8		iny		        iny
.edb8	 b1 94		lda ($94),y	        lda  (dirbuf),y
.edba	 48		pha		        pha     	; save sector
.edbb	 a0 13		ldy #$13	        ldy  #19        ; get ss track
.edbd	 b1 94		lda ($94),y	        lda  (dirbuf),y ; is this relative ?
.edbf	 f0 0a		beq $edcb	        beq  vd17       ; no
.edc1	 85 80		sta $80		        sta  track      ; yes - save track
.edc3	 c8		iny		        iny
.edc4	 b1 94		lda ($94),y	        lda  (dirbuf),y ; get ss sector
.edc6	 85 81		sta $81		        sta  sector
.edc8	 20 e5 ed	jsr $ede5	        jsr  vmkbam     ; validate ss by links
.edcb	 68		pla		vd17    pla
.edcc	 85 81		sta $81		        sta  sector     ; now do data blocks
.edce	 68		pla		        pla
.edcf	 85 80		sta $80		        sta  track
.edd1	 20 e5 ed	jsr $ede5	        jsr  vmkbam     ; set bit used in bam
.edd4	 20 04 c6	jsr $c604	vd20    jsr  srre       ; search for more
.edd7	 f0 c3		beq $ed9c	        beq  vd10       ; no more files
.edd9	 a0 00		ldy #$00	vd25    ldy  #0
.eddb	 b1 94		lda ($94),y	        lda  (dirbuf),y
.eddd	 30 d4		bmi $edb3		bmi  vd15
.eddf	 20 b6 c8	jsr $c8b6	        jsr  deldir     ; not closed delete dir
.ede2	 4c d4 ed	jmp $edd4	        jmp  vd20
.ede5					vmkbam
.ede5	 20 5f d5	jsr $d55f	        jsr  tschk
.ede8	 20 90 ef	jsr $ef90	        jsr  wused
.edeb	 20 75 d4	jsr $d475	        jsr  opnird
.edee	 a9 00		lda #$00	mrk2    lda  #0
.edf0	 20 c8 d4	jsr $d4c8	        jsr  setpnt
.edf3	 20 37 d1	jsr $d137	        jsr  getbyt
.edf6	 85 80		sta $80		        sta  track
.edf8	 20 37 d1	jsr $d137	        jsr  getbyt
.edfb	 85 81		sta $81		        sta  sector
.edfd	 a5 80		lda $80		        lda  track
.edff	 d0 03		bne $ee04	        bne  mrk1
.ee01	 4c 27 d2	jmp $d227	        jmp  frechn
.ee04	 20 90 ef	jsr $ef90	mrk1    jsr  wused
.ee07	 20 4d d4	jsr $d44d	        jsr  nxtbuf
.ee0a	 4c ee ed	jmp $edee	        jmp  mrk2

;******  Return to file "serlib.asm"

						.include "new.asm"

;******  Processing file "new.asm"

.ee0d	 20 12 c3	jsr $c312	new     jsr  onedrv
.ee10	 a5 e2		lda $e2		        lda  fildrv     ; set up drive #
.ee12	 10 05		bpl $ee19	        bpl  n101
.ee14	 a9 33		lda #$33	        lda  #badfn     ; bad drive # given
.ee16	 4c c8 c1	jmp $c1c8	        jmp  cmderr
.ee19	 29 01		and #$01	n101    and  #1
.ee1b	 85 7f		sta $7f		        sta  drvnum
.ee1d	 20 9c ff	jsr $ff9c	        jsr  ptch11     ; clr nodrv ***rom ds 01/21/85***
.ee20	 a5 7f		lda $7f		        lda  drvnum
.ee22	 0a		asl a		        asl  a
.ee23	 aa		tax		        tax
.ee24	 ac 7b 02	ldy $027b	        ldy  filtbl+1   ; get disk id
.ee27	 cc 74 02	cpy $0274	        cpy  cmdsiz     ; ?is this new or clear?
.ee2a	 f0 1a		beq $ee46	        beq  n108       ; end of cmd string
.ee2c	 b9 00 02	lda $0200,y	        lda  cmdbuf,y   ; format disk****
.ee2f	 95 12		sta $12,x	        sta  dskid,x    ; store in proper drive
.ee31	 b9 01 02	lda $0201,y	        lda  cmdbuf+1,y ; (y=0)
.ee34	 95 13		sta $13,x	        sta  dskid+1,x
.ee36	 20 07 d3	jsr $d307	        jsr  clrchn     ; clear all channels when formatting
.ee39	 a9 01		lda #$01	        lda  #1         ; ...in track, track=1
.ee3b	 85 80		sta $80		        sta  track
.ee3d	 20 2f ff	jsr $ff2f	        jsr  patch7     ; set format flag
.ee40	 4c 64 a7	jmp $a764		jmp  ptch27	; *** rom ds 03/15/85 ***
.ee43					rtch27
.ee43	 4c 56 ee	jmp $ee56		jmp  n110
.ee46	 20 42 d0	jsr $d042	n108    jsr  initdr     ; clear directory only
.ee49	 a6 7f		ldx $7f		        ldx  drvnum
.ee4b	 bd 01 01	lda $0101,x	        lda  dskver,x   ; use current version #
.ee4e	 cd d5 fe	cmp $fed5	        cmp  vernum
.ee51	 f0 03		beq $ee56	        beq  n110
.ee53	 4c 72 d5	jmp $d572	        jmp  vnerr      ; wrong version #
.ee56	 20 c7 a7	jsr $a7c7	n110   	jsr  ptch32	; *** rom ds 02/21/85 ***
.ee59	 a5 f9		lda $f9		        lda  jobnum
.ee5b	 a8		tay		        tay
.ee5c	 0a		asl a		        asl  a
.ee5d	 aa		tax		        tax
.ee5e	 ad 88 fe	lda $fe88	        lda  dsknam     ; set ptr to disk name
.ee61	 95 99		sta $99,x	        sta  buftab,x
.ee63	 ae 7a 02	ldx $027a	        ldx  filtbl
.ee66	 a9 1b		lda #$1b	        lda  #27
.ee68	 20 6e c6	jsr $c66e	        jsr  trname     ; transfer cmd buf to bam
.ee6b	 a0 12		ldy #$12	        ldy  #$12
.ee6d	 a6 7f		ldx $7f		        ldx  drvnum
.ee6f	 ad d5 fe	lda $fed5	        lda  vernum     ; set dos's current format type
.ee72	 9d 01 01	sta $0101,x	        sta  dskver,x
.ee75	 8a		txa		        txa
.ee76	 0a		asl a		        asl  a
.ee77	 aa		tax		        tax
.ee78	 b5 12		lda $12,x	        lda  dskid,x    ; write directory's  i.d.
.ee7a	 91 94		sta ($94),y	        sta  (dirbuf),y
.ee7c	 c8		iny		        iny
.ee7d	 b5 13		lda $13,x	        lda  dskid+1,x
.ee7f	 91 94		sta ($94),y	        sta  (dirbuf),y
.ee81	 c8		iny		        iny
.ee82	 c8		iny		        iny
.ee83	 a9 32		lda #$32	        lda  #dosver+$30 ; write directory dos version
.ee85	 91 94		sta ($94),y	        sta  (dirbuf),y
.ee87	 c8		iny		        iny
.ee88	 ad d5 fe	lda $fed5	        lda  vernum     ; write directory format type
.ee8b	 91 94		sta ($94),y	        sta  (dirbuf),y
.ee8d	 a0 02		ldy #$02	        ldy  #2
.ee8f	 91 6d		sta ($6d),y	        sta  (bmpnt),y  ; write diskette's format type
.ee91	 ad 85 fe	lda $fe85	        lda  dirtrk
.ee94	 85 80		sta $80		        sta  track
.ee96	 20 93 ef	jsr $ef93	        jsr  usedts     ; set bam block used
.ee99	 a9 01		lda #$01	        lda  #1
.ee9b	 85 81		sta $81		        sta  sector
.ee9d	 20 93 ef	jsr $ef93	        jsr  usedts     ; set 1st dir block used
.eea0	 20 ff ee	jsr $eeff	        jsr  scrbam     ; scrub the bam
.eea3	 20 05 f0	jsr $f005	        jsr  clrbam     ; set to all 0's
.eea6	 a0 01		ldy #$01	        ldy  #1
.eea8	 a9 ff		lda #$ff	        lda  #$ff       ; set end link
.eeaa	 91 6d		sta ($6d),y	        sta  (bmpnt),y
.eeac	 20 64 d4	jsr $d464	        jsr  drtwrt     ; clear directory
.eeaf	 c6 81		dec $81		        dec  sector
.eeb1	 20 42 d0	jsr $d042		jsr  initdr	; *** rom ds 02/27/85 ***
.eeb4	 4c 94 c1	jmp $c194	        jmp  endcmd

;******  Return to file "serlib.asm"

						.include "map.asm"

;******  Processing file "map.asm"

.eeb7					newmap
.eeb7					newmpv
.eeb7	 20 d1 f0	jsr $f0d1	        jsr  clnbam
.eeba	 a0 00		ldy #$00	        ldy  #0
.eebc	 a9 12		lda #$12	        lda  #18        ; set link to 18.1
.eebe	 91 6d		sta ($6d),y	        sta  (bmpnt),y
.eec0	 c8		iny		        iny
.eec1	 98		tya		        tya
.eec2	 91 6d		sta ($6d),y	        sta  (bmpnt),y
.eec4	 c8		iny		        iny
.eec5	 c8		iny		        iny
.eec6	 c8		iny		        iny     	; .y=4
.eec7					nm10
.eec7	 a9 00		lda #$00	        lda  #0         ; clear track map
.eec9	 85 6f		sta $6f		        sta  t0
.eecb	 85 70		sta $70		        sta  t1
.eecd	 85 71		sta $71		        sta  t2
.eecf	 98		tya		        tya      	; 4=>1
.eed0	 4a		lsr a		        lsr  a
.eed1	 4a		lsr a		        lsr  a          ; .a=track #
.eed2	 20 4b f2	jsr $f24b	        jsr  maxsec     ; store blks free byte away
.eed5	 91 6d		sta ($6d),y	        sta  (bmpnt),y
.eed7	 c8		iny		        iny
.eed8	 aa		tax		        tax
.eed9					nm20
.eed9	 38		sec		        sec     	; set map bits
.eeda	 26 6f		rol $6f		        rol  t0         ;      t0          t1          t2
.eedc	 26 70		rol $70		        rol  t1         ;   76543210  111111         xxx21111
.eede	 26 71		rol $71		        rol  t2         ;             54321098          09876
.eee0	 ca		dex		        dex      	;   11111111  11111111          11111
.eee1	 d0 f6		bne $eed9	        bne  nm20
.eee3					nm30
.eee3	 b5 6f		lda $6f,x	        lda  t0,x
.eee5	 91 6d		sta ($6d),y	        sta  (bmpnt),y  ; write out bit map
.eee7	 c8		iny		        iny
.eee8	 e8		inx		        inx
.eee9	 e0 03		cpx #$03	        cpx  #3
.eeeb	 90 f6		bcc $eee3	        bcc  nm30
.eeed	 c0 90		cpy #$90	        cpy  #$90       ; end of bam, 4-143
.eeef	 90 d6		bcc $eec7	        bcc  nm10
.eef1	 4c 75 d0	jmp $d075	        jmp  nfcalc     ; calc # free sectors
.eef4	 20 93 df	jsr $df93	mapout  jsr  getact
.eef7	 aa		tax		        tax
.eef8	 bd 5b 02	lda $025b,x	        lda  lstjob,x
.eefb	 29 01		and #$01	mo10    and  #1
.eefd	 85 7f		sta $7f		        sta  drvnum     ; check bam before writing
.eeff					scrbam
.eeff	 a4 7f		ldy $7f		        ldy  drvnum
.ef01	 b9 51 02	lda $0251,y	        lda  mdirty,y
.ef04	 d0 01		bne $ef07	        bne  sb10
.ef06	 60		rts		        rts     	; not dirty
.ef07					sb10
.ef07	 a9 00		lda #$00	        lda  #0         ; set to clean bam
.ef09	 99 51 02	sta $0251,y	        sta  mdirty,y
.ef0c	 20 3a ef	jsr $ef3a	        jsr  setbpt     ; set bit map ptr
.ef0f	 a5 7f		lda $7f		        lda  drvnum
.ef11	 0a		asl a		        asl  a
.ef12	 48		pha		        pha
.ef13	 20 a5 f0	jsr $f0a5	        jsr  putbam
.ef16	 68		pla		        pla
.ef17	 18		clc		        clc
.ef18	 69 01		adc #$01	        adc  #1
.ef1a	 20 a5 f0	jsr $f0a5	        jsr  putbam
.ef1d	 a5 80		lda $80		        lda  track
.ef1f	 48		pha		        pha     	; save track var
.ef20	 a9 01		lda #$01	        lda  #1
.ef22	 85 80		sta $80		        sta  track
.ef24					sb20
.ef24	 0a		asl a		        asl  a
.ef25	 0a		asl a		        asl  a
.ef26	 85 6d		sta $6d		        sta  bmpnt
.ef28	 20 37 a9	jsr $a937		jsr  ptch39	; *** rom ds 02/25/85 ***
.ef2b	 e6 80		inc $80		        inc  track
.ef2d	 a5 80		lda $80		        lda  track
.ef2f	 cd ac 02	cmp $02ac	        cmp  maxtrk
.ef32	 90 f0		bcc $ef24	        bcc  sb20
.ef34	 68		pla		        pla     	; restore track var
.ef35	 85 80		sta $80		        sta  track
.ef37	 4c 8d a5	jmp $a58d		jmp  wrt_bam
.ef3a					setbpt
.ef3a	 20 0f f1	jsr $f10f	        jsr  bam2a
.ef3d	 aa		tax		        tax
.ef3e	 20 df f0	jsr $f0df	        jsr  redbam     ; read bam if not in
.ef41	 a6 f9		ldx $f9		        ldx  jobnum
.ef43	 bd e0 fe	lda $fee0,x	        lda  bufind,x   ; set the ptr
.ef46	 85 6e		sta $6e		        sta  bmpnt+1
.ef48	 a9 00		lda #$00	        lda  #0
.ef4a	 85 6d		sta $6d		        sta  bmpnt
.ef4c	 60		rts		        rts
.ef4d					numfre
.ef4d	 a6 7f		ldx $7f		        ldx  drvnum
.ef4f	 bd fa 02	lda $02fa,x	        lda  ndbl,x
.ef52	 8d 72 02	sta $0272	        sta  nbtemp
.ef55	 bd fc 02	lda $02fc,x	        lda  ndbh,x
.ef58	 8d 73 02	sta $0273	        sta  nbtemp+1
.ef5b	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "frets.asm"

;******  Processing file "frets.asm"

.ef5c	 20 f1 ef	jsr $eff1		jsr  wrtbm
.ef5f	 4c 3e a8	jmp $a83e	frets   jmp  ptch33
.ef62	 38		sec		frets2	sec
.ef63	 d0 22		bne $ef87	        bne  fre10      ; free already
.ef65	 b1 6d		lda ($6d),y	        lda  (bmpnt),y  ; not free, free it
.ef67	 1d e9 ef	ora $efe9,x	        ora  bmask,x
.ef6a	 91 6d		sta ($6d),y	        sta  (bmpnt),y
.ef6c	 20 88 ef	jsr $ef88	        jsr  dtybam
.ef6f	 a4 6f		ldy $6f		        ldy  t0         ; point to blks free
.ef71	 18		clc		        clc
.ef72	 b1 6d		lda ($6d),y	        lda  (bmpnt),y
.ef74	 69 01		adc #$01	        adc  #1         ; add one
.ef76	 91 6d		sta ($6d),y	        sta  (bmpnt),y
.ef78	 a5 80		lda $80		        lda  track
.ef7a	 cd 85 fe	cmp $fe85	        cmp  dirtrk
.ef7d	 f0 3b		beq $efba	        beq  use10
.ef7f	 fe fa 02	inc $02fa,x	fre20   inc  ndbl,x
.ef82	 d0 03		bne $ef87	        bne  fre10
.ef84	 fe fc 02	inc $02fc,x	        inc  ndbh,x
.ef87	 60		rts		fre10   rts
.ef88	 a6 7f		ldx $7f		dtybam  ldx  drvnum
.ef8a	 a9 01		lda #$01		lda  #1
.ef8c	 9d 51 02	sta $0251,x		sta  mdirty,x
.ef8f	 60		rts			rts
.ef90	 20 f1 ef	jsr $eff1	wused   jsr  wrtbm      ; get bam index
.ef93	 4c 74 a8	jmp $a874	usedts  jmp  ptch34
.ef96	 f0 36		beq $efce	rtch34  beq  +          ; used, no action
.ef98	 b1 6d		lda ($6d),y	        lda  (bmpnt),y  ; get bits
.ef9a	 5d e9 ef	eor $efe9,x	        eor  bmask,x    ; mark sec used
.ef9d	 91 6d		sta ($6d),y	        sta  (bmpnt),y
.ef9f	 20 88 ef	jsr $ef88	        jsr  dtybam     ; set it dirty
.efa2	 a4 6f		ldy $6f		        ldy  t0
.efa4	 b1 6d		lda ($6d),y	        lda  (bmpnt),y  ; count -1
.efa6	 38		sec		        sec
.efa7	 e9 01		sbc #$01	        sbc  #1
.efa9	 91 6d		sta ($6d),y	        sta  (bmpnt),y  ; save it
.efab	 a5 80		lda $80		        lda  track
.efad	 cd 85 fe	cmp $fe85	        cmp  dirtrk
.efb0	 f0 0b		beq $efbd	        beq  use20
.efb2	 bd fa 02	lda $02fa,x	use30   lda  ndbl,x
.efb5	 d0 03		bne $efba	        bne  use10
.efb7	 de fc 02	dec $02fc,x	        dec  ndbh,x
.efba	 de fa 02	dec $02fa,x	use10   dec  ndbl,x
.efbd	 bd fc 02	lda $02fc,x	use20   lda  ndbh,x
.efc0	 d0 0c		bne $efce	        bne  +
.efc2	 bd fa 02	lda $02fa,x	        lda  ndbl,x
.efc5	 4c f0 aa	jmp $aaf0	        jmp  ptch66
.efc8	 ea		nop		        nop
.efc9	 a9 72		lda #$72	        lda  #dskful
.efcb	 20 c7 e6	jsr $e6c7	        jsr  errmsg
.efce	 60		rts		+       rts
.efcf	 20 11 f0	jsr $f011	freuse  jsr  setbam
.efd2	 98		tya			tya
.efd3	 85 6f		sta $6f			sta  temp
.efd5	 a5 81		lda $81		bambit  lda  sector     ; get sector bit in bam
.efd7	 4a		lsr a		        lsr  a          ; sectr/8
.efd8	 4a		lsr a		        lsr  a
.efd9	 4a		lsr a		        lsr  a
.efda	 38		sec		        sec		; adjust it
.efdb	 65 6f		adc $6f		        adc  temp
.efdd	 a8		tay		        tay
.efde	 a5 81		lda $81		        lda  sector     ; get remainder
.efe0	 29 07		and #$07	        and  #$07
.efe2	 aa		tax		        tax     	; bit mask index
.efe3	 b1 6d		lda ($6d),y	        lda  (bmpnt),y
.efe5	 3d e9 ef	and $efe9,x	        and  bmask,x
.efe8	 60		rts		        rts

>efe9	 01 02 04 08 10 20 40 80  	bmask    .byte  1,2,4,8,16,32,64,128

;******  Return to file "serlib.asm"

						.include "bamutl.asm"

;******  Processing file "bamutl.asm"


.eff1	 a9 ff		lda #$ff	wrtbm	lda  #$ff
.eff3	 2c f9 02	bit $02f9		bit  wbam
.eff6	 f0 0c		beq $f004		beq  +
.eff8	 10 0a		bpl $f004		bpl  +
.effa	 70 08		bvs $f004		bvs  +
.effc	 a9 00		lda #$00		lda  #0
.effe	 8d f9 02	sta $02f9		sta  wbam
.f001	 4c 8d a5	jmp $a58d		jmp  wrt_bam
.f004	 60		rts		+	rts
.f005	 4c 38 a7	jmp $a738	clrbam	jmp  ptch25
.f008	 a0 00		ldy #$00	rtch25	ldy  #0
.f00a	 98		tya			tya
.f00b	 91 6d		sta ($6d),y	-	sta  (bmpnt),y
.f00d	 c8		iny			iny
.f00e	 d0 fb		bne $f00b		bne  -
.f010	 60		rts			rts
.f011	 a5 6f		lda $6f		setbam  lda t0
.f013	 48		pha			pha
.f014	 a5 70		lda $70			lda t1
.f016	 48		pha			pha
.f017	 4c 25 aa	jmp $aa25		jmp ptch52
.f01a	 ea		nop			nop
.f01b	 f0 05		beq $f022	rtch52  beq  +
.f01d	 a9 74		lda #$74	        lda  #nodriv
.f01f	 20 45 e6	jsr $e645	        jsr  cmder2
.f022	 20 0f f1	jsr $f10f	+       jsr  bam2a
.f025	 85 6f		sta $6f			sta  t0
.f027	 8a		txa			txa
.f028	 0a		asl a			asl  a
.f029	 85 70		sta $70			sta  t1
.f02b	 aa		tax			tax
.f02c	 a5 80		lda $80			lda  track
.f02e	 dd 9d 02	cmp $029d,x		cmp  bamis,x
.f031	 f0 0b		beq $f03e		beq  +
.f033	 e8		inx			inx
.f034	 86 70		stx $70			stx  t1
.f036	 dd 9d 02	cmp $029d,x		cmp  bamis,x
.f039	 f0 03		beq $f03e		beq  +
.f03b	 20 5b f0	jsr $f05b		jsr  xttu
.f03e	 a5 70		lda $70		+	lda  t1
.f040	 a6 7f		ldx $7f			ldx  drvnum
.f042	 9d 9b 02	sta $029b,x		sta  bamlu,x
.f045	 0a		asl a			asl  a
.f046	 0a		asl a			asl  a
.f047	 18		clc			clc
.f048	 69 a1		adc #$a1		adc  #<bami
.f04a	 85 6d		sta $6d			sta  bmpnt
.f04c	 a9 02		lda #$02		lda  #>bami
.f04e	 69 00		adc #$00		adc  #0
.f050	 85 6e		sta $6e			sta  bmpnt+1
.f052	 a0 00		ldy #$00		ldy  #0
.f054	 68		pla			pla
.f055	 85 70		sta $70			sta  t1
.f057	 68		pla			pla
.f058	 85 6f		sta $6f			sta  t0
.f05a	 60		rts			rts
.f05b	 a6 6f		ldx $6f		xttu    ldx  t0
.f05d	 20 df f0	jsr $f0df	        jsr  redbam
.f060	 a5 7f		lda $7f		        lda  drvnum
.f062	 aa		tax		        tax
.f063	 0a		asl a		        asl  a
.f064	 1d 9b 02	ora $029b,x	        ora  bamlu,x
.f067	 49 01		eor #$01	        eor  #1
.f069	 29 03		and #$03	        and  #3
.f06b	 85 70		sta $70		        sta  t1
.f06d	 20 a5 f0	jsr $f0a5	        jsr  putbam
.f070	 a5 f9		lda $f9		        lda  jobnum
.f072	 0a		asl a		        asl  a
.f073	 aa		tax		        tax
.f074	 a5 80		lda $80		        lda  track
.f076	 0a		asl a		        asl  a
.f077	 0a		asl a		        asl  a
.f078	 95 99		sta $99,x	        sta  buftab,x
.f07a	 a5 70		lda $70		        lda  t1
.f07c	 0a		asl a		        asl  a
.f07d	 0a		asl a		        asl  a
.f07e	 a8		tay		        tay
.f07f	 a1 99		lda ($99,x)	-       lda  (buftab,x)
.f081	 99 a1 02	sta $02a1,y	        sta  bami,y
.f084	 a9 00		lda #$00	        lda  #0
.f086	 81 99		sta ($99,x)	        sta  (buftab,x)
.f088	 f6 99		inc $99,x	        inc  buftab,x
.f08a	 c8		iny		        iny
.f08b	 98		tya		        tya
.f08c	 29 03		and #$03	        and  #3
.f08e	 d0 ef		bne $f07f	        bne  -
.f090	 a6 70		ldx $70		        ldx  t1
.f092	 a5 80		lda $80		        lda  track
.f094	 9d 9d 02	sta $029d,x	        sta  bamis,x
.f097	 ad f9 02	lda $02f9	        lda  wbam
.f09a	 d0 03		bne $f09f	        bne  +
.f09c	 4c 8d a5	jmp $a58d	        jmp  wrt_bam
.f09f					+
.f09f	 09 80		ora #$80	        ora  #$80
.f0a1	 8d f9 02	sta $02f9	        sta  wbam
.f0a4	 60		rts		        rts
.f0a5	 a8		tay		putbam  tay
.f0a6	 b9 9d 02	lda $029d,y	        lda  bamis,y
.f0a9	 f0 25		beq $f0d0	        beq  +
.f0ab	 48		pha		        pha
.f0ac	 a9 00		lda #$00	        lda  #0
.f0ae	 99 9d 02	sta $029d,y	        sta  bamis,y
.f0b1	 a5 f9		lda $f9		        lda  jobnum
.f0b3	 0a		asl a		        asl  a
.f0b4	 aa		tax		        tax
.f0b5	 68		pla		        pla
.f0b6	 0a		asl a		        asl  a
.f0b7	 0a		asl a		        asl  a
.f0b8	 95 99		sta $99,x	        sta  buftab,x
.f0ba	 98		tya		        tya
.f0bb	 0a		asl a		        asl  a
.f0bc	 0a		asl a		        asl  a
.f0bd	 a8		tay		        tay
.f0be	 b9 a1 02	lda $02a1,y	-       lda  bami,y
.f0c1	 81 99		sta ($99,x)	        sta  (buftab,x)
.f0c3	 a9 00		lda #$00	        lda  #0
.f0c5	 99 a1 02	sta $02a1,y	        sta  bami,y
.f0c8	 f6 99		inc $99,x	        inc  buftab,x
.f0ca	 c8		iny		        iny
.f0cb	 98		tya		        tya
.f0cc	 29 03		and #$03	        and  #3
.f0ce	 d0 ee		bne $f0be	        bne -
.f0d0	 60		rts		+	rts
.f0d1	 a5 7f		lda $7f		clnbam  lda  drvnum
.f0d3	 0a		asl a		        asl  a
.f0d4	 aa		tax		        tax
.f0d5	 a9 00		lda #$00	        lda  #0
.f0d7	 9d 9d 02	sta $029d,x	        sta  bamis,x
.f0da	 e8		inx		        inx
.f0db	 9d 9d 02	sta $029d,x	        sta  bamis,x
.f0de	 60		rts		        rts
.f0df					redbam
.f0df	 b5 a7		lda $a7,x		lda  buf0,x
.f0e1	 c9 ff		cmp #$ff	        cmp  #$ff
.f0e3	 d0 25		bne $f10a	        bne  m1
.f0e5	 8a		txa		        txa
.f0e6	 48		pha		        pha
.f0e7	 20 8e d2	jsr $d28e	        jsr  getbuf
.f0ea	 aa		tax		        tax
.f0eb	 10 05		bpl $f0f2	        bpl  +
.f0ed	 a9 70		lda #$70	        lda  #nochnl
.f0ef	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.f0f2					+
.f0f2	 86 f9		stx $f9		        stx  jobnum
.f0f4	 68		pla		        pla
.f0f5	 a8		tay		        tay
.f0f6	 8a		txa		        txa
.f0f7	 09 80		ora #$80	        ora  #$80
.f0f9	 99 a7 00	sta $00a7,y	        sta  buf0,y
.f0fc	 0a		asl		        asl
.f0fd	 aa		tax		        tax
.f0fe	 ad 85 fe	lda $fe85	        lda  dirtrk
.f101	 95 06		sta $06,x	        sta  hdrs,x
.f103	 a9 00		lda #$00	        lda  #0
.f105	 95 07		sta $07,x	        sta  hdrs+1,x
.f107	 4c 67 a6	jmp $a667	        jmp  ptch23
.f10a	 29 0f		and #$0f	m1	and  #15
.f10c	 85 f9		sta $f9			sta  jobnum
.f10e	 60		rts			rts
.f10f	 a9 06		lda #$06	bam2a   lda  #mxchns
.f111	 a6 7f		ldx $7f			ldx  drvnum
.f113	 d0 03		bne $f118		bne  +
.f115	 18		clc			clc
.f116	 69 07		adc #$07		adc  #mxchns+1
.f118	 60		rts		+	rts
.f119	 20 0f f1	jsr $f10f	bam2x   jsr bam2a
.f11c	 aa		tax			tax
.f11d	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "tstfnd.asm"

;******  Processing file "tstfnd.asm"

.f11e	 20 3e de	jsr $de3e	nxtts   jsr  gethdr
.f121	 a9 03		lda #$03	        lda  #3
.f123	 85 6f		sta $6f		        sta  temp       ; set pass count
.f125	 a9 01		lda #$01		lda  #1         ; find next
.f127	 0d f9 02	ora $02f9	        ora  wbam
.f12a	 8d f9 02	sta $02f9	        sta  wbam
.f12d	 4c db a8	jmp $a8db	nxtds   jmp  ptch36
.f130	 20 11 f0	jsr $f011	rtch36  jsr  setbam
.f133	 68		pla		        pla
.f134	 85 6f		sta $6f		        sta  temp
.f136	 b1 6d		lda ($6d),y	        lda  (bmpnt),y
.f138	 d0 39		bne $f173	rtch36a bne  fndnxt
.f13a	 a5 80		lda $80		        lda  track
.f13c	 cd 85 fe	cmp $fe85	        cmp  dirtrk
.f13f	 f0 19		beq $f15a	        beq  nxterr
.f141	 90 1c		bcc $f15f	        bcc  nxt2
.f143	 e6 80		inc $80		        inc  track
.f145	 a5 80		lda $80		        lda  track
.f147	 cd ac 02	cmp $02ac	        cmp  maxtrk
.f14a	 d0 e1		bne $f12d	        bne  nxtds
.f14c	 ae 85 fe	ldx $fe85	        ldx  dirtrk
.f14f	 ca		dex		        dex
.f150	 86 80		stx $80		        stx  track
.f152	 a9 00		lda #$00	        lda  #0
.f154	 85 81		sta $81		        sta  sector
.f156	 c6 6f		dec $6f		        dec  temp
.f158	 d0 d3		bne $f12d	        bne  nxtds
.f15a	 a9 72		lda #$72	nxterr  lda  #dskful
.f15c	 20 c8 c1	jsr $c1c8	        jsr  cmderr
.f15f	 c6 80		dec $80		nxt2    dec  track
.f161	 d0 ca		bne $f12d	        bne  nxtds
.f163	 ae 85 fe	ldx $fe85	nxt3	ldx  dirtrk
.f166	 e8		inx		        inx
.f167	 86 80		stx $80		        stx  track
.f169	 a9 00		lda #$00	        lda  #0
.f16b	 85 81		sta $81		        sta  sector
.f16d	 c6 6f		dec $6f		        dec  temp
.f16f	 d0 bc		bne $f12d	        bne  nxtds
.f171	 f0 e7		beq $f15a	        beq  nxterr
.f173	 a5 81		lda $81		fndnxt  lda  sector     ; get current sec
.f175	 18		clc		        clc     	; add in the incr
.f176	 65 69		adc $69		        adc  secinc
.f178	 85 81		sta $81		        sta  sector
.f17a	 a5 80		lda $80		        lda  track
.f17c	 20 4b f2	jsr $f24b	        jsr  maxsec
.f17f	 8d 4e 02	sta $024e	        sta  lstsec
.f182	 8d 4d 02	sta $024d	        sta  cmd
.f185	 c5 81		cmp $81		        cmp  sector	; is it over?
.f187	 b0 0c		bcs $f195	        bcs  fndn0      ; no..it's ok
.f189	 38		sec			sec
.f18a	 a5 81		lda $81			lda  sector
.f18c	 ed 4e 02	sbc $024e		sbc  lstsec
.f18f	 85 81		sta $81			sta  sector
.f191	 f0 02		beq $f195		beq  fndn0
.f193	 c6 81		dec $81			dec  sector	; -1
.f195	 20 fa f1	jsr $f1fa	fndn0   jsr  getsec
.f198	 f0 03		beq $f19d	        beq  fndn2	; nothing here...
.f19a					fndn1
.f19a	 4c 90 ef	jmp $ef90		jmp  wused
.f19d					fndn2
.f19d	 a9 00		lda #$00	        lda  #0
.f19f	 85 81		sta $81		        sta  sector     ; start again
.f1a1	 20 fa f1	jsr $f1fa		jsr  getsec
.f1a4	 d0 f4		bne $f19a	        bne  fndn1	; sumtin here...
.f1a6	 4c f5 f1	jmp $f1f5		jmp  derr
.f1a9	 a9 01		lda #$01	intts   lda  #1         ; find init opt t&s
.f1ab	 0d f9 02	ora $02f9	        ora  wbam
.f1ae	 8d f9 02	sta $02f9	        sta  wbam
.f1b1	 a5 86		lda $86		        lda  r0
.f1b3	 48		pha		        pha     	; save temp var
.f1b4	 a9 01		lda #$01	        lda  #1         ; clr r0
.f1b6	 85 86		sta $86		        sta  r0
.f1b8	 ad 85 fe	lda $fe85	its1    lda  dirtrk     ; track:= dirtrk-r0
.f1bb	 38		sec		        sec
.f1bc	 e5 86		sbc $86		        sbc  r0
.f1be	 85 80		sta $80		        sta  track
.f1c0	 90 09		bcc $f1cb	        bcc  its2       ; if t>0
.f1c2	 f0 07		beq $f1cb	        beq  its2       ; then begin
.f1c4	 4c 05 a9	jmp $a905		jmp  ptch37     ; set the bam pntr
.f1c7	 b1 6d		lda ($6d),y	rtch37  lda  (bmpnt),y
.f1c9	 d0 1b		bne $f1e6	rtch37a bne  fndsec
.f1cb	 ad 85 fe	lda $fe85	its2    lda  dirtrk     ; trk= dirtrk+r0
.f1ce	 18		clc		        clc
.f1cf	 65 86		adc $86		        adc  r0
.f1d1	 85 80		sta $80		        sta  track
.f1d3	 e6 86		inc $86		        inc  r0         ; next trk
.f1d5	 cd ac 02	cmp $02ac	        cmp  maxtrk
.f1d8	 90 05		bcc $f1df	        bcc  its3       ; next icf cmnd err
.f1da	 a9 67		lda #$67	        lda  #systs
.f1dc	 20 45 e6	jsr $e645	        jsr  cmder2
.f1df	 4c 1e a9	jmp $a91e	its3    jmp  ptch38     ; set ptr
.f1e2	 b1 6d		lda ($6d),y	rtch38  lda  (bmpnt),y
.f1e4	 f0 d2		beq $f1b8	rtch38a beq  its1
.f1e6	 68		pla		fndsec  pla
.f1e7	 85 86		sta $86		        sta  r0         ; restore r0
.f1e9	 a9 00		lda #$00	        lda  #0
.f1eb	 85 81		sta $81		        sta  sector
.f1ed	 20 fa f1	jsr $f1fa	        jsr  getsec
.f1f0	 f0 03		beq $f1f5	        beq  derr
.f1f2	 4c 90 ef	jmp $ef90	        jmp  wused
.f1f5	 a9 71		lda #$71	derr    lda  #direrr
.f1f7	 20 45 e6	jsr $e645	        jsr  cmder2
.f1fa	 4c a9 a8	jmp $a8a9	getsec  jmp  ptch35
.f1fd	 98		tya		rtch35	tya
.f1fe	 48		pha			pha
.f1ff	 20 20 f2	jsr $f220	        jsr  avck       ; chk bits & count
.f202	 a5 80		lda $80		        lda  track
.f204	 20 4b f2	jsr $f24b	        jsr  maxsec
.f207	 8d 4e 02	sta $024e	        sta  lstsec
.f20a	 68		pla		        pla
.f20b	 85 6f		sta $6f		        sta  temp
.f20d	 a5 81		lda $81		gs10    lda  sector
.f20f	 cd 4e 02	cmp $024e	        cmp  lstsec
.f212	 b0 09		bcs $f21d	        bcs  gs20
.f214	 20 d5 ef	jsr $efd5	        jsr  bambit     ; get sector offset
.f217	 d0 06		bne $f21f	        bne  gs30
.f219	 e6 81		inc $81		        inc  sector
.f21b	 d0 f0		bne $f20d	        bne  gs10       ; bra
.f21d	 a9 00		lda #$00	gs20    lda  #0         ; nothing free
.f21f	 60		rts		gs30    rts     	; (z=1): free
.f220	 a5 6f		lda $6f		avck    lda  temp
.f222	 48		pha			pha
.f223	 a9 00		lda #$00		lda  #0
.f225	 85 6f		sta $6f		        sta  temp       ; blk counter
.f227	 ac 86 fe	ldy $fe86	        ldy  bamsiz
.f22a	 88		dey		        dey     	; adjust it
.f22b	 a2 07		ldx #$07	ac10    ldx  #7
.f22d	 b1 6d		lda ($6d),y	ac20    lda  (bmpnt),y
.f22f	 3d e9 ef	and $efe9,x	        and  bmask,x    ; used ?
.f232	 f0 02		beq $f236	        beq  ac30       ; no
.f234	 e6 6f		inc $6f		        inc  temp       ; count it
.f236	 ca		dex		ac30    dex
.f237	 10 f4		bpl $f22d	        bpl  ac20       ; do next bit
.f239	 88		dey		        dey     	; do next byte
.f23a	 d0 ef		bne $f22b	        bne  ac10
.f23c	 b1 6d		lda ($6d),y	        lda  (bmpnt),y
.f23e	 c5 6f		cmp $6f		        cmp  temp
.f240	 d0 04		bne $f246	        bne  ac40       ; counts don't match
.f242	 68		pla			pla
.f243	 85 6f		sta $6f			sta  temp
.f245	 60		rts		        rts
.f246	 a9 71		lda #$71	ac40    lda  #direrr
.f248	 20 45 e6	jsr $e645	        jsr  cmder2
.f24b	 20 4f a7	jsr $a74f	maxsec  jsr  ptch26
.f24e	 dd d6 fe	cmp $fed6,x	-	cmp  trknum-1,x
.f251	 ca		dex			dex
.f252	 b0 fa		bcs $f24e		bcs  -
.f254	 bd d1 fe	lda $fed1,x		lda  numsec,x
.f257	 60		rts			rts

;******  Return to file "serlib.asm"

						.include "system.asm"

;******  Processing file "system.asm"

.f258					killp
.f258	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "lccinit.asm"

;******  Processing file "lccinit.asm"

.f259	 a9 6f		lda #$6f	cntint  lda  #%01101111         ;  data direction
.f25b	 8d 02 1c	sta $1c02	        sta  ddrb2
.f25e	 29 f0		and #$f0	        and  #$ff-$08-$04-$03   ;  turn motor off,set phase a, led off
.f260	 8d 00 1c	sta $1c00	        sta  dskcnt
.f263	 4c f8 a9	jmp $a9f8		jmp  ptch48	; *** rom ds 04/10/85 ***
.f266	 29 fe		and #$fe	rtch48  and  #$ff-$01   ;  neg edge please
.f268	 09 0e		ora #$0e	        ora  #$0e       ; cb1 input only
.f26a	 09 e0		ora #$e0	        ora  #$e0       ; cb2 mode control r/w
.f26c	 8d 0c 1c	sta $1c0c	        sta  pcr2
.f26f	 a9 41		lda #$41	        lda  #$41       ;  cont irq, latch mode
.f271	 8d 0b 1c	sta $1c0b	        sta  acr2
.f274	 a9 00		lda #$00	        lda  #0
.f276	 8d 06 1c	sta $1c06	        sta  t1ll2
.f279	 a9 3a		lda #$3a	        lda  #tim       ; / 8 ms /irq
.f27b	 8d 07 1c	sta $1c07	        sta  t1hl2
.f27e	 8d 05 1c	sta $1c05	        sta  t1hc2      ;  get 6522's attention
.f281	 a9 7f		lda #$7f	        lda  #$7f       ;  clear all irq sources
.f283	 8d 0e 1c	sta $1c0e	        sta  ier2
.f286	 a9 c0		lda #$c0	        lda  #$80+$40
.f288	 8d 0d 1c	sta $1c0d	        sta  ifr2       ;  clear bit
.f28b	 8d 0e 1c	sta $1c0e	        sta  ier2       ;  enable irq
.f28e	 a9 ff		lda #$ff	        lda  #$ff       ;  no current drive
.f290	 85 3e		sta $3e		        sta  cdrive
.f292	 85 51		sta $51		        sta  ftnum      ;  init format flag
.f294	 a9 08		lda #$08	        lda  #$08       ;  header block id
.f296	 85 39		sta $39		        sta  hbid
.f298	 a9 07		lda #$07	        lda  #$07       ;  data block id
.f29a	 85 47		sta $47		        sta  dbid
.f29c	 a9 05		lda #$05	        lda  #<inact
.f29e	 85 62		sta $62		        sta  nxtst
.f2a0	 a9 fa		lda #$fa	        lda  #>inact
.f2a2	 85 63		sta $63		        sta  nxtst+1
.f2a4	 a9 c8		lda #$c8	        lda  #200
.f2a6	 85 64		sta $64		        sta  minstp
.f2a8	 a9 04		lda #$04	        lda  #4
.f2aa	 85 5e		sta $5e		        sta  as
.f2ac	 a9 04		lda #$04	        lda  #$4
.f2ae	 85 5f		sta $5f		        sta  af

;******  Return to file "serlib.asm"

						.include "lcccntrl.asm"

;******  Processing file "lcccntrl.asm"

.f2b0					lcc
.f2b0	 ba		tsx		        tsx     	;  save current stack pointer
.f2b1	 86 49		stx $49		        stx  savsp
.f2b3	 ad 04 1c	lda $1c04	        lda  t1lc2      ; reset irq flag
.f2b6	 ad 0c 1c	lda $1c0c	        lda  pcr2       ;  enable s.o. to 6502
.f2b9	 09 0e		ora #$0e	        ora  #$0e       ;  hi output
.f2bb	 8d 0c 1c	sta $1c0c	        sta  pcr2
.f2be	 a0 05		ldy #$05	top     ldy  #numjob-1  ;  pointer into job que
.f2c0					cont10
.f2c0	 b9 00 00	lda $0000,y	        lda  jobs,y     ;  find a job (msb set)
.f2c3	 10 2e		bpl $f2f3	        bpl  cont20     ;  not one here
.f2c5	 c9 d0		cmp #$d0	        cmp  #jumpc     ;  test if its a jump command
.f2c7	 d0 04		bne $f2cd	        bne  cont30
.f2c9	 98		tya		        tya     	;  put job num in .a
.f2ca	 4c 70 f3	jmp $f370	        jmp  ex2
.f2cd					cont30
.f2cd	 29 01		and #$01	        and  #1         ;  get drive #
.f2cf	 f0 07		beq $f2d8	        beq  cont35
.f2d1	 84 3f		sty $3f		        sty  jobn
.f2d3	 a9 0f		lda #$0f	        lda  #$0f       ; bad drive # error
.f2d5	 4c 69 f9	jmp $f969	        jmp  errr
.f2d8	 aa		tax		cont35  tax
.f2d9	 85 3d		sta $3d		        sta  drive
.f2db	 c5 3e		cmp $3e		        cmp  cdrive     ;  test if current drive
.f2dd	 f0 0a		beq $f2e9	        beq  cont40
.f2df	 20 7e f9	jsr $f97e	        jsr  turnon     ;  turn on drive
.f2e2	 a5 3d		lda $3d		        lda  drive
.f2e4	 85 3e		sta $3e		        sta  cdrive
.f2e6	 4c 9c f9	jmp $f99c	        jmp  end        ;  go clean up
.f2e9	 a5 20		lda $20		cont40  lda  drvst      ;  test if motor up to speed
.f2eb	 30 03		bmi $f2f0	        bmi  cont50
.f2ed	 0a		asl a		        asl  a          ;  test if stepping
.f2ee	 10 09		bpl $f2f9	        bpl  que        ;  not stepping
.f2f0	 4c 9c f9	jmp $f99c	cont50  jmp  end
.f2f3	 88		dey		cont20  dey
.f2f4	 10 ca		bpl $f2c0	        bpl  cont10
.f2f6	 4c 9c f9	jmp $f99c	        jmp  end
.f2f9	 a9 20		lda #$20	que     lda  #$20       ;  status=running
.f2fb	 85 20		sta $20		        sta  drvst
.f2fd	 a0 05		ldy #$05	        ldy  #numjob-1
.f2ff	 84 3f		sty $3f		        sty  jobn
.f301	 20 93 f3	jsr $f393	que10   jsr  setjb
.f304	 30 1a		bmi $f320	        bmi  que20
.f306	 c6 3f		dec $3f		que05   dec  jobn
.f308	 10 f7		bpl $f301	        bpl  que10
.f30a	 a4 41		ldy $41		        ldy  nxtjob
.f30c	 20 95 f3	jsr $f395	        jsr  setjb1
.f30f	 a5 42		lda $42		        lda  nxtrk
.f311	 85 4a		sta $4a		        sta  steps
.f313	 06 4a		asl $4a		        asl  steps      ;  steps*2
.f315	 a9 60		lda #$60	        lda  #$60       ;  set status=stepping
.f317	 85 20		sta $20		        sta  drvst
.f319	 b1 32		lda ($32),y	        lda  (hdrpnt),y         ;  get dest track #
.f31b	 85 22		sta $22		        sta  drvtrk
.f31d	 4c 9c f9	jmp $f99c	fin     jmp  end
.f320	 29 01		and #$01	que20   and  #1         ;  test if same drive
.f322	 c5 3d		cmp $3d		        cmp  drive
.f324	 d0 e0		bne $f306	        bne  que05
.f326	 a5 22		lda $22		        lda  drvtrk
.f328	 f0 12		beq $f33c	        beq  gotu       ;  uninit. track #
.f32a	 38		sec		        sec     	;  calc distance to track
.f32b	 f1 32		sbc ($32),y	        sbc  (hdrpnt),y
.f32d	 f0 0d		beq $f33c	        beq  gotu       ;  on track
.f32f	 49 ff		eor #$ff	        eor  #$ff       ;  2's comp
.f331	 85 42		sta $42		        sta  nxtrk
.f333	 e6 42		inc $42		        inc  nxtrk
.f335	 a5 3f		lda $3f		        lda  jobn       ;  save job# and dist to track
.f337	 85 41		sta $41		        sta  nxtjob
.f339	 4c 06 f3	jmp $f306	        jmp  que05
.f33c	 a2 04		ldx #$04	gotu    ldx  #4         ;  set track and sectr
.f33e	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.f340	 85 40		sta $40		        sta  tracc
.f342	 dd 47 c0	cmp $c047,x	gotu10  cmp  trackn-1,x ; *** rom ds 11/7/86 ***, set density for tracks > 35
.f345	 ca		dex		        dex
.f346	 b0 fa		bcs $f342	        bcs  gotu10
.f348	 bd d1 fe	lda $fed1,x	        lda  numsec,x
.f34b	 85 43		sta $43		        sta  sectr
.f34d	 8a		txa		        txa     	;  set density
.f34e	 0a		asl a		        asl  a
.f34f	 0a		asl a		        asl  a
.f350	 0a		asl a		        asl  a
.f351	 0a		asl a		        asl  a
.f352	 0a		asl a		        asl  a
.f353	 85 44		sta $44		        sta  work
.f355	 ad 00 1c	lda $1c00	        lda  dskcnt
.f358	 29 9f		and #$9f	        and  #$9f       ;  clear density bits
.f35a	 05 44		ora $44		        ora  work
.f35c	 8d 00 1c	sta $1c00	        sta  dskcnt
.f35f	 a6 3d		ldx $3d		        ldx  drive      ;  drive num in .x
.f361	 a5 45		lda $45		        lda  job        ;  yes, go do the job
.f363	 c9 40		cmp #$40	        cmp  #bumpc     ;  test for bump
.f365	 f0 15		beq $f37c	        beq  bmp
.f367	 c9 60		cmp #$60	exe     cmp  #execd     ;  test if execute
.f369	 f0 03		beq $f36e	        beq  ex
.f36b	 4c b1 f3	jmp $f3b1	        jmp  seak       ;  do a sector seek
.f36e	 a5 3f		lda $3f		ex      lda  jobn       ;  jump to buffer
.f370	 18		clc		ex2     clc
.f371	 69 03		adc #$03	        adc  #>bufs
.f373	 85 31		sta $31		        sta  bufpnt+1
.f375	 a9 00		lda #$00	        lda  #0
.f377	 85 30		sta $30		        sta  bufpnt
.f379	 6c 30 00	jmp ($0030)	ex3     jmp  (bufpnt)
.f37c					bmp
.f37c	 a9 60		lda #$60	        lda  #$60       ;  set status=stepping
.f37e	 85 20		sta $20		        sta  drvst
.f380	 ad 00 1c	lda $1c00	        lda  dskcnt
.f383	 29 fc		and #$fc	        and  #$ff-$03   ;  set phase a
.f385	 8d 00 1c	sta $1c00	        sta  dskcnt
.f388	 a9 a4		lda #$a4	        lda  #256-92    ;  step back 45 traks
.f38a	 85 4a		sta $4a		        sta  steps
.f38c	 a9 01		lda #$01	        lda  #1         ;  drvtrk now 1
.f38e	 85 22		sta $22		        sta  drvtrk
.f390	 4c 69 f9	jmp $f969	        jmp  errr       ;  job done return 1
.f393	 a4 3f		ldy $3f		setjb   ldy  jobn
.f395	 b9 00 00	lda $0000,y	setjb1  lda  jobs,y
.f398	 48		pha		        pha
.f399	 10 10		bpl $f3ab	        bpl  setj10     ;  no job here
.f39b	 29 78		and #$78	        and  #$78
.f39d	 85 45		sta $45		        sta  job
.f39f	 98		tya		        tya
.f3a0	 0a		asl a		        asl  a
.f3a1	 69 06		adc #$06	        adc  #<hdrs
.f3a3	 85 32		sta $32		        sta  hdrpnt
.f3a5	 98		tya		        tya     	;  point at buffer
.f3a6	 18		clc		        clc
.f3a7	 69 03		adc #$03	        adc  #>bufs
.f3a9	 85 31		sta $31		        sta  bufpnt+1
.f3ab	 a0 00		ldy #$00	setj10  ldy  #0
.f3ad	 84 30		sty $30		        sty  bufpnt
.f3af	 68		pla		        pla
.f3b0	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "lccseek.asm"

;******  Processing file "lccseek.asm"

.f3b1	 a2 5a		ldx #$5a	seak    ldx  #90        ;  search 90 headers
.f3b3	 86 4b		stx $4b		        stx  tmp
.f3b5	 a2 00		ldx #$00	        ldx  #0         ; read in 8 gcr bytes
.f3b7	 a9 52		lda #$52	        lda  #$52       ;  header block id
.f3b9	 85 24		sta $24		        sta  stab
.f3bb	 20 56 f5	jsr $f556	seek10  jsr  sync       ;  find sync char
.f3be	 50 fe		bvc $f3be	        bvc  *          ;  wait for block id
.f3c0	 b8		clv		        clv
.f3c1	 ad 01 1c	lda $1c01	        lda  data2
.f3c4	 c5 24		cmp $24		        cmp  stab       ;  test if header block
.f3c6	 d0 3f		bne $f407	        bne  seek20     ;  not header
.f3c8	 50 fe		bvc $f3c8	seek15  bvc  *
.f3ca	 b8		clv		        clv     	;  read in gcr header
.f3cb	 ad 01 1c	lda $1c01	        lda  data2
.f3ce	 95 25		sta $25,x	        sta  stab+1,x
.f3d0	 e8		inx		        inx
.f3d1	 e0 07		cpx #$07	        cpx  #7
.f3d3	 d0 f3		bne $f3c8	        bne  seek15
.f3d5	 20 97 f4	jsr $f497	        jsr  cnvbin     ;  convert header in stab to binary in header
.f3d8	 a0 04		ldy #$04	        ldy  #4         ;  compute checksum
.f3da	 a9 00		lda #$00	        lda  #0
.f3dc	 59 16 00	eor $0016,y	seek30  eor  header,y
.f3df	 88		dey		        dey
.f3e0	 10 fa		bpl $f3dc	        bpl  seek30
.f3e2	 c9 00		cmp #$00	        cmp  #0         ;  test if ok
.f3e4	 d0 38		bne $f41e	        bne  cserr      ;  nope, checksum error in header
.f3e6	 a6 3e		ldx $3e		        ldx  cdrive     ;  update drive track#
.f3e8	 a5 18		lda $18		        lda  header+2
.f3ea	 95 22		sta $22,x	        sta  drvtrk,x
.f3ec	 a5 45		lda $45		        lda  job        ;  test if a seek job
.f3ee	 c9 30		cmp #$30	        cmp  #$30
.f3f0	 f0 1e		beq $f410	        beq  eseek
.f3f2	 a5 3e		lda $3e		        lda  cdrive
.f3f4	 0a		asl a		        asl  a          ;  test if correct id
.f3f5	 a8		tay		        tay
.f3f6	 b9 12 00	lda $0012,y	        lda  dskid,y
.f3f9	 c5 16		cmp $16		        cmp  header
.f3fb	 d0 1e		bne $f41b	        bne  badid
.f3fd	 b9 13 00	lda $0013,y	        lda  dskid+1,y
.f400	 c5 17		cmp $17		        cmp  header+1
.f402	 d0 17		bne $f41b	        bne  badid
.f404	 4c 23 f4	jmp $f423	        jmp  wsect      ;  find best sector to service
.f407	 c6 4b		dec $4b		seek20  dec  tmp        ;  search more?
.f409	 d0 b0		bne $f3bb	        bne  seek10     ; yes
.f40b	 a9 02		lda #$02	        lda  #2         ;  cant find a sector
.f40d	 20 69 f9	jsr $f969	        jsr  errr
.f410	 a5 16		lda $16		eseek   lda  header     ; harris fix....
.f412	 85 12		sta $12		        sta  dskid      ; ....
.f414	 a5 17		lda $17		        lda  header+1   ; ....
.f416	 85 13		sta $13		        sta  dskid+1    ; ....
.f418	 a9 01		lda #$01	done    lda  #1         ;  return ok code

>f41a	 2c                       		.byte    skip2

.f41b	 a9 0b		lda #$0b	badid   lda  #11        ;  disk id mismatch

>f41d	 2c                       		.byte    skip2

.f41e	 a9 09		lda #$09	cserr   lda  #9         ;  checksum error in header
.f420	 4c 69 f9	jmp $f969	        jmp  errr
.f423	 a9 7f		lda #$7f	wsect   lda  #$7f       ;  find best job
.f425	 85 4c		sta $4c		        sta  csect
.f427	 a5 19		lda $19		        lda  header+3   ;  get upcoming sector #
.f429	 18		clc		        clc
.f42a	 69 02		adc #$02	        adc  #2
.f42c	 c5 43		cmp $43		        cmp  sectr
.f42e	 90 02		bcc $f432	        bcc  l460
.f430	 e5 43		sbc $43		        sbc  sectr      ; wrap around
.f432	 85 4d		sta $4d		l460    sta  nexts      ;  next sector
.f434	 a2 05		ldx #$05	        ldx  #numjob-1
.f436	 86 3f		stx $3f		        stx  jobn
.f438	 a2 ff		ldx #$ff	        ldx  #$ff
.f43a	 20 93 f3	jsr $f393	l480    jsr  setjb
.f43d	 10 44		bpl $f483	        bpl  l470
.f43f	 85 44		sta $44		        sta  work
.f441	 29 01		and #$01	        and  #1
.f443	 c5 3e		cmp $3e		        cmp  cdrive     ;  test if same drive
.f445	 d0 3c		bne $f483	        bne  l470       ;  nope
.f447	 a0 00		ldy #$00	        ldy  #0         ;  test if same track
.f449	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.f44b	 c5 40		cmp $40		        cmp  tracc
.f44d	 d0 34		bne $f483	        bne  l470
.f44f	 a5 45		lda $45		        lda  job        ;  test if execute job
.f451	 c9 60		cmp #$60	        cmp  #execd
.f453	 f0 0c		beq $f461	        beq  l465
.f455	 a0 01		ldy #$01	        ldy  #1
.f457	 38		sec		        sec
.f458	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.f45a	 e5 4d		sbc $4d		        sbc  nexts
.f45c	 10 03		bpl $f461	        bpl  l465
.f45e	 18		clc		        clc
.f45f	 65 43		adc $43		        adc  sectr
.f461	 c5 4c		cmp $4c		l465    cmp  csect
.f463	 b0 1e		bcs $f483	        bcs  l470
.f465	 48		pha		        pha     	;  save it
.f466	 a5 45		lda $45		        lda  job
.f468	 f0 14		beq $f47e	        beq  tstrdj     ;  must be a read
.f46a	 68		pla		        pla
.f46b	 c9 04		cmp #$04	        cmp  #wrtmin    ;  +if(csect<4)return;
.f46d	 90 14		bcc $f483	        bcc  l470       ;  +if(csect>8)return;
.f46f	 c9 08		cmp #$08	        cmp  #wrtmax
.f471	 b0 10		bcs $f483	        bcs  l470
.f473	 85 4c		sta $4c		doitt   sta  csect      ; its better
.f475	 a5 3f		lda $3f		        lda  jobn
.f477	 aa		tax		        tax
.f478	 69 03		adc #$03	        adc  #>bufs
.f47a	 85 31		sta $31		        sta  bufpnt+1
.f47c	 d0 05		bne $f483	        bne  l470
.f47e	 68		pla		tstrdj  pla
.f47f	 c9 06		cmp #$06	        cmp  #rdmax     ;  if(csect>6)return;
.f481	 90 f0		bcc $f473	        bcc  doitt
.f483	 c6 3f		dec $3f		l470    dec  jobn
.f485	 10 b3		bpl $f43a	        bpl  l480
.f487	 8a		txa		        txa     	;  test if a job to do
.f488	 10 03		bpl $f48d	        bpl  l490
.f48a	 4c 9c f9	jmp $f99c	        jmp  end        ;  no job found
.f48d	 86 3f		stx $3f		l490    stx  jobn
.f48f	 20 93 f3	jsr $f393	        jsr  setjb
.f492	 a5 45		lda $45		        lda  job
.f494	 4c ca f4	jmp $f4ca	        jmp  reed
.f497	 a5 30		lda $30		cnvbin  lda  bufpnt
.f499	 48		pha		        pha
.f49a	 a5 31		lda $31		        lda  bufpnt+1
.f49c	 48		pha		        pha     	;  save buffer pntr
.f49d	 a9 24		lda #$24	        lda  #<stab
.f49f	 85 30		sta $30		        sta  bufpnt     ;  point at gcr code
.f4a1	 a9 00		lda #$00	        lda  #>stab
.f4a3	 85 31		sta $31		        sta  bufpnt+1
.f4a5	 a9 00		lda #$00	        lda  #0
.f4a7	 85 34		sta $34		        sta  gcrpnt
.f4a9	 20 e6 f7	jsr $f7e6	        jsr  get4gb     ;  convert 4 bytes
.f4ac	 a5 55		lda $55		        lda  btab+3
.f4ae	 85 18		sta $18		        sta  header+2
.f4b0	 a5 54		lda $54		        lda  btab+2
.f4b2	 85 19		sta $19		        sta  header+3
.f4b4	 a5 53		lda $53		        lda  btab+1
.f4b6	 85 1a		sta $1a		        sta  header+4
.f4b8	 20 e6 f7	jsr $f7e6	        jsr  get4gb     ;  get 2 more
.f4bb	 a5 52		lda $52		        lda  btab       ;  get id
.f4bd	 85 17		sta $17		        sta  header+1
.f4bf	 a5 53		lda $53		        lda  btab+1
.f4c1	 85 16		sta $16		        sta  header
.f4c3	 68		pla		        pla
.f4c4	 85 31		sta $31		        sta  bufpnt+1   ; restore pointer
.f4c6	 68		pla		        pla
.f4c7	 85 30		sta $30		        sta  bufpnt
.f4c9	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "lccread.asm"

;******  Processing file "lccread.asm"

.f4ca	 c9 00		cmp #$00	reed    cmp  #0         ;  test if read job
.f4cc	 f0 03		beq $f4d1	        beq  read01     ;  go test if write
.f4ce	 4c 6e f5	jmp $f56e	        jmp  wright
.f4d1	 20 0a f5	jsr $f50a	read01  jsr  dstrt      ;  find header and start reading data
.f4d4	 50 fe		bvc $f4d4	read11  bvc  *          ;  wait for byte
.f4d6	 b8		clv		        clv
.f4d7	 ad 01 1c	lda $1c01	        lda  data2      ;  store away data
.f4da	 91 30		sta ($30),y	        sta  (bufpnt),y ;  in data buffer
.f4dc	 c8		iny		        iny
.f4dd	 d0 f5		bne $f4d4	        bne  read11
.f4df	 a0 ba		ldy #$ba	        ldy  #255-toprd ;  store rest in overflow buffer
.f4e1	 50 fe		bvc $f4e1	read20  bvc  *
.f4e3	 b8		clv		        clv
.f4e4	 ad 01 1c	lda $1c01	        lda  data2
.f4e7	 99 00 01	sta $0100,y	        sta  ovrbuf,y
.f4ea	 c8		iny		        iny
.f4eb	 d0 f4		bne $f4e1	        bne  read20
.f4ed	 20 e0 f8	jsr $f8e0	        jsr  gcrbin     ;  convert buffer to binary
.f4f0	 a5 38		lda $38		        lda  bid        ;  test if its a data block
.f4f2	 c5 47		cmp $47		        cmp  dbid
.f4f4	 f0 05		beq $f4fb	        beq  read28
.f4f6	 a9 04		lda #$04	        lda  #4         ;  not a data block
.f4f8	 4c 69 f9	jmp $f969	        jmp  errr
.f4fb	 20 e9 f5	jsr $f5e9	read28  jsr  chkblk     ;  calc checksum
.f4fe	 c5 3a		cmp $3a		        cmp  chksum
.f500	 f0 03		beq $f505	        beq  read40
.f502	 a9 05		lda #$05	        lda  #5         ;  data block checksum error

>f504	 2c                       		.byte  skip2

.f505	 a9 01		lda #$01	read40  lda  #1         ;  read data block ok
.f507	 4c 69 f9	jmp $f969	        jmp  errr
.f50a	 20 10 f5	jsr $f510	dstrt   jsr  srch       ;  find header
.f50d	 4c 56 f5	jmp $f556	        jmp  sync       ;  and then data block sync
.f510	 a5 3d		lda $3d		srch    lda  drive      ;  create header image
.f512	 0a		asl a		        asl  a
.f513	 aa		tax		        tax
.f514	 b5 12		lda $12,x	        lda  dskid,x    ;  get master id for the drive
.f516	 85 16		sta $16		        sta  header
.f518	 b5 13		lda $13,x	        lda  dskid+1,x
.f51a	 85 17		sta $17		        sta  header+1
.f51c	 a0 00		ldy #$00	        ldy  #0         ;  get track,sector
.f51e	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.f520	 85 18		sta $18		        sta  header+2
.f522	 c8		iny		        iny
.f523	 b1 32		lda ($32),y	        lda  (hdrpnt),y
.f525	 85 19		sta $19		        sta  header+3
.f527	 a9 00		lda #$00	        lda  #0
.f529	 45 16		eor $16		        eor  header
.f52b	 45 17		eor $17		        eor  header+1
.f52d	 45 18		eor $18		        eor  header+2
.f52f	 45 19		eor $19		        eor  header+3
.f531	 85 1a		sta $1a		        sta  header+4   ;  store the checksum
.f533	 20 34 f9	jsr $f934	        jsr  conhdr     ;  convert header to gcr
.f536	 a2 5a		ldx #$5a	        ldx  #90        ;  search 90 sync chars
.f538	 20 56 f5	jsr $f556	srch20  jsr  sync       ;  find sync
.f53b	 a0 00		ldy #$00	        ldy  #0         ;  test 8 gcr bytes
.f53d	 50 fe		bvc $f53d	srch25  bvc  *
.f53f	 b8		clv		        clv     	;  wait for byte
.f540	 ad 01 1c	lda $1c01	        lda  data2
.f543	 d9 24 00	cmp $0024,y	        cmp  stab,y     ;  test if the same
.f546	 d0 06		bne $f54e	        bne  srch30     ;  nope
.f548	 c8		iny		        iny
.f549	 c0 08		cpy #$08	        cpy  #8
.f54b	 d0 f0		bne $f53d	        bne  srch25
.f54d	 60		rts		        rts
.f54e	 ca		dex		srch30  dex     	; try again
.f54f	 d0 e7		bne $f538	        bne  srch20
.f551	 a9 02		lda #$02	        lda  #2         ;  cant find this header
.f553	 4c 69 f9	jmp $f969	err     jmp  errr
.f556					sync
.f556	 a9 d0		lda #$d0	        lda  #$80+80    ;  wait 20 ms for sync max
.f558	 8d 05 18	sta $1805	        sta  timer1
.f55b	 a9 03		lda #$03	        lda  #3         ;  error code for no sync
.f55d	 2c 05 18	bit $1805	sync10  bit  timer1     ;  test for time out
.f560	 10 f1		bpl $f553	        bpl  err
.f562	 2c 00 1c	bit $1c00	        bit  dskcnt     ;  test for sync
.f565	 30 f6		bmi $f55d	        bmi  sync10
.f567	 ad 01 1c	lda $1c01	        lda  data2      ;  reset pa latch
.f56a	 b8		clv		        clv
.f56b	 a0 00		ldy #$00	        ldy  #0         ;  clear pointer
.f56d	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "lccwrt.asm"

;******  Processing file "lccwrt.asm"

.f56e	 c9 10		cmp #$10	wright  cmp  #$10       ;  test if write
.f570	 f0 03		beq $f575	        beq  wrt05
.f572	 4c 91 f6	jmp $f691	        jmp  vrfy
.f575	 20 e9 f5	jsr $f5e9	wrt05   jsr  chkblk     ;  get block checksum
.f578	 85 3a		sta $3a		        sta  chksum
.f57a	 ad 00 1c	lda $1c00	        lda  dskcnt     ;  test for write protect
.f57d	 29 10		and #$10	        and  #$10
.f57f	 d0 05		bne $f586	        bne  wrt10      ;  not  protected
.f581	 a9 08		lda #$08	        lda  #8         ;  write protect error
.f583	 4c 69 f9	jmp $f969	        jmp  errr
.f586	 20 8f f7	jsr $f78f	wrt10   jsr  bingcr     ;  convert buffer to write image
.f589	 20 10 f5	jsr $f510	        jsr  srch       ;  find header
.f58c	 a2 09		ldx #$09	        ldx  #gap1-2    ;  wait out header gap
.f58e	 50 fe		bvc $f58e	wrt20   bvc  *
.f590	 b8		clv		        clv
.f591	 ca		dex		        dex     	;  test if done yet
.f592	 d0 fa		bne $f58e	        bne  wrt20
.f594	 a9 ff		lda #$ff	        lda  #$ff       ;  make output $ff
.f596	 8d 03 1c	sta $1c03	        sta  ddra2
.f599	 ad 0c 1c	lda $1c0c	        lda  pcr2       ;  set write mode
.f59c	 29 1f		and #$1f	        and  #$ff-$e0
.f59e	 09 c0		ora #$c0	        ora  #$c0
.f5a0	 8d 0c 1c	sta $1c0c	        sta  pcr2
.f5a3	 a9 ff		lda #$ff	        lda  #$ff       ;  write 5 gcr sync
.f5a5	 a2 05		ldx #$05	        ldx  #numsyn    ;
.f5a7	 8d 01 1c	sta $1c01	        sta  data2
.f5aa	 b8		clv		        clv
.f5ab	 50 fe		bvc $f5ab	wrtsnc  bvc  *
.f5ad	 b8		clv		        clv
.f5ae	 ca		dex		        dex
.f5af	 d0 fa		bne $f5ab	        bne  wrtsnc
.f5b1	 a0 bb		ldy #$bb	        ldy  #256-topwrt
.f5b3	 b9 00 01	lda $0100,y	wrt30   lda  ovrbuf,y   ;  get a char
.f5b6	 50 fe		bvc $f5b6	        bvc  *          ;  wait until ready
.f5b8	 b8		clv		        clv
.f5b9	 8d 01 1c	sta $1c01	        sta  data2      ;  stuff it
.f5bc	 c8		iny		        iny
.f5bd	 d0 f4		bne $f5b3	        bne  wrt30      ;  do next char
.f5bf	 b1 30		lda ($30),y	wrt40   lda  (bufpnt),y ;  now do buffer
.f5c1	 50 fe		bvc $f5c1	        bvc  *          ;  wait until ready
.f5c3	 b8		clv		        clv
.f5c4	 8d 01 1c	sta $1c01	        sta  data2      ;  stuff it again
.f5c7	 c8		iny		        iny
.f5c8	 d0 f5		bne $f5bf	        bne  wrt40      ;  do the whole thing
.f5ca	 50 fe		bvc $f5ca	        bvc  *          ;  wait for last char to write out
.f5cc	 ad 0c 1c	lda $1c0c	        lda  pcr2       ;  goto read mode
.f5cf	 09 e0		ora #$e0	        ora  #$e0
.f5d1	 8d 0c 1c	sta $1c0c	        sta  pcr2
.f5d4	 a9 00		lda #$00	        lda  #0         ;  make data2 input $00
.f5d6	 8d 03 1c	sta $1c03	        sta  ddra2
.f5d9	 20 f2 f5	jsr $f5f2	        jsr  wtobin     ;  convert write image to binary
.f5dc	 a4 3f		ldy $3f		        ldy  jobn       ;  make job a verify
.f5de	 b9 00 00	lda $0000,y	        lda  jobs,y
.f5e1	 49 30		eor #$30	        eor  #$30
.f5e3	 99 00 00	sta $0000,y	        sta  jobs,y
.f5e6	 4c b1 f3	jmp $f3b1	        jmp  seak       ;  scan job que
.f5e9	 a9 00		lda #$00	chkblk  lda  #0         ;  get eor checksum
.f5eb	 a8		tay		        tay
.f5ec	 51 30		eor ($30),y	chkb10  eor  (bufpnt),y
.f5ee	 c8		iny		        iny
.f5ef	 d0 fb		bne $f5ec	        bne  chkb10
.f5f1	 60		rts		        rts     	;  return checksum in .a
.f5f2	 a9 00		lda #$00	wtobin  lda  #0         ;  init pointer
.f5f4	 85 2e		sta $2e		        sta  savpnt
.f5f6	 85 30		sta $30		        sta  bufpnt     ;  lsb
.f5f8	 85 4f		sta $4f		        sta  nxtpnt
.f5fa	 a5 31		lda $31		        lda  bufpnt+1   ; goto buffer next
.f5fc	 85 4e		sta $4e		        sta  nxtbf
.f5fe	 a9 01		lda #$01	        lda  #>ovrbuf   ;  use overflow first
.f600	 85 31		sta $31		        sta  bufpnt+1
.f602	 85 2f		sta $2f		        sta  savpnt+1
.f604	 a9 bb		lda #$bb	        lda  #256-topwrt
.f606	 85 34		sta $34		        sta  gcrpnt     ;  get here first
.f608	 85 36		sta $36		        sta  bytcnt     ;  store here
.f60a	 20 e6 f7	jsr $f7e6	        jsr  get4gb     ;  get first four- id and 3 data
.f60d	 a5 52		lda $52		        lda  btab       ;  save bid
.f60f	 85 38		sta $38		        sta  bid
.f611	 a4 36		ldy $36		        ldy  bytcnt
.f613	 a5 53		lda $53		        lda  btab+1
.f615	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f617	 c8		iny		        iny
.f618	 a5 54		lda $54		        lda  btab+2
.f61a	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f61c	 c8		iny		        iny
.f61d	 a5 55		lda $55		        lda  btab+3
.f61f	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f621	 c8		iny		        iny
.f622	 84 36		sty $36		        sty  bytcnt
.f624	 20 e6 f7	jsr $f7e6	wtob14  jsr  get4gb     ; do rest of overflow buffer
.f627	 a4 36		ldy $36		        ldy  bytcnt
.f629	 a5 52		lda $52		        lda  btab
.f62b	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f62d	 c8		iny		        iny
.f62e	 a5 53		lda $53		        lda  btab+1
.f630	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f632	 c8		iny		        iny
.f633	 f0 0e		beq $f643	        beq  wtob50
.f635	 a5 54		lda $54		        lda  btab+2
.f637	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f639	 c8		iny		        iny
.f63a	 a5 55		lda $55		        lda  btab+3
.f63c	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f63e	 c8		iny		        iny
.f63f	 84 36		sty $36		        sty  bytcnt
.f641	 d0 e1		bne $f624	        bne  wtob14     ;  jmp
.f643					wtob50
.f643	 a5 54		lda $54		        lda  btab+2
.f645	 91 30		sta ($30),y	        sta  (bufpnt),y
.f647	 c8		iny		        iny
.f648	 a5 55		lda $55		        lda  btab+3
.f64a	 91 30		sta ($30),y	        sta  (bufpnt),y
.f64c	 c8		iny		        iny
.f64d	 84 36		sty $36		        sty  bytcnt
.f64f	 20 e6 f7	jsr $f7e6	wtob53  jsr  get4gb
.f652	 a4 36		ldy $36		        ldy  bytcnt
.f654	 a5 52		lda $52		        lda  btab
.f656	 91 30		sta ($30),y	        sta  (bufpnt),y
.f658	 c8		iny		        iny
.f659	 a5 53		lda $53		        lda  btab+1
.f65b	 91 30		sta ($30),y	        sta  (bufpnt),y
.f65d	 c8		iny		        iny
.f65e	 a5 54		lda $54		        lda  btab+2
.f660	 91 30		sta ($30),y	        sta  (bufpnt),y
.f662	 c8		iny		        iny
.f663	 a5 55		lda $55		        lda  btab+3
.f665	 91 30		sta ($30),y	        sta  (bufpnt),y
.f667	 c8		iny		        iny
.f668	 84 36		sty $36		        sty  bytcnt
.f66a	 c0 bb		cpy #$bb	        cpy  #187
.f66c	 90 e1		bcc $f64f	        bcc  wtob53
.f66e	 a9 45		lda #$45	wtob52  lda  #69        ;  move buffer up
.f670	 85 2e		sta $2e		        sta  savpnt
.f672	 a5 31		lda $31		        lda  bufpnt+1
.f674	 85 2f		sta $2f		        sta  savpnt+1
.f676	 a0 ba		ldy #$ba	        ldy  #256-topwrt-1
.f678	 b1 30		lda ($30),y	wtob55  lda  (bufpnt),y
.f67a	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f67c	 88		dey		        dey
.f67d	 d0 f9		bne $f678	        bne  wtob55
.f67f	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f681	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f683	 a2 bb		ldx #$bb	        ldx  #256-topwrt
.f685	 bd 00 01	lda $0100,x	wtob57  lda  ovrbuf,x
.f688	 91 30		sta ($30),y	        sta  (bufpnt),y
.f68a	 c8		iny		        iny
.f68b	 e8		inx		        inx
.f68c	 d0 f7		bne $f685	        bne  wtob57
.f68e	 86 50		stx $50		        stx  gcrflg     ;  clear buffer gcr flag
.f690	 60		rts		        rts
.f691	 c9 20		cmp #$20	vrfy    cmp  #$20       ;  test if verify
.f693	 f0 03		beq $f698	        beq  vrf10
.f695	 4c ca f6	jmp $f6ca	        jmp  sectsk
.f698					vrf10
.f698	 20 e9 f5	jsr $f5e9	        jsr  chkblk     ;  get block checksum
.f69b	 85 3a		sta $3a		        sta  chksum
.f69d	 20 8f f7	jsr $f78f	        jsr  bingcr     ;  convert to verify image
.f6a0	 20 0a f5	jsr $f50a	        jsr  dstrt
.f6a3	 a0 bb		ldy #$bb	        ldy  #256-topwrt
.f6a5	 b9 00 01	lda $0100,y	vrf15   lda  ovrbuf,y   ;  get char
.f6a8	 50 fe		bvc $f6a8	        bvc  *
.f6aa	 b8		clv		        clv
.f6ab	 4d 01 1c	eor $1c01	        eor  data2      ;  test if same
.f6ae	 d0 15		bne $f6c5	        bne  vrf20      ;  verify error
.f6b0	 c8		iny		        iny
.f6b1	 d0 f2		bne $f6a5	        bne  vrf15      ;  next byte
.f6b3	 b1 30		lda ($30),y	vrf30   lda  (bufpnt),y ;  now do buffer
.f6b5	 50 fe		bvc $f6b5	        bvc  *
.f6b7	 b8		clv		        clv     ;  wait for char
.f6b8	 4d 01 1c	eor $1c01	        eor  data2      ;  test if same
.f6bb	 d0 08		bne $f6c5	        bne  vrf20      ;  error
.f6bd	 c8		iny		        iny
.f6be	 c0 fd		cpy #$fd	        cpy  #$fd       ;  dont test off bytes
.f6c0	 d0 f1		bne $f6b3	        bne  vrf30
.f6c2	 4c 18 f4	jmp $f418	        jmp  done       ;  verify ok
.f6c5	 a9 07		lda #$07	vrf20   lda  #7         ;  verify error
.f6c7	 4c 69 f9	jmp $f969	        jmp  errr
.f6ca	 20 10 f5	jsr $f510	sectsk  jsr  srch       ;  sector seek
.f6cd	 4c 18 f4	jmp $f418	        jmp  done

;******  Return to file "serlib.asm"

					        .include "lccbingc.asm"

;******  Processing file "lccbingc.asm"

.f6d0	 a9 00		lda #$00	put4bg  lda  #0         ;  clear table
.f6d2	 85 57		sta $57		        sta  gtab+1
.f6d4	 85 5a		sta $5a		        sta  gtab+4
.f6d6	 a4 34		ldy $34		        ldy  gcrpnt
.f6d8	 a5 52		lda $52		        lda  btab
.f6da	 29 f0		and #$f0	        and  #$f0
.f6dc	 4a		lsr a		        lsr  a
.f6dd	 4a		lsr a		        lsr  a
.f6de	 4a		lsr a		        lsr  a
.f6df	 4a		lsr a		        lsr  a
.f6e0	 aa		tax		        tax
.f6e1	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f6e4	 0a		asl a		        asl  a
.f6e5	 0a		asl a		        asl  a
.f6e6	 0a		asl a		        asl  a
.f6e7	 85 56		sta $56		        sta  gtab
.f6e9	 a5 52		lda $52		        lda  btab
.f6eb	 29 0f		and #$0f	        and  #$0f
.f6ed	 aa		tax		        tax
.f6ee	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f6f1	 6a		ror a		        ror  a
.f6f2	 66 57		ror $57		        ror  gtab+1
.f6f4	 6a		ror a		        ror  a
.f6f5	 66 57		ror $57		        ror  gtab+1
.f6f7	 29 07		and #$07	        and  #$07
.f6f9	 05 56		ora $56		        ora  gtab
.f6fb	 91 30		sta ($30),y	        sta  (bufpnt),y
.f6fd	 c8		iny		        iny
.f6fe	 a5 53		lda $53		        lda  btab+1
.f700	 29 f0		and #$f0	        and  #$f0
.f702	 4a		lsr a		        lsr  a
.f703	 4a		lsr a		        lsr  a
.f704	 4a		lsr a		        lsr  a
.f705	 4a		lsr a		        lsr  a
.f706	 aa		tax		        tax
.f707	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f70a	 0a		asl a		        asl  a
.f70b	 05 57		ora $57		        ora  gtab+1
.f70d	 85 57		sta $57		        sta  gtab+1
.f70f	 a5 53		lda $53		        lda  btab+1
.f711	 29 0f		and #$0f	        and  #$0f
.f713	 aa		tax		        tax
.f714	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f717	 2a		rol a		        rol  a
.f718	 2a		rol a		        rol  a
.f719	 2a		rol a		        rol  a
.f71a	 2a		rol a		        rol  a
.f71b	 85 58		sta $58		        sta  gtab+2
.f71d	 2a		rol a		        rol  a
.f71e	 29 01		and #$01	        and  #1
.f720	 05 57		ora $57		        ora  gtab+1
.f722	 91 30		sta ($30),y	        sta  (bufpnt),y
.f724	 c8		iny		        iny
.f725	 a5 54		lda $54		        lda  btab+2
.f727	 29 f0		and #$f0	        and  #$f0
.f729	 4a		lsr a		        lsr  a
.f72a	 4a		lsr a		        lsr  a
.f72b	 4a		lsr a		        lsr  a
.f72c	 4a		lsr a		        lsr  a
.f72d	 aa		tax		        tax
.f72e	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f731	 18		clc		        clc
.f732	 6a		ror a		        ror  a
.f733	 05 58		ora $58		        ora  gtab+2
.f735	 91 30		sta ($30),y	        sta  (bufpnt),y
.f737	 c8		iny		        iny
.f738	 6a		ror a		        ror  a
.f739	 29 80		and #$80	        and  #$80
.f73b	 85 59		sta $59		        sta  gtab+3
.f73d	 a5 54		lda $54		        lda  btab+2
.f73f	 29 0f		and #$0f	        and  #$0f
.f741	 aa		tax		        tax
.f742	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f745	 0a		asl a		        asl  a
.f746	 0a		asl a		        asl  a
.f747	 29 7c		and #$7c	        and  #$7c
.f749	 05 59		ora $59		        ora  gtab+3
.f74b	 85 59		sta $59		        sta  gtab+3
.f74d	 a5 55		lda $55		        lda  btab+3
.f74f	 29 f0		and #$f0	        and  #$f0
.f751	 4a		lsr a		        lsr  a
.f752	 4a		lsr a		        lsr  a
.f753	 4a		lsr a		        lsr  a
.f754	 4a		lsr a		        lsr  a
.f755	 aa		tax		        tax
.f756	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f759	 6a		ror a		        ror  a
.f75a	 66 5a		ror $5a		        ror  gtab+4
.f75c	 6a		ror a		        ror  a
.f75d	 66 5a		ror $5a		        ror  gtab+4
.f75f	 6a		ror a		        ror  a
.f760	 66 5a		ror $5a		        ror  gtab+4
.f762	 29 03		and #$03	        and  #$03
.f764	 05 59		ora $59		        ora  gtab+3
.f766	 91 30		sta ($30),y	        sta  (bufpnt),y
.f768	 c8		iny		        iny
.f769	 d0 04		bne $f76f	        bne  bing35
.f76b	 a5 2f		lda $2f		        lda  savpnt+1
.f76d	 85 31		sta $31		        sta  bufpnt+1
.f76f	 a5 55		lda $55		bing35  lda  btab+3
.f771	 29 0f		and #$0f	        and  #$0f
.f773	 aa		tax		        tax
.f774	 bd 7f f7	lda $f77f,x	        lda  bgtab,x
.f777	 05 5a		ora $5a		        ora  gtab+4
.f779	 91 30		sta ($30),y	        sta  (bufpnt),y
.f77b	 c8		iny		        iny
.f77c	 84 34		sty $34		        sty  gcrpnt
.f77e	 60		rts		        rts

>f77f	 0a                       	bgtab   .byte    $0a
>f780	 0b                       		.byte    $0b
>f781	 12                       		.byte    $12
>f782	 13                       		.byte    $13
>f783	 0e                       		.byte    $0e
>f784	 0f                       		.byte    $0f
>f785	 16                       		.byte    $16
>f786	 17                       		.byte    $17
>f787	 09                       		.byte    $09
>f788	 19                       		.byte    $19
>f789	 1a                       		.byte    $1a
>f78a	 1b                       		.byte    $1b
>f78b	 0d                       		.byte    $0d
>f78c	 1d                       		.byte    $1d
>f78d	 1e                       		.byte    $1e
>f78e	 15                       		.byte    $15

.f78f	 a9 00		lda #$00	bingcr  lda  #0         ;  init pointers
.f791	 85 30		sta $30		        sta  bufpnt
.f793	 85 2e		sta $2e		        sta  savpnt
.f795	 85 36		sta $36		        sta  bytcnt
.f797	 a9 bb		lda #$bb	        lda  #256-topwrt
.f799	 85 34		sta $34		        sta  gcrpnt     ;  start saving gcr here
.f79b	 85 50		sta $50		        sta  gcrflg     ;  buffer converted flag
.f79d	 a5 31		lda $31		        lda  bufpnt+1   ;  save buffer pointer
.f79f	 85 2f		sta $2f		        sta  savpnt+1
.f7a1	 a9 01		lda #$01	        lda  #>ovrbuf   ;  point at overflow
.f7a3	 85 31		sta $31		        sta  bufpnt+1
.f7a5	 a5 47		lda $47		        lda  dbid       ;  store data block id
.f7a7	 85 52		sta $52		        sta  btab       ;  and next 3 data bytes
.f7a9	 a4 36		ldy $36		        ldy  bytcnt
.f7ab	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.f7ad	 85 53		sta $53		        sta  btab+1
.f7af	 c8		iny		        iny
.f7b0	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.f7b2	 85 54		sta $54		        sta  btab+2
.f7b4	 c8		iny		        iny
.f7b5	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.f7b7	 85 55		sta $55		        sta  btab+3
.f7b9	 c8		iny		        iny
.f7ba	 84 36		sty $36		bing07  sty  bytcnt     ;  next byte to get
.f7bc	 20 d0 f6	jsr $f6d0	        jsr  put4bg     ;  convert and store
.f7bf	 a4 36		ldy $36		        ldy  bytcnt
.f7c1	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.f7c3	 85 52		sta $52		        sta  btab
.f7c5	 c8		iny		        iny
.f7c6	 f0 11		beq $f7d9	        beq  bing20
.f7c8	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.f7ca	 85 53		sta $53		        sta  btab+1
.f7cc	 c8		iny		        iny
.f7cd	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.f7cf	 85 54		sta $54		        sta  btab+2
.f7d1	 c8		iny		        iny
.f7d2	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.f7d4	 85 55		sta $55		        sta  btab+3
.f7d6	 c8		iny		        iny
.f7d7	 d0 e1		bne $f7ba	        bne  bing07     ;  jmp
.f7d9	 a5 3a		lda $3a		bing20  lda  chksum     ;  store chksum
.f7db	 85 53		sta $53		        sta  btab+1
.f7dd	 a9 00		lda #$00	        lda  #0         ;  store 0 off byte
.f7df	 85 54		sta $54		        sta  btab+2
.f7e1	 85 55		sta $55		        sta  btab+3
.f7e3	 4c d0 f6	jmp $f6d0	        jmp  put4bg     ;  convert and store and return

;******  Return to file "serlib.asm"

					        .include "lccgcrbi.asm"

;******  Processing file "lccgcrbi.asm"

=00f8					mask1=$f8
=0007					mask2=$07
=00c0					mask2x=$c0
=003e					mask3=$3e
=0001					mask4=$01
=00f0					mask4x=$f0
=000f					mask5=$0f
=0080					mask5x=$80
=007c					mask6=$7c
=0003					mask7=$03
=00e0					mask7x=$e0
=001f					mask8=$1f
.f7e6	 a4 34		ldy $34		get4gb  ldy  gcrpnt
.f7e8	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f7ea	 29 f8		and #$f8	        and  #mask1
.f7ec	 4a		lsr a		        lsr  a
.f7ed	 4a		lsr a		        lsr  a
.f7ee	 4a		lsr a		        lsr  a
.f7ef	 85 56		sta $56		        sta  gtab       ;  hi nibble
.f7f1	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f7f3	 29 07		and #$07	        and  #mask2
.f7f5	 0a		asl a		        asl  a
.f7f6	 0a		asl a		        asl  a
.f7f7	 85 57		sta $57		        sta  gtab+1
.f7f9	 c8		iny		        iny       	;  next byte
.f7fa	 d0 06		bne $f802	        bne  xx05       ;  test for next buffer
.f7fc	 a5 4e		lda $4e		        lda  nxtbf
.f7fe	 85 31		sta $31		        sta  bufpnt+1
.f800	 a4 4f		ldy $4f		        ldy  nxtpnt
.f802	 b1 30		lda ($30),y	xx05    lda  (bufpnt),y
.f804	 29 c0		and #$c0	        and  #mask2x
.f806	 2a		rol a		        rol  a
.f807	 2a		rol a		        rol  a
.f808	 2a		rol a		        rol  a
.f809	 05 57		ora $57		        ora  gtab+1
.f80b	 85 57		sta $57		        sta  gtab+1
.f80d	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f80f	 29 3e		and #$3e	        and  #mask3
.f811	 4a		lsr a		        lsr  a
.f812	 85 58		sta $58		        sta  gtab+2
.f814	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f816	 29 01		and #$01	        and  #mask4
.f818	 0a		asl a		        asl  a
.f819	 0a		asl a		        asl  a
.f81a	 0a		asl a		        asl  a
.f81b	 0a		asl a		        asl  a
.f81c	 85 59		sta $59		        sta  gtab+3
.f81e	 c8		iny		        iny     		;  next
.f81f	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f821	 29 f0		and #$f0	        and  #mask4x
.f823	 4a		lsr a		        lsr  a
.f824	 4a		lsr a		        lsr  a
.f825	 4a		lsr a		        lsr  a
.f826	 4a		lsr a		        lsr  a
.f827	 05 59		ora $59		        ora  gtab+3
.f829	 85 59		sta $59		        sta  gtab+3
.f82b	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f82d	 29 0f		and #$0f	        and  #mask5
.f82f	 0a		asl a		        asl  a
.f830	 85 5a		sta $5a		        sta  gtab+4
.f832	 c8		iny		        iny     		;  next byte
.f833	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f835	 29 80		and #$80	        and  #mask5x
.f837	 18		clc		        clc
.f838	 2a		rol a		        rol  a
.f839	 2a		rol a		        rol  a
.f83a	 29 01		and #$01	        and  #1
.f83c	 05 5a		ora $5a		        ora  gtab+4
.f83e	 85 5a		sta $5a		        sta  gtab+4
.f840	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f842	 29 7c		and #$7c	        and  #mask6
.f844	 4a		lsr a		        lsr  a
.f845	 4a		lsr a		        lsr  a
.f846	 85 5b		sta $5b		        sta  gtab+5
.f848	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f84a	 29 03		and #$03	        and  #mask7
.f84c	 0a		asl a		        asl  a
.f84d	 0a		asl a		        asl  a
.f84e	 0a		asl a		        asl  a
.f84f	 85 5c		sta $5c		        sta  gtab+6
.f851	 c8		iny		        iny
.f852	 d0 06		bne $f85a	        bne  xx06
.f854	 a5 4e		lda $4e		        lda  nxtbf
.f856	 85 31		sta $31		        sta  bufpnt+1
.f858	 a4 4f		ldy $4f		        ldy  nxtpnt
.f85a	 b1 30		lda ($30),y	xx06    lda  (bufpnt),y
.f85c	 29 e0		and #$e0	        and  #mask7x
.f85e	 2a		rol a		        rol  a
.f85f	 2a		rol a		        rol  a
.f860	 2a		rol a		        rol  a
.f861	 2a		rol a		        rol  a
.f862	 05 5c		ora $5c		        ora  gtab+6
.f864	 85 5c		sta $5c		        sta  gtab+6
.f866	 b1 30		lda ($30),y	        lda  (bufpnt),y
.f868	 29 1f		and #$1f	        and  #mask8
.f86a	 85 5d		sta $5d		        sta  gtab+7
.f86c	 c8		iny		        iny
.f86d	 84 34		sty $34		        sty  gcrpnt
.f86f	 a6 56		ldx $56		        ldx  gtab
.f871	 bd a0 f8	lda $f8a0,x	        lda  gcrhi,x
.f874	 a6 57		ldx $57		        ldx  gtab+1
.f876	 1d c0 f8	ora $f8c0,x	        ora  gcrlo,x
.f879	 85 52		sta $52		        sta  btab
.f87b	 a6 58		ldx $58		        ldx  gtab+2
.f87d	 bd a0 f8	lda $f8a0,x	        lda  gcrhi,x
.f880	 a6 59		ldx $59		        ldx  gtab+3
.f882	 1d c0 f8	ora $f8c0,x	        ora  gcrlo,x
.f885	 85 53		sta $53		        sta  btab+1
.f887	 a6 5a		ldx $5a		        ldx  gtab+4
.f889	 bd a0 f8	lda $f8a0,x	        lda  gcrhi,x
.f88c	 a6 5b		ldx $5b		        ldx  gtab+5
.f88e	 1d c0 f8	ora $f8c0,x	        ora  gcrlo,x
.f891	 85 54		sta $54		        sta  btab+2
.f893	 a6 5c		ldx $5c		        ldx  gtab+6
.f895	 bd a0 f8	lda $f8a0,x	        lda  gcrhi,x
.f898	 a6 5d		ldx $5d		        ldx  gtab+7
.f89a	 1d c0 f8	ora $f8c0,x	        ora  gcrlo,x
.f89d	 85 55		sta $55		        sta  btab+3
.f89f	 60		rts		        rts

>f8a0	 ff                       	gcrhi   .byte  	$ff    ; error
>f8a1	 ff                       		.byte   $ff    ; error
>f8a2	 ff                       		.byte   $ff    ; error
>f8a3	 ff                       		.byte   $ff    ; error
>f8a4	 ff                       		.byte   $ff    ; error
>f8a5	 ff                       		.byte   $ff    ; error
>f8a6	 ff                       		.byte   $ff    ; error
>f8a7	 ff                       		.byte   $ff    ; error
>f8a8	 ff                       		.byte   $ff    ; error
>f8a9	 80                       		.byte   $80
>f8aa	 00                       		.byte   $00
>f8ab	 10                       		.byte   $10
>f8ac	 ff                       		.byte   $ff    ; error
>f8ad	 c0                       		.byte   $c0
>f8ae	 40                       		.byte   $40
>f8af	 50                       		.byte   $50
>f8b0	 ff                       		.byte   $ff    ; error
>f8b1	 ff                       		.byte   $ff    ; error
>f8b2	 20                       		.byte   $20
>f8b3	 30                       		.byte   $30
>f8b4	 ff                       		.byte   $ff    ; error
>f8b5	 f0                       		.byte   $f0
>f8b6	 60                       		.byte   $60
>f8b7	 70                       		.byte   $70
>f8b8	 ff                       		.byte   $ff    ; error
>f8b9	 90                       		.byte   $90
>f8ba	 a0                       		.byte   $a0
>f8bb	 b0                       		.byte   $b0
>f8bc	 ff                       		.byte   $ff    ; error
>f8bd	 d0                       		.byte   $d0
>f8be	 e0                       		.byte   $e0
>f8bf	 ff                       		.byte   $ff    ; error
>f8c0	 ff                       	gcrlo   .byte   $ff    ; error
>f8c1	 ff                       		.byte   $ff    ; error
>f8c2	 ff                       		.byte   $ff    ; error
>f8c3	 ff                       		.byte   $ff    ; error
>f8c4	 ff                       		.byte   $ff    ; error
>f8c5	 ff                       		.byte   $ff    ; error
>f8c6	 ff                       		.byte   $ff    ; error
>f8c7	 ff                       		.byte   $ff    ; error
>f8c8	 ff                       		.byte   $ff    ; error
>f8c9	 08                       		.byte   8
>f8ca	 00                       		.byte   $00
>f8cb	 01                       		.byte   1
>f8cc	 ff                       		.byte   $ff    ; error
>f8cd	 0c                       		.byte   $c
>f8ce	 04                       		.byte   4
>f8cf	 05                       		.byte   5
>f8d0	 ff                       		.byte   $ff    ; error
>f8d1	 ff                       		.byte   $ff    ; error
>f8d2	 02                       		.byte   2
>f8d3	 03                       		.byte   3
>f8d4	 ff                       		.byte   $ff    ; error
>f8d5	 0f                       		.byte   $f
>f8d6	 06                       		.byte   6
>f8d7	 07                       		.byte   7
>f8d8	 ff                       		.byte   $ff    ; error
>f8d9	 09                       		.byte   9
>f8da	 0a                       		.byte   $a
>f8db	 0b                       		.byte   $b
>f8dc	 ff                       		.byte   $ff    ; error
>f8dd	 0d                       		.byte   $d
>f8de	 0e                       		.byte   $e
>f8df	 ff                       		.byte   $ff    ; error

.f8e0	 a9 00		lda #$00	gcrbin  lda  #0         ;  setup pointers
.f8e2	 85 34		sta $34		        sta  gcrpnt
.f8e4	 85 2e		sta $2e		        sta  savpnt
.f8e6	 85 36		sta $36		        sta  bytcnt
.f8e8	 a9 01		lda #$01	        lda  #>ovrbuf
.f8ea	 85 4e		sta $4e		        sta  nxtbf
.f8ec	 a9 ba		lda #$ba	        lda  #255-toprd
.f8ee	 85 4f		sta $4f		        sta  nxtpnt
.f8f0	 a5 31		lda $31		        lda  bufpnt+1
.f8f2	 85 2f		sta $2f		        sta  savpnt+1
.f8f4	 20 e6 f7	jsr $f7e6	        jsr  get4gb
.f8f7	 a5 52		lda $52		        lda  btab
.f8f9	 85 38		sta $38		        sta  bid        ;  get header id
.f8fb	 a4 36		ldy $36		        ldy  bytcnt
.f8fd	 a5 53		lda $53		        lda  btab+1
.f8ff	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f901	 c8		iny		        iny
.f902	 a5 54		lda $54		        lda  btab+2
.f904	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f906	 c8		iny		        iny
.f907	 a5 55		lda $55		        lda  btab+3
.f909	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f90b	 c8		iny		        iny
.f90c	 84 36		sty $36		gcrb10  sty  bytcnt
.f90e	 20 e6 f7	jsr $f7e6	        jsr  get4gb
.f911	 a4 36		ldy $36		        ldy  bytcnt
.f913	 a5 52		lda $52		        lda  btab
.f915	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f917	 c8		iny		        iny
.f918	 f0 11		beq $f92b	        beq  gcrb20     ;  test if done yet
.f91a	 a5 53		lda $53		        lda  btab+1
.f91c	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f91e	 c8		iny		        iny
.f91f	 a5 54		lda $54		        lda  btab+2
.f921	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f923	 c8		iny		        iny
.f924	 a5 55		lda $55		        lda  btab+3
.f926	 91 2e		sta ($2e),y	        sta  (savpnt),y
.f928	 c8		iny		        iny
.f929	 d0 e1		bne $f90c	        bne  gcrb10     ;  jmp
.f92b					gcrb20
.f92b	 a5 53		lda $53		        lda  btab+1
.f92d	 85 3a		sta $3a		        sta  chksum
.f92f	 a5 2f		lda $2f		        lda  savpnt+1   ; restore buffer pointer
.f931	 85 31		sta $31		        sta  bufpnt+1
.f933	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "lccconhd.asm"

;******  Processing file "lccconhd.asm"

.f934	 a5 31		lda $31		conhdr  lda  bufpnt+1   ; save buffer pointer
.f936	 85 2f		sta $2f		        sta  savpnt+1
.f938	 a9 00		lda #$00	        lda  #>stab
.f93a	 85 31		sta $31		        sta  bufpnt+1
.f93c	 a9 24		lda #$24	        lda  #<stab
.f93e	 85 34		sta $34		        sta  gcrpnt
.f940	 a5 39		lda $39		        lda  hbid
.f942	 85 52		sta $52		        sta  btab
.f944	 a5 1a		lda $1a		        lda  header+4
.f946	 85 53		sta $53		        sta  btab+1
.f948	 a5 19		lda $19		        lda  header+3
.f94a	 85 54		sta $54		        sta  btab+2
.f94c	 a5 18		lda $18		        lda  header+2
.f94e	 85 55		sta $55		        sta  btab+3
.f950	 20 d0 f6	jsr $f6d0	        jsr  put4bg
.f953	 a5 17		lda $17		        lda  header+1
.f955	 85 52		sta $52		        sta  btab
.f957	 a5 16		lda $16		        lda  header
.f959	 85 53		sta $53		        sta  btab+1
.f95b	 a9 00		lda #$00	        lda  #0
.f95d	 85 54		sta $54		        sta  btab+2
.f95f	 85 55		sta $55		        sta  btab+3
.f961	 20 d0 f6	jsr $f6d0	        jsr  put4bg
.f964	 a5 2f		lda $2f		        lda  savpnt+1   ; restore buffer pointer
.f966	 85 31		sta $31		        sta  bufpnt+1
.f968	 60		rts		        rts

;******  Return to file "serlib.asm"

						.include "lccutil.asm"

;******  Processing file "lccutil.asm"

.f969	 a4 3f		ldy $3f		errr    ldy  jobn       ;  return  job code
.f96b	 99 00 00	sta $0000,y	        sta  jobs,y
.f96e	 a5 50		lda $50		        lda  gcrflg     ;  test if buffer left gcr
.f970	 f0 03		beq $f975	        beq  errr10     ;  no
.f972	 20 f2 f5	jsr $f5f2	        jsr  wtobin     ;  convert back to binary
.f975					errr10
.f975	 20 8f f9	jsr $f98f	        jsr  trnoff     ;  start timeout on drive
.f978	 a6 49		ldx $49		        ldx  savsp
.f97a	 9a		txs		        txs     	;  reset stack pointer
.f97b	 4c be f2	jmp $f2be	        jmp  top        ;  back to the top
.f97e	 a9 a0		lda #$a0	turnon  lda  #$a0       ;  turn on drive
.f980	 85 20		sta $20		        sta  drvst
.f982	 ad 00 1c	lda $1c00	        lda  dskcnt     ;  turn motor on and select drive
.f985	 09 04		ora #$04	        ora  #$04       ;  turn motor on
.f987	 8d 00 1c	sta $1c00	        sta  dskcnt
.f98a	 a9 32		lda #$32	        lda  #50	;  delay  .4 sec *** rom ds 04/17/85 ***
.f98c	 85 48		sta $48		        sta  acltim
.f98e	 60		rts		        rts
.f98f	 a6 3e		ldx $3e		trnoff  ldx  cdrive     ;  start time out of current drive
.f991	 a5 20		lda $20		        lda  drvst      ; status=timeout
.f993	 09 10		ora #$10	        ora  #$10
.f995	 85 20		sta $20		        sta  drvst
.f997	 4c 2b a6	jmp $a62b		jmp  ptch20	; setup timers for timeout *rom-05ds 01/22/85*
.f99a	 ea		nop			nop		; fill
.f99b	 ea		nop			nop		; fill

;******  Return to file "serlib.asm"

					        .include "lccend.asm"

;******  Processing file "lccend.asm"

.f99c					end
.f99c	 ad 07 1c	lda $1c07	        lda  t1hl2      ; set irq timer
.f99f	 8d 05 1c	sta $1c05	        sta  t1hc2
.f9a2	 ad 00 1c	lda $1c00	        lda  dskcnt
.f9a5	 29 10		and #$10	        and  #$10       ;  test write proctect
.f9a7	 c5 1e		cmp $1e		        cmp  lwpt
.f9a9	 85 1e		sta $1e		        sta  lwpt       ;  change ?
.f9ab	 4c 34 a6	jmp $a634		jmp  ptch21	;  do auto on code *** rom ds 01/22/85 ***
.f9ae	 ea		nop			nop		;  fill
.f9af	 ea		nop			nop		;  fill
.f9b0	 ea		nop			nop		;  fill
.f9b1					rtch21
.f9b1	 ad fe 02	lda $02fe	end002  lda  phase      ;  test for phase offset
.f9b4	 f0 15		beq $f9cb	        beq  end40
.f9b6	 c9 02		cmp #$02	        cmp  #2
.f9b8	 d0 07		bne $f9c1	        bne  end003
.f9ba	 a9 00		lda #$00	        lda  #0         ; phase <-- 0
.f9bc	 8d fe 02	sta $02fe	        sta  phase
.f9bf	 f0 0a		beq $f9cb	        beq  end40
.f9c1	 85 4a		sta $4a		end003  sta  steps
.f9c3	 a9 02		lda #$02	        lda  #2         ; phase <-- 2
.f9c5	 8d fe 02	sta $02fe	        sta  phase
.f9c8	 4c 2e fa	jmp $fa2e	        jmp  dostep
.f9cb	 a6 3e		ldx $3e		end40   ldx  cdrive     ;  work on active drive only
.f9cd	 30 07		bmi $f9d6	        bmi  end33x     ;  no active drive
.f9cf	 a5 20		lda $20		        lda  drvst      ;  test if motor on
.f9d1	 a8		tay		        tay
.f9d2	 c9 20		cmp #$20	        cmp  #$20       ;  test if anything to do
.f9d4	 d0 03		bne $f9d9	        bne  end10      ;  something here
.f9d6	 4c be fa	jmp $fabe	end33x  jmp  end33      ;  motor just running
.f9d9	 c6 48		dec $48		end10   dec  acltim     ;  dec timer
.f9db	 d0 1d		bne $f9fa	        bne  end30
.f9dd	 98		tya		        tya     	;  test if acel
.f9de	 10 04		bpl $f9e4	        bpl  end20
.f9e0	 29 7f		and #$7f	        and  #$7f       ;  over, clear acel bit
.f9e2	 85 20		sta $20		        sta  drvst
.f9e4	 29 10		and #$10	end20   and  #$10       ;  test if time out state
.f9e6	 f0 12		beq $f9fa	        beq  end30
.f9e8	 c6 35		dec $35			dec  acltim2	;  timer2 *rom-05ds 01/22/85*
.f9ea	 d0 0e		bne $f9fa		bne  end30
.f9ec	 ea		nop			nop		;  fill
.f9ed	 20 70 87	jsr $8770		jsr  motoff	;  off the motor, ok...
.f9f0	 a9 ff		lda #$ff	        lda  #$ff       ;  no active drive now
.f9f2	 85 3e		sta $3e		        sta  cdrive
.f9f4	 a9 00		lda #$00	        lda  #0         ;  drive inactive
.f9f6	 85 20		sta $20		        sta  drvst      ;  clear on bit and timout
.f9f8	 f0 dc		beq $f9d6	        beq  end33x
.f9fa	 98		tya		end30   tya     	;  test if step needed
.f9fb	 29 40		and #$40	        and  #$40
.f9fd	 d0 03		bne $fa02	        bne  end30x     ;  stepping
.f9ff	 4c be fa	jmp $fabe	        jmp  end33
.fa02	 6c 62 00	jmp ($0062)	end30x  jmp  (nxtst)    ; goto proper stepper state
.fa05	 a5 4a		lda $4a		inact   lda  steps      ;  get abs(steps)
.fa07	 10 05		bpl $fa0e	        bpl  inac10
.fa09	 49 ff		eor #$ff	        eor  #$ff
.fa0b	 18		clc		        clc
.fa0c	 69 01		adc #$01	        adc  #1
.fa0e	 c5 64		cmp $64		inac10  cmp  minstp     ;  test if we can accel
.fa10	 b0 0a		bcs $fa1c	        bcs  inac20     ;  too small
.fa12	 a9 3b		lda #$3b	        lda  #<short    ; short step mode
.fa14	 85 62		sta $62		        sta  nxtst
.fa16	 a9 fa		lda #$fa	        lda  #>short
.fa18	 85 63		sta $63		        sta  nxtst+1
.fa1a	 d0 12		bne $fa2e	        bne  dostep
.fa1c					inac20
.fa1c	 e5 5e		sbc $5e		        sbc  as
.fa1e	 e5 5e		sbc $5e		        sbc  as
.fa20	 85 61		sta $61		        sta  rsteps
.fa22	 a5 5e		lda $5e		        lda  as
.fa24	 85 60		sta $60		        sta  aclstp     ;  set  # of accel steps
.fa26	 a9 7b		lda #$7b	        lda  #<ssacl
.fa28	 85 62		sta $62		        sta  nxtst
.fa2a	 a9 fa		lda #$fa	        lda  #>ssacl
.fa2c	 85 63		sta $63		        sta  nxtst+1
.fa2e	 a5 4a		lda $4a		dostep  lda  steps
.fa30	 10 31		bpl $fa63	        bpl  stpin
.fa32	 4c 45 ff	jmp $ff45	stpout  jmp  patch9     ; check track 0 (photo sensor)
.fa35	 ea		nop		        nop     	;
.fa36	 ea		nop		        nop     	;
.fa37	 ea		nop		        nop     	;
.fa38	 4c 69 fa	jmp $fa69	pppppp  jmp  stp        ; goto step
.fa3b	 a5 4a		lda $4a		short   lda  steps      ; step end ?
.fa3d	 d0 ef		bne $fa2e	        bne  dostep     ; no
.fa3f	 a9 4e		lda #$4e	        lda  #<setle    ; settle
.fa41	 85 62		sta $62		        sta  nxtst
.fa43	 a9 fa		lda #$fa	        lda  #>setle
.fa45	 85 63		sta $63		        sta  nxtst+1
.fa47	 a9 05		lda #$05	        lda  #5         ;  settle time (5*8=40ms)
.fa49	 85 60		sta $60		        sta  aclstp
.fa4b	 4c be fa	jmp $fabe	        jmp  end33
.fa4e	 c6 60		dec $60		setle   dec  aclstp     ;  settle end ?
.fa50	 d0 6c		bne $fabe	        bne  end33      ;  no
.fa52	 a5 20		lda $20		        lda  drvst
.fa54	 29 bf		and #$bf	        and  #$ff-$40
.fa56	 85 20		sta $20		        sta  drvst
.fa58	 a9 05		lda #$05	        lda  #<inact
.fa5a	 85 62		sta $62		        sta  nxtst
.fa5c	 a9 fa		lda #$fa	        lda  #>inact
.fa5e	 85 63		sta $63		        sta  nxtst+1
.fa60	 4c be fa	jmp $fabe	        jmp  end33
.fa63	 c6 4a		dec $4a		stpin   dec  steps
.fa65	 ae 00 1c	ldx $1c00	        ldx  dskcnt
.fa68	 e8		inx		        inx
.fa69	 8a		txa		stp     txa
.fa6a	 29 03		and #$03	        and  #3
.fa6c	 85 4b		sta $4b		        sta  tmp
.fa6e	 ad 00 1c	lda $1c00	        lda  dskcnt
.fa71	 29 fc		and #$fc	        and  #$ff-$03   ;  mask out old
.fa73	 05 4b		ora $4b		        ora  tmp
.fa75	 8d 00 1c	sta $1c00	        sta  dskcnt
.fa78	 4c be fa	jmp $fabe	        jmp  end33
.fa7b					ssacl
.fa7b	 38		sec		        sec
.fa7c	 ad 07 1c	lda $1c07	        lda  t1hl2
.fa7f	 e5 5f		sbc $5f		        sbc  af
.fa81	 8d 05 1c	sta $1c05	        sta  t1hc2
.fa84	 c6 60		dec $60		        dec  aclstp
.fa86	 d0 0c		bne $fa94	        bne  ssa10
.fa88	 a5 5e		lda $5e		        lda  as
.fa8a	 85 60		sta $60		        sta  aclstp
.fa8c	 a9 97		lda #$97	        lda  #<ssrun
.fa8e	 85 62		sta $62		        sta  nxtst
.fa90	 a9 fa		lda #$fa	        lda  #>ssrun
.fa92	 85 63		sta $63		        sta  nxtst+1
.fa94	 4c 2e fa	jmp $fa2e	ssa10   jmp  dostep
.fa97	 c6 61		dec $61		ssrun   dec  rsteps
.fa99	 d0 f9		bne $fa94	        bne  ssa10
.fa9b	 a9 a5		lda #$a5	        lda  #<ssdec
.fa9d	 85 62		sta $62		        sta  nxtst
.fa9f	 a9 fa		lda #$fa	        lda  #>ssdec
.faa1	 85 63		sta $63		        sta  nxtst+1
.faa3	 d0 ef		bne $fa94	        bne  ssa10
.faa5					ssdec
.faa5	 ad 07 1c	lda $1c07	        lda  t1hl2
.faa8	 18		clc		        clc
.faa9	 65 5f		adc $5f		        adc  af
.faab	 8d 05 1c	sta $1c05	        sta  t1hc2
.faae	 c6 60		dec $60		        dec  aclstp
.fab0	 d0 e2		bne $fa94	        bne  ssa10
.fab2	 a9 4e		lda #$4e	        lda  #<setle    ;  goto settle mode
.fab4	 85 62		sta $62		        sta  nxtst
.fab6	 a9 fa		lda #$fa	        lda  #>setle
.fab8	 85 63		sta $63		        sta  nxtst+1
.faba	 a9 05		lda #$05	        lda  #5
.fabc	 85 60		sta $60		        sta  aclstp     ;  settle timer
.fabe	 ad 0c 1c	lda $1c0c	end33   lda  pcr2       ;  disable s.o. to 6502
.fac1	 29 fd		and #$fd	        and  #$ff-$02
.fac3	 8d 0c 1c	sta $1c0c	        sta  pcr2
.fac6	 60		rts		        rts

;******  Return to file "serlib.asm"

					        .include "lccfmt1.asm"

;******  Processing file "lccfmt1.asm"

=0620					fmtvar   =  $620        ;  put format vars in jump buffer
=0620					cnt      =  fmtvar
=0621					num      =  fmtvar+1
=0623					trys     =  fmtvar+3
=0624					tral     =  fmtvar+4
=0626					dtrck    =  fmtvar+6
=0627					remdr    =  fmtvar+7
=0628					sect     =  fmtvar+8
.fac7					code
.fac7	 a5 51		lda $51		formt   lda  ftnum      ;  test if formatting begun
.fac9	 10 2a		bpl $faf5	        bpl  l213       ;  yes
.facb	 a6 3d		ldx $3d		        ldx  drive      ;  no,start up by bumping
.facd	 a9 60		lda #$60	        lda  #$60       ;  status=stepping
.facf	 95 20		sta $20,x	        sta  drvst,x
.fad1	 a9 01		lda #$01	        lda  #1         ;  drive track =1
.fad3	 95 22		sta $22,x	        sta  drvtrk,x
.fad5	 85 51		sta $51		        sta  ftnum      ;  start on track 1
.fad7	 a9 a4		lda #$a4	        lda  #256-92    ;  bump back 45 steps
.fad9	 85 4a		sta $4a		        sta  steps
.fadb	 ad 00 1c	lda $1c00	        lda  dskcnt     ; set phase a
.fade	 29 fc		and #$fc	        and  #$ff-$03
.fae0	 8d 00 1c	sta $1c00	        sta  dskcnt
.fae3	 a9 0a		lda #$0a	        lda  #10        ;  10 errors allowed
.fae5	 8d 20 06	sta $0620	        sta  cnt
.fae8	 a9 a0		lda #$a0	        lda  #<4000     ;  first guess at track size
.faea	 8d 21 06	sta $0621	        sta  num
.faed	 a9 0f		lda #$0f	        lda  #>4000
.faef	 8d 22 06	sta $0622	        sta  num+1
.faf2	 4c 9c f9	jmp $f99c	        jmp  end        ;  back to controller
.faf5	 a0 00		ldy #$00	l213    ldy  #0         ;  test if on right track number
.faf7	 d1 32		cmp ($32),y	        cmp  (hdrpnt),y
.faf9	 f0 05		beq $fb00	        beq  l214
.fafb	 91 32		sta ($32),y	        sta  (hdrpnt),y ;  goto right track
.fafd	 4c 9c f9	jmp $f99c	        jmp  end
.fb00	 ad 00 1c	lda $1c00	l214    lda  dskcnt     ;  test for write protect
.fb03	 29 10		and #$10	        and  #$10
.fb05	 d0 05		bne $fb0c	        bne  topp       ;  its ok
.fb07	 a9 08		lda #$08	        lda  #8         ;  write protect error
.fb09	 4c d3 fd	jmp $fdd3	        jmp  fmterr
.fb0c	 20 a3 fd	jsr $fda3	topp    jsr  synclr     ;  erase track with sync
.fb0f	 20 c3 fd	jsr $fdc3	        jsr  wrtnum     ;  write out num syncs
.fb12	 a9 55		lda #$55	        lda  #$55       ;  write out num non sync
.fb14	 8d 01 1c	sta $1c01	        sta  data2
.fb17	 20 c3 fd	jsr $fdc3	        jsr  wrtnum
.fb1a	 20 00 fe	jsr $fe00	        jsr  kill       ;  kill write
.fb1d	 20 56 f5	jsr $f556	        jsr  sync       ;  find sync
.fb20	 a9 40		lda #$40	        lda  #$40       ;  set timer mode
.fb22	 0d 0b 18	ora $180b	        ora  acr1
.fb25	 8d 0b 18	sta $180b	        sta  acr1
.fb28	 a9 62		lda #$62	        lda  #100-2     ;  set up 100us timer
.fb2a	 8d 06 18	sta $1806	        sta  t1ll1      ;  cont mode timer
.fb2d	 a9 00		lda #$00	        lda  #0
.fb2f	 8d 07 18	sta $1807	        sta  t1hl1      ;  hi latch
.fb32	 8d 05 18	sta $1805	        sta  t1hc1      ;  get attention of '22
.fb35	 a0 00		ldy #$00	        ldy  #0         ;  time the sync and nonsync segments
.fb37	 a2 00		ldx #$00	        ldx  #0
.fb39	 2c 00 1c	bit $1c00	fwait   bit  dskcnt     ;  wait for sync
.fb3c	 30 fb		bmi $fb39	        bmi  fwait
.fb3e	 2c 00 1c	bit $1c00	fwait2  bit  dskcnt     ;  wait for no sync
.fb41	 10 fb		bpl $fb3e	        bpl  fwait2
.fb43	 ad 04 18	lda $1804	f000    lda  t1lc1      ;  reset ifr
.fb46	 2c 00 1c	bit $1c00	f001    bit  dskcnt     ;  time nonsync area
.fb49	 10 11		bpl $fb5c	        bpl  f005       ;  time until sync found
.fb4b	 ad 0d 18	lda $180d	        lda  ifr1       ;  test for time out
.fb4e	 0a		asl a		        asl  a
.fb4f	 10 f5		bpl $fb46	        bpl  f001       ;  not yet
.fb51	 e8		inx		        inx     	;  .x is lsb
.fb52	 d0 ef		bne $fb43	        bne  f000
.fb54	 c8		iny		        iny     	;  .y is msb
.fb55	 d0 ec		bne $fb43	        bne  f000
.fb57	 a9 02		lda #$02	        lda  #tolong    ;  cant find sync
.fb59	 4c d3 fd	jmp $fdd3	        jmp  fmterr
.fb5c	 86 71		stx $71		f005    stx  t2         ;  save time
.fb5e	 84 72		sty $72		        sty  t2+1
.fb60	 a2 00		ldx #$00	        ldx  #0         ;  time sync area
.fb62	 a0 00		ldy #$00	        ldy  #0
.fb64	 ad 04 18	lda $1804	f006    lda  t1lc1      ;  reset ifr
.fb67	 2c 00 1c	bit $1c00	f007    bit  dskcnt     ;  test for  no sync
.fb6a	 30 11		bmi $fb7d	        bmi  f009
.fb6c	 ad 0d 18	lda $180d	        lda  ifr1       ;  test for time out
.fb6f	 0a		asl a		        asl  a
.fb70	 10 f5		bpl $fb67	        bpl  f007
.fb72	 e8		inx		        inx     	;  count up another 100us
.fb73	 d0 ef		bne $fb64	        bne  f006
.fb75	 c8		iny		        iny     	;  msb
.fb76	 d0 ec		bne $fb64	        bne  f006
.fb78	 a9 02		lda #$02	        lda  #tolong    ;  cant be this long
.fb7a	 4c d3 fd	jmp $fdd3	        jmp  fmterr
.fb7d	 38		sec		f009    sec     	;  t1-t2
.fb7e	 8a		txa		        txa
.fb7f	 e5 71		sbc $71		        sbc  t2
.fb81	 aa		tax		        tax
.fb82	 85 70		sta $70		        sta  t1
.fb84	 98		tya		        tya
.fb85	 e5 72		sbc $72		        sbc  t2+1
.fb87	 a8		tay		        tay
.fb88	 85 71		sta $71		        sta  t1+1
.fb8a	 10 0b		bpl $fb97	        bpl  f013       ;  get abs(t1-t2)
.fb8c	 49 ff		eor #$ff	        eor  #$ff       ;  make +
.fb8e	 a8		tay		        tay
.fb8f	 8a		txa		        txa
.fb90	 49 ff		eor #$ff	        eor  #$ff
.fb92	 aa		tax		        tax
.fb93	 e8		inx		        inx
.fb94	 d0 01		bne $fb97	        bne  f013
.fb96	 c8		iny		        iny
.fb97	 98		tya		f013    tya     	;  test if abs(t1-t2)<4, that is close enough
.fb98	 d0 04		bne $fb9e	        bne  f014       ;  msb must be 0
.fb9a	 e0 04		cpx #$04	        cpx  #4         ;  test lsb < 4
.fb9c	 90 18		bcc $fbb6	        bcc  count      ;  its there
.fb9e	 06 70		asl $70		f014    asl  t1         ;  num=num+(diff/2)
.fba0	 26 71		rol $71		        rol  t1+1
.fba2	 18		clc		        clc
.fba3	 a5 70		lda $70		        lda  t1
.fba5	 6d 21 06	adc $0621	        adc  num
.fba8	 8d 21 06	sta $0621	        sta  num
.fbab	 a5 71		lda $71		        lda  t1+1
.fbad	 6d 22 06	adc $0622	        adc  num+1
.fbb0	 8d 22 06	sta $0622	        sta  num+1
.fbb3	 4c 0c fb	jmp $fb0c	        jmp  topp       ;  try again sam
.fbb6	 a2 00		ldx #$00	count   ldx  #0         ;  now count #bytes in data segment
.fbb8	 a0 00		ldy #$00	        ldy  #0
.fbba	 b8		clv		        clv
.fbbb	 ad 00 1c	lda $1c00	cnt10   lda  dskcnt     ;  test for sync
.fbbe	 10 0e		bpl $fbce	        bpl  cnt20      ;  found sync
.fbc0	 50 f9		bvc $fbbb	        bvc  cnt10      ;  test if byte time
.fbc2	 b8		clv		        clv     	;  yes, count it
.fbc3	 e8		inx		        inx
.fbc4	 d0 f5		bne $fbbb	        bne  cnt10      ;  keep counting
.fbc6	 c8		iny		        iny
.fbc7	 d0 f2		bne $fbbb	        bne  cnt10      ;  to many ?
.fbc9	 a9 03		lda #$03	        lda  #tomany    ;  tomany counts
.fbcb	 4c d3 fd	jmp $fdd3	        jmp  fmterr
.fbce	 8a		txa		cnt20   txa     	;  #bytes=count*2
.fbcf	 0a		asl a		        asl  a
.fbd0	 8d 25 06	sta $0625	        sta  tral+1
.fbd3	 98		tya		        tya
.fbd4	 2a		rol a		        rol  a
.fbd5	 8d 24 06	sta $0624	        sta  tral
.fbd8	 a9 bf		lda #$bf	        lda  #$ff-$40   ;  clear cont mode
.fbda	 2d 0b 18	and $180b	        and  acr1
.fbdd	 8d 0b 18	sta $180b	        sta  acr1

;******  Return to file "serlib.asm"

					        .include "lccfmt2.asm"

;******  Processing file "lccfmt2.asm"

.fbe0	 a9 66		lda #$66	ds08    lda  #$66       ;  min block size 282*5/4 -256=85
.fbe2	 8d 26 06	sta $0626	        sta  dtrck
.fbe5	 a6 43		ldx $43		        ldx  sectr      ;  total bytes= min*#secors
.fbe7	 a0 00		ldy #$00	        ldy  #0
.fbe9	 98		tya		        tya
.fbea	 18		clc		ds10    clc     	;  min*#sectors
.fbeb	 6d 26 06	adc $0626	        adc  dtrck
.fbee	 90 01		bcc $fbf1	        bcc  ds14
.fbf0	 c8		iny		        iny
.fbf1	 c8		iny		ds14    iny
.fbf2	 ca		dex		        dex
.fbf3	 d0 f5		bne $fbea	        bne  ds10
.fbf5	 49 ff		eor #$ff	        eor  #$ff       ;  get 2s comp
.fbf7	 38		sec		        sec
.fbf8	 69 00		adc #$00	        adc  #0
.fbfa	 18		clc		        clc
.fbfb	 6d 25 06	adc $0625	        adc  tral+1
.fbfe	 b0 03		bcs $fc03	        bcs  ds15
.fc00	 ce 24 06	dec $0624	        dec  tral
.fc03	 aa		tax		ds15    tax
.fc04	 98		tya		        tya
.fc05	 49 ff		eor #$ff	        eor  #$ff
.fc07	 38		sec		        sec
.fc08	 69 00		adc #$00	        adc  #0
.fc0a	 18		clc		        clc
.fc0b	 6d 24 06	adc $0624	        adc  tral
.fc0e	 10 05		bpl $fc15	        bpl  ds17
.fc10	 a9 04		lda #$04	        lda  #tobig     ;  not enough space
.fc12	 4c d3 fd	jmp $fdd3	        jmp  fmterr
.fc15	 a8		tay		ds17    tay
.fc16	 8a		txa		        txa
.fc17	 a2 00		ldx #$00	        ldx  #0
.fc19	 38		sec		ds20    sec
.fc1a	 e5 43		sbc $43		        sbc  sectr
.fc1c	 b0 03		bcs $fc21	        bcs  ds22
.fc1e	 88		dey		        dey
.fc1f	 30 03		bmi $fc24	        bmi  ds30
.fc21	 e8		inx		ds22    inx
.fc22	 d0 f5		bne $fc19	        bne  ds20
.fc24	 8e 26 06	stx $0626	ds30    stx  dtrck
.fc27	 e0 04		cpx #$04	        cpx  #gap2      ;  test for min size
.fc29	 b0 05		bcs $fc30	        bcs  ds32
.fc2b	 a9 05		lda #$05	        lda  #tosmal    ;  gap2 to small
.fc2d	 4c d3 fd	jmp $fdd3	        jmp  fmterr
.fc30	 18		clc		ds32    clc
.fc31	 65 43		adc $43		        adc  sectr
.fc33	 8d 27 06	sta $0627	        sta  remdr      ;  get remaider size
.fc36	 a9 00		lda #$00	        lda  #0
.fc38	 8d 28 06	sta $0628	        sta  sect
.fc3b	 a0 00		ldy #$00	        ldy  #0
.fc3d	 a6 3d		ldx $3d		        ldx  drive
.fc3f	 a5 39		lda $39		mak10   lda  hbid       ;  hbid cs s t id id 0f 0f
.fc41	 99 00 03	sta $0300,y	        sta  buff0,y
.fc44	 c8		iny		        iny
.fc45	 c8		iny		        iny     	;  skip checksum
.fc46	 ad 28 06	lda $0628	        lda  sect       ;  store sector #
.fc49	 99 00 03	sta $0300,y	        sta  buff0,y
.fc4c	 c8		iny		        iny
.fc4d	 a5 51		lda $51		        lda  ftnum      ;  store track #
.fc4f	 99 00 03	sta $0300,y	        sta  buff0,y
.fc52	 c8		iny		        iny
.fc53	 b5 13		lda $13,x	        lda  dskid+1,x  ;  store id low
.fc55	 99 00 03	sta $0300,y	        sta  buff0,y
.fc58	 c8		iny		        iny
.fc59	 b5 12		lda $12,x	        lda  dskid,x    ;  store id hi
.fc5b	 99 00 03	sta $0300,y	        sta  buff0,y
.fc5e	 c8		iny		        iny
.fc5f	 a9 0f		lda #$0f	        lda  #$0f       ;  store gap1 bytes
.fc61	 99 00 03	sta $0300,y	        sta  buff0,y
.fc64	 c8		iny		        iny
.fc65	 99 00 03	sta $0300,y	        sta  buff0,y
.fc68	 c8		iny		        iny
.fc69	 a9 00		lda #$00	        lda  #0         ; create checksum
.fc6b	 59 fa 02	eor $02fa,y	        eor  buff0-6,y
.fc6e	 59 fb 02	eor $02fb,y	        eor  buff0-5,y
.fc71	 59 fc 02	eor $02fc,y	        eor  buff0-4,y
.fc74	 59 fd 02	eor $02fd,y	        eor  buff0-3,y
.fc77	 99 f9 02	sta $02f9,y	        sta  buff0-7,y  ;  store checksum
.fc7a	 ee 28 06	inc $0628	        inc  sect       ;  goto next sector
.fc7d	 ad 28 06	lda $0628	        lda  sect       ;  test if done yet
.fc80	 c5 43		cmp $43		        cmp  sectr
.fc82	 90 bb		bcc $fc3f	        bcc  mak10      ;  more to do
.fc84	 98		tya		        tya     	;  save block size
.fc85	 48		pha		        pha
.fc86	 e8		inx		        inx     	;  .x=0
.fc87	 8a		txa		        txa
.fc88	 9d 00 05	sta $0500,x	crtdat  sta  buff2,x
.fc8b	 e8		inx		        inx
.fc8c	 d0 fa		bne $fc88	        bne  crtdat
.fc8e	 a9 03		lda #$03	        lda  #>buff0
.fc90	 85 31		sta $31		        sta  bufpnt+1   ;  point at buffer
.fc92	 20 30 fe	jsr $fe30	        jsr  fbtog      ;  convert to gcr with no bid char
.fc95	 68		pla		        pla     	;   restore block size
.fc96	 a8		tay		        tay     	;  move buffer up 79 bytes
.fc97	 88		dey		        dey     	;  for i=n-1 to 0:mem+i+69|:=mem+i|:next
.fc98	 20 e5 fd	jsr $fde5	        jsr  movup      ;  move buf0 up 69 bytes
.fc9b	 20 f5 fd	jsr $fdf5	        jsr  movovr     ;  move ovrbuf up to buffer
.fc9e	 a9 05		lda #$05	        lda  #>buff2    ;  point at buffer
.fca0	 85 31		sta $31		        sta  bufpnt+1
.fca2	 20 e9 f5	jsr $f5e9	        jsr  chkblk     ;  get block checksum
.fca5	 85 3a		sta $3a		        sta  chksum
.fca7	 20 8f f7	jsr $f78f	        jsr  bingcr
.fcaa	 a9 00		lda #$00	        lda  #0         ;  init counter
.fcac	 85 32		sta $32		        sta  hdrpnt
.fcae	 20 0e fe	jsr $fe0e	        jsr  clear      ;  clear disk
.fcb1	 a9 ff		lda #$ff	wrtsyn  lda  #$ff       ;  write sync
.fcb3	 8d 01 1c	sta $1c01	        sta  data2
.fcb6	 a2 05		ldx #$05	        ldx  #numsyn    ;  write 4  sync
.fcb8	 50 fe		bvc $fcb8	wrts10  bvc  *
.fcba	 b8		clv		        clv
.fcbb	 ca		dex		        dex
.fcbc	 d0 fa		bne $fcb8	        bne  wrts10
.fcbe	 a2 0a		ldx #$0a	        ldx  #10        ;  write out header
.fcc0	 a4 32		ldy $32		        ldy  hdrpnt
.fcc2	 50 fe		bvc $fcc2	wrts20  bvc  *
.fcc4	 b8		clv		        clv
.fcc5	 b9 00 03	lda $0300,y	        lda  buff0,y    ;  get header data
.fcc8	 8d 01 1c	sta $1c01	        sta  data2
.fccb	 c8		iny		        iny
.fccc	 ca		dex		        dex
.fccd	 d0 f3		bne $fcc2	        bne  wrts20
.fccf	 a2 09		ldx #$09	        ldx  #gap1-2    ;  write  gcr bytes
.fcd1	 50 fe		bvc $fcd1	wrts30  bvc  *
.fcd3	 b8		clv		        clv
.fcd4	 a9 55		lda #$55	        lda  #$55
.fcd6	 8d 01 1c	sta $1c01	        sta  data2
.fcd9	 ca		dex		        dex
.fcda	 d0 f5		bne $fcd1	        bne  wrts30
.fcdc	 a9 ff		lda #$ff	        lda  #$ff       ;  write data block sync
.fcde	 a2 05		ldx #$05	        ldx  #numsyn
.fce0	 50 fe		bvc $fce0	dbsync  bvc  *
.fce2	 b8		clv		        clv
.fce3	 8d 01 1c	sta $1c01	        sta  data2
.fce6	 ca		dex		        dex
.fce7	 d0 f7		bne $fce0	        bne  dbsync
.fce9	 a2 bb		ldx #$bb	        ldx  #256-topwrt ;  write out ovrbuf
.fceb	 50 fe		bvc $fceb	wrts40  bvc  *
.fced	 b8		clv		        clv
.fcee	 bd 00 01	lda $0100,x	        lda  ovrbuf,x
.fcf1	 8d 01 1c	sta $1c01	        sta  data2
.fcf4	 e8		inx		        inx
.fcf5	 d0 f4		bne $fceb	        bne  wrts40
.fcf7	 a0 00		ldy #$00	        ldy  #0
.fcf9	 50 fe		bvc $fcf9	wrts50  bvc  *
.fcfb	 b8		clv		        clv
.fcfc	 b1 30		lda ($30),y	        lda  (bufpnt),y
.fcfe	 8d 01 1c	sta $1c01	        sta  data2
.fd01	 c8		iny		        iny
.fd02	 d0 f5		bne $fcf9	        bne  wrts50
.fd04	 a9 55		lda #$55	        lda  #$55       ;  write gap2(dtrck)
.fd06	 ae 26 06	ldx $0626	        ldx  dtrck
.fd09	 50 fe		bvc $fd09	wgp2    bvc  *
.fd0b	 b8		clv		        clv
.fd0c	 8d 01 1c	sta $1c01	        sta  data2
.fd0f	 ca		dex		        dex
.fd10	 d0 f7		bne $fd09	        bne  wgp2
.fd12	 a5 32		lda $32		        lda  hdrpnt     ;  advance header pointer
.fd14	 18		clc		        clc
.fd15	 69 0a		adc #$0a	        adc  #10
.fd17	 85 32		sta $32		        sta  hdrpnt
.fd19	 ce 28 06	dec $0628	        dec  sect       ;  go to next on
.fd1c	 d0 93		bne $fcb1	        bne  wrtsyn     ;  more to do
.fd1e	 50 fe		bvc $fd1e	        bvc  *          ;  wait for last one to write
.fd20	 b8		clv		        clv
.fd21	 50 fe		bvc $fd21	        bvc  *
.fd23	 b8		clv		        clv
.fd24	 20 00 fe	jsr $fe00	        jsr  kill       ;  goto read mode

;******  Return to file "serlib.asm"

					        .include "lccfmt3.asm"

;******  Processing file "lccfmt3.asm"

.fd27	 a9 c8		lda #$c8	        lda  #200       ;  look at 200 syncs
.fd29	 8d 23 06	sta $0623	        sta  trys
.fd2c	 a9 00		lda #$00	comp    lda  #0         ;  pointer into headers
.fd2e	 85 30		sta $30		        sta  bufpnt
.fd30	 a9 03		lda #$03	        lda  #>buff0
.fd32	 85 31		sta $31		        sta  bufpnt+1
.fd34	 a5 43		lda $43		        lda  sectr      ;  sector counter
.fd36	 8d 28 06	sta $0628	        sta  sect
.fd39	 20 56 f5	jsr $f556	cmpr10  jsr  sync       ;  find sync
.fd3c	 a2 0a		ldx #$0a	        ldx  #10
.fd3e	 a0 00		ldy #$00	        ldy  #0
.fd40	 50 fe		bvc $fd40	cmpr15  bvc  *          ;  get header byte
.fd42	 b8		clv		        clv
.fd43	 ad 01 1c	lda $1c01	        lda  data2
.fd46	 d1 30		cmp ($30),y	        cmp  (bufpnt),y ;  compare gcr
.fd48	 d0 0e		bne $fd58	        bne  cmpr20     ; error
.fd4a	 c8		iny		        iny
.fd4b	 ca		dex		        dex
.fd4c	 d0 f2		bne $fd40	        bne  cmpr15     ;  test all bytes
.fd4e	 18		clc		        clc     	;  update headr pointer
.fd4f	 a5 30		lda $30		        lda  bufpnt
.fd51	 69 0a		adc #$0a	        adc  #10
.fd53	 85 30		sta $30		        sta  bufpnt
.fd55	 4c 62 fd	jmp $fd62	        jmp  tstdat     ;  now test data
.fd58	 ce 23 06	dec $0623	cmpr20  dec  trys       ;  test if too many errors
.fd5b	 d0 cf		bne $fd2c	        bne  comp
.fd5d	 a9 06		lda #$06	        lda  #notfnd    ;  too many error
.fd5f	 4c d3 fd	jmp $fdd3	        jmp  fmterr
.fd62	 20 56 f5	jsr $f556	tstdat  jsr  sync       ;  find data sync
.fd65	 a0 bb		ldy #$bb	        ldy  #256-topwrt
.fd67	 50 fe		bvc $fd67	tst05   bvc  *
.fd69	 b8		clv		        clv
.fd6a	 ad 01 1c	lda $1c01	        lda  data2      ;  compare gcr
.fd6d	 d9 00 01	cmp $0100,y	        cmp  ovrbuf,y
.fd70	 d0 e6		bne $fd58	        bne  cmpr20     ;  error
.fd72	 c8		iny		        iny
.fd73	 d0 f2		bne $fd67	        bne  tst05      ;  do all ovrbuf
.fd75	 a2 fc		ldx #$fc	        ldx  #255-3     ;  now do buffer, dont test off bytes
.fd77	 50 fe		bvc $fd77	tst10   bvc  *
.fd79	 b8		clv		        clv
.fd7a	 ad 01 1c	lda $1c01	        lda  data2
.fd7d	 d9 00 05	cmp $0500,y	        cmp  buff2,y
.fd80	 d0 d6		bne $fd58	        bne  cmpr20
.fd82	 c8		iny		        iny
.fd83	 ca		dex		        dex
.fd84	 d0 f1		bne $fd77	        bne  tst10
.fd86	 ce 28 06	dec $0628	        dec  sect       ;  more sectors to test?
.fd89	 d0 ae		bne $fd39	        bne  cmpr10     ;  yes
.fd8b	 e6 51		inc $51		        inc  ftnum      ;  goto next track
.fd8d	 a5 51		lda $51		        lda  ftnum
.fd8f	 c9 24		cmp #$24	        cmp  #36        ;  #tracks max
.fd91	 b0 03		bcs $fd96	        bcs  fmtend
.fd93	 4c 9c f9	jmp $f99c	        jmp  end        ;  more to do
.fd96	 a9 ff		lda #$ff	fmtend  lda  #$ff       ;  clear ftnum
.fd98	 85 51		sta $51		        sta  ftnum
.fd9a	 a9 00		lda #$00	        lda  #$0        ;  clear gcr buffer flag
.fd9c	 85 50		sta $50		        sta  gcrflg
.fd9e	 a9 01		lda #$01	        lda  #1         ;  return ok code
.fda0	 4c 69 f9	jmp $f969	        jmp  errr

;******  Return to file "serlib.asm"

					        .include "lccfmt4.asm"

;******  Processing file "lccfmt4.asm"

.fda3	 ad 0c 1c	lda $1c0c	synclr  lda  pcr2       ;  write entire track with sync
.fda6	 29 1f		and #$1f	        and  #$ff-$e0
.fda8	 09 c0		ora #$c0	        ora  #$c0
.fdaa	 8d 0c 1c	sta $1c0c	        sta  pcr2
.fdad	 a9 ff		lda #$ff	        lda  #$ff       ;  output mode ddr
.fdaf	 8d 03 1c	sta $1c03	        sta  ddra2
.fdb2	 8d 01 1c	sta $1c01	        sta  data2      ;  sync char
.fdb5	 a2 28		ldx #$28	        ldx  #$28       ;  $28*256 bytes
.fdb7	 a0 00		ldy #$00	        ldy  #0
.fdb9	 50 fe		bvc $fdb9	syc10   bvc  *
.fdbb	 b8		clv		        clv
.fdbc	 88		dey		        dey
.fdbd	 d0 fa		bne $fdb9	        bne  syc10
.fdbf	 ca		dex		        dex
.fdc0	 d0 f7		bne $fdb9	        bne  syc10
.fdc2	 60		rts		        rts     	;  leave write on
.fdc3	 ae 21 06	ldx $0621	wrtnum  ldx  num        ;  write out num bytes
.fdc6	 ac 22 06	ldy $0622	        ldy  num+1
.fdc9	 50 fe		bvc $fdc9	wrtn10  bvc  *
.fdcb	 b8		clv		        clv
.fdcc	 ca		dex		        dex
.fdcd	 d0 fa		bne $fdc9	        bne  wrtn10
.fdcf	 88		dey		        dey
.fdd0	 10 f7		bpl $fdc9	        bpl  wrtn10
.fdd2	 60		rts		        rts
.fdd3	 ce 20 06	dec $0620	fmterr  dec  cnt        ;  test for retry
.fdd6	 f0 03		beq $fddb	        beq  fmte10
.fdd8	 4c 9c f9	jmp $f99c	        jmp  end
.fddb					fmte10
.fddb	 a0 ff		ldy #$ff	        ldy  #$ff
.fddd	 84 51		sty $51		        sty  ftnum      ;  clear format
.fddf	 c8		iny		        iny
.fde0	 84 50		sty $50		        sty  gcrflg
.fde2	 4c 69 f9	jmp $f969	        jmp  errr
.fde5	 b9 00 03	lda $0300,y	movup   lda  buff0,y    ;   move up 69 bytes
.fde8	 99 45 03	sta $0345,y	        sta  buff0+69,y ;  move from top down
.fdeb	 88		dey		        dey
.fdec	 d0 f7		bne $fde5	        bne  movup
.fdee	 ad 00 03	lda $0300	        lda  buff0      ;  do last byte
.fdf1	 8d 45 03	sta $0345	        sta  buff0+69
.fdf4	 60		rts		        rts
.fdf5	 a0 44		ldy #$44	movovr  ldy  #68        ;  move ovrbuf into (buffer)
.fdf7	 b9 bb 01	lda $01bb,y	movo10  lda  ovrbuf+256-topwrt,y
.fdfa	 91 30		sta ($30),y	        sta  (bufpnt),y
.fdfc	 88		dey		        dey
.fdfd	 10 f8		bpl $fdf7	        bpl  movo10
.fdff	 60		rts		        rts
.fe00	 ad 0c 1c	lda $1c0c	kill    lda  pcr2       ;  disable write
.fe03	 09 e0		ora #$e0	        ora  #$e0
.fe05	 8d 0c 1c	sta $1c0c	        sta  pcr2
.fe08	 a9 00		lda #$00	        lda  #$00       ;  make port input now
.fe0a	 8d 03 1c	sta $1c03	        sta  ddra2
.fe0d	 60		rts		        rts
.fe0e	 ad 0c 1c	lda $1c0c	clear   lda  pcr2       ;  enable write
.fe11	 29 1f		and #$1f	        and  #$ff-$e0
.fe13	 09 c0		ora #$c0	        ora  #$c0
.fe15	 8d 0c 1c	sta $1c0c	        sta  pcr2
.fe18	 a9 ff		lda #$ff	        lda  #$ff       ;  make port an output
.fe1a	 8d 03 1c	sta $1c03	        sta  ddra2
.fe1d	 a9 55		lda #$55	        lda  #$55       ;  write a 1f pattern
.fe1f	 8d 01 1c	sta $1c01	        sta  data2
.fe22	 a2 28		ldx #$28	        ldx  #$28       ;  $28*256 chars
.fe24	 a0 00		ldy #$00	        ldy  #00
.fe26	 50 fe		bvc $fe26	cler10  bvc  *
.fe28	 b8		clv		        clv
.fe29	 88		dey		        dey
.fe2a	 d0 fa		bne $fe26	        bne  cler10
.fe2c	 ca		dex		        dex
.fe2d	 d0 f7		bne $fe26	        bne  cler10
.fe2f	 60		rts		        rts
.fe30	 a9 00		lda #$00	fbtog   lda  #0         ;  point at buffer
.fe32	 85 30		sta $30		        sta  bufpnt
.fe34	 85 2e		sta $2e		        sta  savpnt
.fe36	 85 36		sta $36		        sta  bytcnt
.fe38	 a9 bb		lda #$bb	        lda  #256-topwrt ;  put gcr in ovrflow buffer
.fe3a	 85 34		sta $34		        sta  gcrpnt
.fe3c	 a5 31		lda $31		        lda  bufpnt+1   ;  save buffer pointer
.fe3e	 85 2f		sta $2f		        sta  savpnt+1
.fe40	 a9 01		lda #$01	        lda  #>ovrbuf
.fe42	 85 31		sta $31		        sta  bufpnt+1   ;  store in overbuf
.fe44	 a4 36		ldy $36		fbg10   ldy  bytcnt     ;  get pointer
.fe46	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.fe48	 85 52		sta $52		        sta  btab
.fe4a	 c8		iny		        iny
.fe4b	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.fe4d	 85 53		sta $53		        sta  btab+1
.fe4f	 c8		iny		        iny
.fe50	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.fe52	 85 54		sta $54		        sta  btab+2
.fe54	 c8		iny		        iny
.fe55	 b1 2e		lda ($2e),y	        lda  (savpnt),y
.fe57	 85 55		sta $55		        sta  btab+3
.fe59	 c8		iny		        iny
.fe5a	 f0 08		beq $fe64	        beq  fbg15      ;  test if done
.fe5c	 84 36		sty $36		        sty  bytcnt     ;  save pointer
.fe5e	 20 d0 f6	jsr $f6d0	        jsr  put4bg     ;  convert and store
.fe61	 4c 44 fe	jmp $fe44	        jmp  fbg10
.fe64	 4c d0 f6	jmp $f6d0	fbg15   jmp  put4bg     ;  done, return

;******  Return to file "serlib.asm"

						.include "irq.asm"

;******  Processing file "irq.asm"

.fe67	 6c a9 02	jmp ($02a9)	sysirq  jmp  (irqjmp)	;  irq vector ***rom ds 02/01/85***
.fe6a	 98		tya		        tya
.fe6b	 48		pha		        pha      	;  save .y
.fe6c	 ad 0d 18	lda $180d	        lda  ifr1       ;  test if atn
.fe6f	 29 02		and #$02	        and  #2
.fe71	 f0 03		beq $fe76	        beq  +		;  not atn
.fe73	 20 53 e8	jsr $e853	        jsr  atnirq     ;  handle atn request
.fe76	 ad 0d 1c	lda $1c0d	+	lda  ifr2       ;  test if timer
.fe79	 0a		asl a		        asl  a
.fe7a	 10 03		bpl $fe7f	        bpl  +		;  not timer
.fe7c	 20 b0 f2	jsr $f2b0	        jsr  lcc        ;  goto controller
.fe7f	 68		pla		+	pla     	;  restore .y,.x,.a
.fe80	 a8		tay		        tay
.fe81	 68		pla		        pla
.fe82	 aa		tax		        tax
.fe83	 68		pla		        pla
.fe84	 40		rti		        rti

;******  Return to file "serlib.asm"

						.include "romtblsf.asm"

;******  Processing file "romtblsf.asm"


>fe85	 12                       	dirtrk   .byte  18      ; directory track #
>fe86	 04                       	bamsiz   .byte  4       ; # bytes/track in bam
>fe87	 04                       	mapoff   .byte  4       ; offset of bam in sector
>fe88	 90                       	dsknam   .byte  $90     ; offset of disk name in bam sector
>fe89	 56 49 44 4d 42 55 50 26 	cmdtbl   .text  'VIDMBUP&CRSN'
>fe91	 43 52 53 4e 
=000c					ncmds    =*-cmdtbl
>fe95	 84 05 c1                 	cjumpl   .byte    <verdir,<intdrv,<duplct
>fe98	 f8 1b 5c                 		 .byte    <mem,<block,<user
>fe9b	 07                       		 .byte    <record
>fe9c	 a3                       		 .byte    <utlodr
>fe9d	 f0                       		 .byte    <dskcpy
>fe9e	 88 23 0d                 		 .byte    <rename,<scrtch,<new

>fea1	 ed d0 c8                 	cjumph   .byte    >verdir,>intdrv,>duplct
>fea4	 ca cc cb                 		 .byte    >mem,>block,>user
>fea7	 e2                       	 	 .byte    >record
>fea8	 e7                       	 	 .byte    >utlodr
>fea9	 c8                       	 	 .byte    >dskcpy
>feaa	 ca c8 ee                 		 .byte    >rename,>scrtch,>new
=0000					val=0           ; validate (verify) cmd #
=0009					pcmd     =9

>fead	 51                       		.byte    %01010001      ;  dskcpy
=fea5					struct   =*-pcmd        	;  cmds not parsed
>feae	 dd                       		.byte    %11011101      ;  rename
>feaf	 1c                       		.byte    %00011100      ;  scratch
>feb0	 9e                       		.byte    %10011110      ;  new
=000c					ldcmd    =*-struct      	;  load cmd image
>feb1	 1c                       		.byte    %00011100      ;  load
>feb2	 52 57 41 4d              	modlst   .text  'RWAM'          ;  mode table
=0004					nmodes   =*-modlst
>feb6	 44 53 50 55 4c           	tplst    .text  'DSPUL'
>febb	 44 53 50 55 52           	typlst   .text  'DSPUR'         ; del, seq, prog, user, relative
=0005					ntypes   =*-typlst
>fec0	 45 45 52 53 45           	tp1lst   .text  'EERSE'
>fec5	 4c 51 47 52 4c           	tp2lst   .text  'LQGRL'
>feca	 08 00                    	ledmsk   .byte  led0,led1
>fecc	 00                       	er00     .byte  0
>fecd	 3f                       	er0      .byte  $3f
>fece	 7f                       	er1      .byte  $7f
>fecf	 bf                       	er2      .byte  $bf
>fed0	 ff                       	er3      .byte  $ff

.fed1					numsec

>fed1	 11 12 13 15              		 .byte    17,18,19,21
>fed5	 41                       	vernum   .byte  fm4040          ; format type
>fed6	 04                       	nzones   .byte  4       	; # of zones

.fed7					trknum

>fed7	 24 1f 19 12              		 .byte    36,31,25,18

.fedb					offset

>fedb	 01 ff ff 01 00           		 .byte    1,$ff,$ff,1,0

.fee0					bufind

>fee0	 03 04 05 06 07 07        		 .byte    $03,$04,$05,$06,$07,$07

;******  Return to file "serlib.asm"

						.include "patch.asm"

;******  Processing file "patch.asm"

>fee6	 ff                       	dchksum	.byte $ff

.fee7	 6c 65 00	jmp ($0065)	jnmi	jmp (vnmi)
.feea	 8d 00 1c	sta $1c00	pea7a   sta  ledprt
.feed	 8d 02 1c	sta $1c02	        sta  ddrb2
.fef0	 4c 7d ea	jmp $ea7d	        jmp  rea7d
.fef3	 8a		txa		slowd   txa             ; only affect .a
.fef4	 a2 05		ldx #$05		ldx  #5         ; insert 20us of delay with this routine
.fef6	 ca		dex		-       dex
.fef7	 d0 fd		bne $fef6		bne  -
.fef9	 aa		tax			tax
.fefa	 60		rts			rts
.fefb	 20 ae e9	jsr $e9ae	patch4  jsr  clklo
.fefe	 4c 9c e9	jmp $e99c		jmp  dathi
.ff01					nnmi
.ff01	 ad 02 02	lda $0202		lda  cmdbuf+2   ; new nmi routine check for
.ff04	 c9 2d		cmp #$2d		cmp  #'-'
.ff06	 f0 05		beq $ff0d		beq  m1         ; if ui- then no delay
.ff08	 38		sec			sec
.ff09	 e9 2b		sbc #$2b		sbc  #'+'
.ff0b	 d0 da		bne $fee7		bne  jnmi       ; if not ui+ then must be a real ui command
.ff0d	 85 23		sta $23		m1      sta  slflag     ; set/clr slow flag
.ff0f	 60		rts			rts
.ff10	 8e 03 18	stx $1803	patch5  stx  ddra1
.ff13	 a9 02		lda #$02	        lda  #2
.ff15	 4c 5a a6	jmp $a65a	        jmp  ptch22
.ff18	 a9 1a		lda #$1a	ptch22r lda  #$1a
.ff1a	 8d 02 18	sta $1802	        sta  ddrb1
.ff1d	 4c a7 ea	jmp $eaa7	        jmp  dkit10
.ff20					patch6
.ff20	 ad 00 18	lda $1800	-       lda  pb
.ff23	 29 01		and #$01	        and  #1
.ff25	 d0 f9		bne $ff20	        bne  -
.ff27	 a9 01		lda #$01	        lda  #1
.ff29	 8d 05 18	sta $1805	        sta  timer1
.ff2c	 4c df e9	jmp $e9df	        jmp  acptr.rptch6
.ff2f	 a9 ff		lda #$ff	patch7  lda  #255
.ff31	 85 51		sta $51			sta  ftnum
.ff33	 ad 0f 18	lda $180f		lda  pota1
.ff36	 29 20		and #$20		and  #$20
.ff38	 d0 03		bne $ff3d		bne  +
.ff3a	 a9 24		lda #$24		lda  #36

>ff3c	 2c                       		.byte skip2

.ff3d	 a9 47		lda #$47	+	lda  #71
.ff3f	 8d ac 02	sta $02ac		sta  maxtrk
.ff42	 4c 79 a7	jmp $a779	        jmp  ptch28
.ff45					patch9
.ff45	 98		tya			tya
.ff46	 48		pha		        pha
.ff47	 a0 64		ldy #$64	    	ldy  #100
.ff49	 ad 0f 18	lda $180f	-    	lda  pota1
.ff4c	 6a		ror a		    	ror  a
.ff4d	 08		php		    	php
.ff4e	 ad 0f 18	lda $180f	    	lda  pota1
.ff51	 6a		ror a		    	ror  a
.ff52	 6a		ror a		    	ror  a
.ff53	 28		plp		    	plp
.ff54	 29 80		and #$80	    	and  #$80
.ff56	 90 04		bcc $ff5c	    	bcc  +
.ff58	 10 1d		bpl $ff77	    	bpl  m2
.ff5a	 30 02		bmi $ff5e	    	bmi  m1
.ff5c	 30 19		bmi $ff77	+    	bmi  m2
.ff5e	 88		dey		m1	dey
.ff5f	 d0 e8		bne $ff49		bne  -
.ff61	 b0 14		bcs $ff77		bcs  m2
.ff63	 ad 00 1c	lda $1c00		lda  dskcnt
.ff66	 29 03		and #$03		and  #3
.ff68	 d0 0d		bne $ff77		bne  m2
.ff6a	 a5 7b		lda $7b			lda  adrsed
.ff6c	 d0 09		bne $ff77		bne  m2
.ff6e	 68		pla			pla
.ff6f	 a8		tay			tay
.ff70	 a9 00		lda #$00		lda  #0
.ff72	 85 4a		sta $4a			sta  steps
.ff74	 4c be fa	jmp $fabe		jmp  end33
.ff77	 68		pla		m2	pla
.ff78	 a8		tay			tay
.ff79	 e6 4a		inc $4a			inc  steps
.ff7b	 ae 00 1c	ldx $1c00		ldx  dskcnt
.ff7e	 ca		dex			dex
.ff7f	 4c 38 fa	jmp $fa38		jmp  pppppp
.ff82	 20 59 f2	jsr $f259	ptch10  jsr  cntint
.ff85	 a9 05		lda #$05	        lda  #5
.ff87	 85 3c		sta $3c		        sta  cpmit
.ff89	 a9 88		lda #$88	        lda  #<irq
.ff8b	 8d a9 02	sta $02a9	        sta  irqjmp
.ff8e	 a9 9d		lda #$9d	        lda  #>irq
.ff90	 8d aa 02	sta $02aa	        sta  irqjmp+1
.ff93	 a9 24		lda #$24	        lda  #36
.ff95	 8d ac 02	sta $02ac	        sta  maxtrk
.ff98	 18		clc		        clc
.ff99	 4c f3 93	jmp $93f3	        jmp  set_side
.ff9c	 85 ff		sta $ff		ptch11  sta  nodrv
.ff9e	 4c 00 c1	jmp $c100	        jmp  setlds
.ffa1	 85 7b		sta $7b		ptch12  sta  adrsed
.ffa3	 4c 76 d6	jmp $d676	        jmp  hedoff
.ffa6	 20 76 d6	jsr $d676	ptch13  jsr  hedoff
.ffa9	 a9 00		lda #$00	        lda  #0
.ffab	 85 7b		sta $7b		        sta  adrsed
.ffad	 60		rts		        rts
.ffae	 a4 82		ldy $82		ptch15  ldy  lindx
.ffb0	 4c de d3	jmp $d3de	        jmp  rndget

;******  Return to file "serlib.asm"

						.include "vects.asm"

;******  Processing file "vects.asm"


>ffe6	 c6 c8                    		.word    format
>ffe8	 8f f9                    		.word    trnoff
>ffea	 5f cd                    	ublock  .word    ublkrd
>ffec	 97 cd                    		.word    ublkwt
>ffee	 00 05                    		.word    $0500   ; links to buffer #2
>fff0	 03 05                    		.word    $0503
>fff2	 06 05                    		.word    $0506
>fff4	 09 05                    		.word    $0509
>fff6	 0c 05                    		.word    $050c
>fff8	 0f 05                    		.word    $050f

>fffa	 01 ff                    		.word    nnmi
>fffc	 a0 ea                    		.word    dskint
>fffe	 67 fe                    		.word    sysirq

;******  Return to file "serlib.asm"

					        .include "newvec.asm"

;******  Processing file "newvec.asm"


.bf00	 4c 88 9d	jmp $9d88		jmp  irq
.bf03	 4c de 9d	jmp $9dde		jmp  jirq
.bf06	 4c b0 f2	jmp $f2b0		jmp  lcc
.bf09	 4c ba 92	jmp $92ba		jmp  jlcc
.bf0c	 4c 93 f3	jmp $f393		jmp  setjb
.bf0f	 4c d1 93	jmp $93d1		jmp  jsetjb
.bf12	 4c 69 f9	jmp $f969		jmp  errr
.bf15	 4c b5 99	jmp $99b5		jmp  jerrr
.bf18	 4c 00 fe	jmp $fe00		jmp  kill
.bf1b	 4c 34 f9	jmp $f934		jmp  conhdr
.bf1e	 4c 56 f5	jmp $f556		jmp  sync
.bf21	 4c 54 97	jmp $9754		jmp  jsync
.bf24	 4c e0 f8	jmp $f8e0		jmp  gcrbin
.bf27	 4c 65 99	jmp $9965		jmp  jgcrbin
.bf2a	 4c e9 f5	jmp $f5e9		jmp  chkblk
.bf2d	 4c e6 f7	jmp $f7e6		jmp  get4gb
.bf30	 4c d9 98	jmp $98d9		jmp  jget4gb
.bf33	 4c 83 a4	jmp $a483		jmp  jslowd
.bf36	 4c f3 fe	jmp $fef3		jmp  slowd
.bf39	 4c 7e a4	jmp $a47e		jmp  jslower
.bf3c	 4c 05 f0	jmp $f005		jmp  clrbam
.bf3f	 4c d1 f0	jmp $f0d1		jmp  clnbam
.bf42	 4c 46 c1	jmp $c146		jmp  parsxq
.bf45	 4c 68 c2	jmp $c268		jmp  parse
.bf48	 4c b3 c2	jmp $c2b3		jmp  cmdset
.bf4b	 4c dc c2	jmp $c2dc		jmp  cmdrst
.bf4e	 4c e6 86	jmp $86e6		jmp  prcmd
.bf51	 4c 64 87	jmp $8764		jmp  moton
.bf54	 4c 70 87	jmp $8770		jmp  motoff
.bf57	 ad 8e 80	lda $808e		lda  cmdtbb
.bf5a	 4c 1e cf	jmp $cf1e		jmp  dblbuf
.bf5d	 4c b4 d7	jmp $d7b4		jmp  open
.bf60	 4c c0 da	jmp $dac0		jmp  close
.bf63	 4c 0a e6	jmp $e60a		jmp  error
.bf66	 4c 80 90	jmp $9080		jmp  fstload
.bf69	 4c 4e 92	jmp $924e		jmp  signature
.bf6c	 4c 59 f2	jmp $f259		jmp  cntint
.bf6f	 4c 9c f9	jmp $f99c		jmp  end
.bf72	 4c ca 99	jmp $99ca		jmp  jend
.bf75	 ad 95 fe	lda $fe95		lda  cjumpl

>bf96	 c8 86                    		.word cmdjmp

;******  Return to file "serlib.asm"


;******  end of code
